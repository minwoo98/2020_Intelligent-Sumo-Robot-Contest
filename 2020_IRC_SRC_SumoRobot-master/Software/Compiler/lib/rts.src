!<arch>
IQ.asm/         1146129404  0     0     0       607       `
;******************************************************************************
;* IQ v4.1.3                                                                  *
;* Copyright (c) 2002-2006 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* IQ.ASM
;****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "IQ28.inc"
        .endif

IQ28.inc/       1146129404  0     0     0       4132      `
;******************************************************************************
;* IQ CONSTRUCTOR CODE FOR C28X v4.1.3                                        *
;* Copyright (c) 2002-2006 Texas Instruments Incorporated                     *
;******************************************************************************
	.sect	".text"
	.global	__IQ
        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW
	.asg   AR5, 	   INP_N
	.asg   AR4, 	   EXP  

__IQ:	.asmfunc
	MOVZ	  INP_N, AL		; Save N
	MOVL	  ACC, OP1_MSW		; Load the input into ACC:P
	MOVL	  P,   OP1_LSW		;
        CMP64     ACC:P                 ; Clear V flag
        CMP64     ACC:P                 ; check for 0
	B         EXIT,EQ

	MOVL      XAR7,ACC              ; save upper half of A in XAR7

	ASR	  AH,15
	MOVZ      AR6,AH                ; save sign in AR6

	MOVL	  ACC,XAR7              ; find the exp
        LSR       AH,4                  
        AND       AH,AH,#0x7ff              
	MOV	  AL,AH
	MOVB      AH,#0
	SETC      SXM
        ADD       ACC,#-1023            ; ACC contains the exp
	CLRC      SXM
	B         NEG_EXP,LT            ; branch if exp < 0

	MOVZ      EXP,AL                ; save exp in AR5

        MOVB      AL,#30                ; determine if exp > (30 - N)
	SUB       AL,INP_N              ; AL contains (30 - N)
	MOV       AH,EXP
	SUB       AH,AL                 ; AH contains (exp - (30 - N))
	B         SATURATE,GT           ; saturate if int val >= I bits
	B         FIND_I,UNC

NEG_EXP:
	NEG       AL
	MOVZ      EXP,AL                ; save exp in AR5
	SUBB	  AL,#1                 ; exp - 1 = number of leading zeros
	SUB       AL,INP_N
	B         ZERO_RESULT,GT        ; return 0 number of leading 0's > Q

        MOVL      ACC,XAR7
	ANDB      AH,#0xf               ; zero sign and exp
	ADD       AH,#0x10              ; add implied 1
	LSL64     ACC:P,#0xb            ; shift frac << 11
	MOVL      XAR7,ACC              ; save frac in XAR6:XAR7
	MOV       AH,EXP                ; shift = (exp - 1)
	SUBB      AH,#1
	MOV       T,AH
	MOVL      ACC,XAR7
	LSR64     ACC:P,T               ; shift frac >> (exp - 1)
	MOVL      P,ACC                 ; move frac to P
	MOVB      ACC,#0                ; set I to 0
	MOVL      XAR7,ACC              ; save result back to XAR6:XAR7
	B         FIND_RESULT,UNC

FIND_I:
        MOVL      ACC,XAR7              ; move int from XAR7 to ACC
        ANDB      AH,#0xf               ; clear sign and exp
	ADD 	  AH,#0x10              ; add implied 1 
	LSL64     ACC:P,#0xb            ; shift << 11
	MOVL	  XAR7,ACC		

        MOVB      AL,#31                ; find shift amount
        SUB       AL,EXP                ; shift = 31 - exp
        MOV       T,AL                   
        MOVL      ACC,XAR7           
        LSR64     ACC:P,T               ; shift >> (31 - exp);
        MOVL      XAR7,ACC              

FIND_RESULT:
	MOVL      ACC,XAR7              ; move I to ACC

	MOV	  T,INP_N
	LSL64	  ACC:P,T               ; shift I:Q by N

        TBIT      PH,#15                ; check if must round result
	B         CHECK_SIGN,NTC

	TBIT      AR6,#0
	B         ROUND,TC              ; round negative results

	MOV       PL,#65535
	MOV       PH,#32767
	CMPL      ACC,P
	B         CHECK_SIGN,EQ         ; Don't round if result is saturated

ROUND:
	ADDB      ACC,#1                ; round ACC

CHECK_SIGN:	
        TBIT	  AR6,#0                ; check sign bit
	B	  EXIT,NTC              ; negate result if necessary

	NEG       ACC                   ; negate result
	B 	  EXIT,UNC

ZERO_RESULT:
	MOVB	  ACC,#0
	B         EXIT,UNC

SATURATE:
        MOV       AL,AR6
	B         UNDERFLOW,NEQ

        MOV       AH,#32767
        MOV       AL,#65535             ; return 0x7fffffff
        B         EXIT,UNC              

UNDERFLOW:
        MOV       AH,#32768
        MOV       AL,#0                 ; return 0x80000000
        B         EXIT,UNC               

EXIT:    
        LRETR
	.endasmfunc
IQxmpy.asm/     1146129405  0     0     0       615       `
;******************************************************************************
;* IQXMPY  v4.1.3                                                             *
;* Copyright (c) 2002-2006 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* IQXMPY.ASM
;****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "IQxmpy28.inc"
        .endif

IQxmpy28.inc/   1146129405  0     0     0       1780      `
;******************************************************************************
;* IQ XMPY CODE FOR C28X v4.1.3                                               *
;* Copyright (c) 2002-2006 Texas Instruments Incorporated                     *
;*                                                                            *
;* __IQXMPY  - Implementation of __IQxmpy() intrinsic when N is not a         *
;*             constant.                                                      *
;******************************************************************************
;* __IQxmpy(long A, long B, int N)                                            *
;*                                          A is in ACC                       *
;*                                          B is in *-SP[4]                   *
;*                                          N is in AR4                       *
;* Result is returned in ACC.                                                 *
;******************************************************************************

	.sect	".text"
	.global	__IQXMPY

__IQXMPY:	.asmfunc
        MOVL XAR7,ACC          ; save A
	MOV  AL,AR4            ; test N 
	SB $10,LT
        MOVL XT,XAR7           ; N is positive
	IMPYL P,XT,*-SP[4]     ; calculate A * B = 64-bits result
	QMPYL ACC,XT,*-SP[4]
	MOV T,AR4              ; 
	LSL64 ACC:P,T          ; scale the result by N and return in ACC.
        LRETR

$10:                           ; N is negative
        NEG AL                 ; negate N
        MOV AR4,AL       
        MOVL XT,XAR7
	IMPYL P,XT,*-SP[4]     ; calculate A * B = 64-bits result
	QMPYL ACC,XT,*-SP[4]
	MOV T,AR4
	ASR64 ACC:P,T          ; scale the result by N and return in ACC.
        LRETR

	.endasmfunc

Makefile_eh.inc/1146129405  0     0     0       11422     `
#------------------------------------------------------------------------------
# Generic shared makefile.  File lists and lib prefixes should be set up
# by target specific Makefile, which then includes this one.
#------------------------------------------------------------------------------
PLATFORM := $(shell uname)
 
ifeq ($(PLATFORM),Windows_95)
  PLATFORM=Windows_NT
endif
ifeq ($(PLATFORM),Windows_98)
  PLATFORM=Windows_NT
endif
ifeq ($(PLATFORM),Interix)
  PLATFORM=Windows_NT
endif

VPATH=SHARED EDGRTS MATH

LNAME             = fake
DIR               = $(patsubst %_eh,%,$(LNAME))
INCLUDES          = -i. $(patsubst %,-I%,$(VPATH))
LIBNAMES          = $(patsubst %,rts%.lib,$(NAMES))
EH_LIBNAMES       = $(patsubst %,rts%_eh.lib,$(NAMES))
CLFLAGS           = $($(LNAME)_OPT) -qq -o

# The -k below is important!! When building a library for release, we
# want to make sure the FILE symbol within each object file actually
# refers to an assembly file name we can recognize.  This helps
# with debugging and with error messages for the user.  If we did
# not use the -k here, all the C files would get temporary assembly
# files in the temp file directory, and the names would all be
# random and unrecognizable!!
#
# More info: This is especially required for when a user does
# absolute listing, as the absolute listed uses those filename
# symbols for doing inclusions.  If we do not use the -k here,
# then the absolute lister will try to include the temporary
# asm file names!
#
#
# Feb-20-2002 CMW - Added the -oe flag to enable embedding the icode.  This
# is to support Bob Franko and the XDC project so they do not need to keep
# recompiling the RTS to to Alchemy link-time optimization with an updated
# icode.
#
# Apr-02-2003 DJD - Added the "--ti_lib" switch, which will categorize all
# functions as library functions in the DWARF information.  Specifically, the
# current motivation for this is to provide CCS's profile server a way to
# filter out RTS/BIOS/RTDX functions if the end user wishes not to see them.
#
COMMON_CFLAGS = -pdsw225 -ps -k -oe --ti_lib
CFLAGS     = $(CLFLAGS) $(APPEND) $(COMMON_CFLAGS)

MAKEFLAGS += -E

# We don't like $EH_LIBNAMES, since they're built automatically for $LIBNAMES
all: $(LIBNAMES) rts.src

# If this is dependant on rts$(LNAME).lib in any way, we'll get double
# file build (corruption) for any all rule which lists both forms.
# This is only here so users can type the XX_eh.lib name and not cause
# an infinite loop in the rule following!  CMW
rts%_eh.lib: rts%.lib
	@echo Next time, build rts$*.lib and $@ will also be built for you.
	exit 0

# We pass on the path to take care of errors on the PC where it reinitialized
# the path under gmake sometimes, losing the setting we made before starting.
rts%.lib: FORCE
	mkdir -p $(patsubst %_eh,%,$*) $(patsubst %_eh,%,$*)/EDG $(patsubst %_eh,%,$*)/EH $(patsubst %_eh,%,$*)/NONEH
	@$(MAKE) PATH="$(PATH)" -f Makefile $@ LNAME=$*

#------------------------------------------------------------------------------
# Create object list, putting files into appropriate subdirs
#------------------------------------------------------------------------------
COMMON_OBJ = $(patsubst %,%.obj,$(COMMONFUNCS))

EH_EDG_OBJ = $(patsubst %,%.obj,$(_EDG_CPP_FUNCS))
NONEH_EDG_OBJ = $(patsubst %,%.obj,$(_EDG_CPP_FUNCS))

COMMON_DIROBJ = $(patsubst %,$(DIR)/%,$(COMMON_OBJ))
EH_EDG_DIROBJ     = $(patsubst %,$(DIR)/EH/%,$(EH_EDG_OBJ))
NONEH_EDG_DIROBJ  = $(patsubst %,$(DIR)/NONEH/%,$(NONEH_EDG_OBJ))

#------------------------------------------------------------------------------
# Build the libraries.
# (We do a topc/tounix to make sure the rts.src files are viewable after
#  extraction by an end user.  We CANNOT topc them in place, as they are
#  mostly symbolic links into subdirectories containing the source files.)
# (We also use ar cmd files to perform the archiving because the command
#  line gets way too long on the PC.)
#------------------------------------------------------------------------------

# rts.src DOES NOT include the EDG exception handling source files!! CMW

rts.src: $(patsubst %,%.c,$(_C_FUNCS))     \
	 $(patsubst %,%.asm,$(_ASMFUNCS)) \
	 $(patsubst %,%.sa,$(_SAFUNCS))   \
	 $(patsubst %,%.cpp,$(_EDG_CPP_FUNCS)) \
	 $(HEADERS) $(INTERNAL_HEADERS)
	mkdir -p _rtssrc && rm -f _rtssrc/* && cp $^ _rtssrc
ifeq ($(PLATFORM),Windows_NT)
	cd _rtssrc && topc -c *
else
	cd _rtssrc && tounix -c *
endif
	cd _rtssrc && rm -f ar.cmd $@ && echo "-qa $@ $(sort $(notdir $^))" > ar.cmd
	cd _rtssrc && $(AR) @ar.cmd && mv $@ ..
	rm -f _rtssrc/*

rts$(LNAME).lib: $(sort $(COMMON_DIROBJ) $(NONEH_EDG_DIROBJ) $(EH_EDG_DIROBJ))
	@echo BASE LIBRARY BUILD
	rm -f $@ ar_$(LNAME).cmd && echo "-qa $@ $(sort $(COMMON_DIROBJ) $(NONEH_EDG_DIROBJ))" > ar_$(LNAME).cmd
	$(AR) @ar_$(LNAME).cmd
	rm -f ar_$(LNAME).cmd
	@echo EXCEPTION HANDLING LIBRARY BUILD
	rm -f xrts$(LNAME)_eh.lib rts$(LNAME)_eh.lib
	cp $@ xrts$(LNAME)_eh.lib
	rm -f areh_$(LNAME).cmd && echo "-qr xrts$(LNAME)_eh.lib $(EH_EDG_DIROBJ)" > areh_$(LNAME).cmd
	$(AR) @areh_$(LNAME).cmd
	rm -f areh_$(LNAME).cmd
	mv xrts$(LNAME)_eh.lib rts$(LNAME)_eh.lib

#------------------------------------------------------------------------------
# Build individual files
#------------------------------------------------------------------------------
$(DIR)/NONEH/%.obj: EDGRTS/%.cpp
	$(CL) -c $(INCLUDES) $(CFLAGS) $(NONEH_CPP_OPT) -fr $(DIR)/NONEH -fs $(DIR)/NONEH -ft $(DIR)/NONEH $<

$(DIR)/EH/%.obj: EDGRTS/%.cpp
	$(CL) -c $(INCLUDES) $(CFLAGS) $(EH_CPP_OPT) -fr $(DIR)/EH -fs $(DIR)/EH -ft $(DIR)/EH $<

$(DIR)/%.obj: %.asm
	$(CL) -c $(CFLAGS) -fr $(DIR) -fs $(DIR) -ft $(DIR) $<

$(DIR)/%.obj: %.c
	$(CL) -c $(INCLUDES) $(CFLAGS) -fr $(DIR) -fs $(DIR) -ft $(DIR)  $<

$(DIR)/%.obj: %.sa
	$(CL) -c $(INCLUDES) $(CFLAGS) -fr $(DIR) -fs $(DIR) -ft $(DIR) $<

#------------------------------------------------------------------------------
# Create a tar distibution
#
# CMW: What is this for?  Does it need to include the exception handling?
#------------------------------------------------------------------------------
#DIST_TAR = $(HOME)/$(TARGET)_rts.tgz
#
#dist: $(LIBNAMES) $(HEADERS) $(INTERNAL_HEADERS) rts.src
#	gtar zcfh dist.tgz $^
#	mv dist.tgz $(DIST_TAR)
#
#------------------------------------------------------------------------------
# Install all the libs and header files to a specified directory.  This is
# usually used by the nightly stuff to install the rts into $target/exec.
#
# Define INSTALL_TO to copy all headers, libs and rts.src to that
# directory.  Define LIBINSTALL_TO and INCINSTALL_TO to copy the libs
# or headers (i.e. includes) to those directories.
# 
# Also make sure linefeeds are correct for the current system (PC vs Unix).
#------------------------------------------------------------------------------
install: install_to incinstall_to libinstall_to

install_to: $(LIBNAMES) $(EH_LIBNAMES) $(HEADERS) rts.src
ifdef INSTALL_TO
	rm -f $(addprefix $(INSTALL_TO)/,$(notdir $^))
	mkdir -p $(INSTALL_TO)
	cp $^ $(INSTALL_TO)
ifeq ($(PLATFORM),Windows_NT)
	topc -c $(addprefix $(INSTALL_TO)/,$(HEADERS))
else
	tounix -c $(addprefix $(INSTALL_TO)/,$(HEADERS))
endif # PLATFORM
endif # INSTALL_TO


incinstall_to: $(HEADERS)
ifdef INCINSTALL_TO
	rm -f $(addprefix $(INCINSTALL_TO)/,$(notdir $^))
	mkdir -p $(INCINSTALL_TO)
	cp $^ $(INCINSTALL_TO)
ifeq ($(PLATFORM),Windows_NT)
	topc -c $(addprefix $(INCINSTALL_TO)/,$(HEADERS))
else
	tounix -c $(addprefix $(INCINSTALL_TO)/,$(HEADERS))
endif # PLATFORM
endif # INCINSTALL_TO


libinstall_to: $(LIBNAMES) $(EH_LIBNAMES) rts.src
ifdef LIBINSTALL_TO
	rm -f $(addprefix $(LIBINSTALL_TO)/,$(notdir $^))
	mkdir -p $(LIBINSTALL_TO)
	cp $^ $(LIBINSTALL_TO)
endif

#------------------------------------------------------------------------------
# Used by Alpha release programs to get lists of source/header files.
# Does not include $(INTERNAL_HEADERS)
#------------------------------------------------------------------------------

# Things that go in the user include directory
headerlist:
	@echo $(HEADERS)

# Source files that should generate object files
sourcelist:
	@echo $(patsubst %,%.c,$(COMMONFUNCS)) \
		$(patsubst %,%.sa,$(_EDG_CPP_FUNCS)) 

# Libraries that we should have built
liblist:
	@echo $(LIBNAMES) $(EH_LIBNAMES)

# Things that should exist when we build the rts, and which go into rts.src.
# CMW: This list does not include the EDG files nor array.c
allsourcelist:
	@echo $(patsubst %,%.c,$(_C_FUNCS)) \
		$(patsubst %,%.asm,$(_ASMFUNCS)) \
		$(patsubst %,%.sa,$(_SAFUNCS)) \
		$(patsubst %,%.c,$(_EDG_CPP_FUNCS)) \
		$(INTERNAL_HEADERS) $(HEADERS)

#
# This rather hacky rule will warn you about files which exist in the
# module but are unmentioned by the makefile, and thus probably
# unused; this may or may not be a problem.  The first line will warn
# you about headers which are not mentioned in either HEADERS or
# INTERNAL_HEADERS; this *is* a problem
#
warnunused:
	@(echo `find . -type f -name '*.h' | sed 's,[^ ]*/,,g'` ; \
	  echo $(HEADERS) $(INTERNAL_HEADERS) ; \
	  echo $(HEADERS) $(INTERNAL_HEADERS)) | tr ' ' '\012' | \
	 sort | uniq -u | awk ' { print; count++ } END { exit count }' 
	@(echo `find . -type f -name '*.c' | sed 's,[^ ]*/,,g'` ; \
	  echo $(patsubst %,%.c,$(_C_FUNCS)); \
	  echo $(patsubst %,%.c,$(_C_FUNCS))) | tr ' ' '\012' | \
	 sort | uniq -u | awk ' { print; count++ } END { exit count }' 
	@(echo `find . -type f -name '*.c' | sed 's,[^ ]*/,,g'` ; \
	  echo $(patsubst %,%.c,$(_EDG_CPP_FUNCS)); \
	  echo $(patsubst %,%.c,$(_EDG_CPP_FUNCS))) | tr ' ' '\012' | \
	 sort | uniq -u | awk ' { print; count++ } END { exit count }' 
	@(echo `find . -type f -name '*.asm' | sed 's,[^ ]*/,,g'` ; \
	  echo $(patsubst %,%.asm,$(_ASMFUNCS)); \
	  echo $(patsubst %,%.asm,$(_ASMFUNCS))) | tr ' ' '\012' | \
	@(echo `find . -type f -name '*.sa' | sed 's,[^ ]*/,,g'` ; \
	  echo $(patsubst %,%.sa,$(_SAFUNCS)); \
	  echo $(patsubst %,%.sa,$(_SAFUNCS))) | tr ' ' '\012' | \
	 sort | uniq -u | awk ' { print; count++ } END { exit count }' 

#------------------------------------------------------------------------------
# support rules
#------------------------------------------------------------------------------
realclean:: clean

clean::
	rm -rf $(NAMES) $(LIBNAMES) $(EH_LIBNAMES) rts.src testdir Makefile.dep *.d *~ *.obj _rtssrc

.PHONY: all clean FORCE dist


#------------------------------------------------------------------------------
# Info rules
#------------------------------------------------------------------------------
info: help

help:
	@echo TARGET=$(TARGET)
	@echo PLATFORM=$(PLATFORM)
	@echo NAMES=$(NAMES)
	@echo _C_FUNCS=$(_C_FUNCS)
	@echo _ASM_FUNCS=$(_ASM_FUNCS)
	@echo _EDG_CPP_FUNCS=$(_EDG_CPP_FUNCS)
	@echo INTERNAL_HEADERS=$(INTERNAL_HEADERS)
	@echo HEADERS=$(HEADERS)
	@echo CL=$(CL)
	@echo AR=$(AR)
	@echo LIBNAMES=$(LIBNAMES)
	@echo CFLAGS=$(CFLAGS)
	@echo CFUNCS=$(CFUNCS)
	@echo ASMFUNCS=$(ASMFUNCS)
	@echo SAFUNCS=$(SAFUNCS)
	@echo DIROBJS=$(DIROBJS)
	@echo DIST_TAR=$(DIST_TAR)
	@echo INSTALL_TO=$(INSTALL_TO)
	@echo LIBINSTALL_TO=$(LIBINSTALL_TO)
	@echo INCINSTALL_TO=$(INCINSTALL_TO)
_bufread.c/     1146129405  0     0     0       3584      `
/*****************************************************************************/
/*  _BUFREAD.C v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/
 
/*****************************************************************************/
/* Functions:                                                                */
/*    _BUFF_READ  -  Fill a stream's buffer from its file                    */
/*****************************************************************************/
#include <stdio.h>
#include <_lock.h>
#include "file.h"

extern _DATA_ACCESS int  _ft_end;
extern int  _doflush(FILE *_fp);
extern void _buff_read(FILE *_fp);


/*****************************************************************************/
/* _BUFF_READ  -   Fill a stream's buffer from its file                      */
/*                                                                           */
/*    This function fills stream _FP's buffer with the contents of the file  */
/*    it is associated with.  It returns nothing, but sets flags in the      */
/*    stream if any I/O errors occur.                                        */
/*                                                                           */
/*****************************************************************************/
void _buff_read(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   errchk,
         j,
         buffer_size    = _fp->bufend - _fp->buf;

   /*------------------------------------------------------------------------*/
   /* If this is a line buffered stream, flush all line buffered streams.    */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IOLBF)
   {
       /*--------------------------------------------------------------------*/
       /* This is a critical section because it depends on the global	     */
       /* variable _ft_end.						     */
       /*--------------------------------------------------------------------*/
       _lock();
       for(j=0; j < _ft_end; j++)
	   if(_BUFFMODE(&_ftable[j]) == _IOLBF)
	       _doflush(&_ftable[j]);
       _unlock();
   }

   /*------------------------------------------------------------------------*/
   /* Read in the next characters from the file.                             */
   /*------------------------------------------------------------------------*/
   errchk = read(_fp->fd, (char *)_fp->buf, buffer_size);

   /*------------------------------------------------------------------------*/
   /* Adjust the buffer pointers.                                            */
   /*------------------------------------------------------------------------*/
   _fp->buff_stop = _fp->buf + errchk;
   _fp->pos = _fp->buf;

   /*------------------------------------------------------------------------*/
   /* Set any error flags if necessary.                                      */
   /*------------------------------------------------------------------------*/
   switch(errchk)
   {
      case -1 : _SET(_fp, _STATERR);
                break;
 
      case 0  : _SET(_fp, _STATEOF);
                break;
   }

   return;
 
}
 
_io_perm.c/     1146129405  0     0     0       5956      `
/*****************************************************************************/
/*  _IO_PERM.C v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    _RD_OK   -  Check to make sure that the stream is readable             */
/*    _WRT_OK  -  Check to make sure that the stream is writeable            */
/*****************************************************************************/
#include <stdio.h>

extern int _rd_ok(FILE *_fp);
extern int _wrt_ok(FILE *_fp);


/*****************************************************************************/
/* _RD_OK   -  Check to make sure that the stream is readable.               */
/*                                                                           */
/*    This function checks to make sure that the stream _FP has been opened  */
/*    for reading, and allocates a buffer for the stream if one hasn't been  */
/*    already.  The function returns a 1 if it is alright to write to this   */
/*    stream, otherwise it returns a 0.                                      */
/*                                                                           */
/*****************************************************************************/
int _rd_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   =  0;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being written to, return a 0.              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in read mode.                               */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODER) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODER);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
 
}


/*****************************************************************************/
/* _WRT_OK()   -  Check to make sure that a stream is writeable              */
/*                                                                           */
/*    This function takes the FILE pointer _FP, and makes sure that it is ok */
/*    to write to it.  It also allocates a buffer if one is needed.  The     */
/*    function returns a 1 if it is ok to write to this stream, otherwise it */
/*    returns a 0.                                                           */
/*                                                                           */
/*****************************************************************************/
int _wrt_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being read return a 0.                     */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _MODER)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is in append mode, move the file pointer to the end of   */
   /* the file.                                                              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEA)) fseek(_fp, 0L, SEEK_END);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in write mode.                              */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODEW) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODEW);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
}

_lock.c/        1146129405  0     0     0       639       `
/****************************************************************************/
/*  _lock v4.1.3                                                            */
/*  Copyright (c) 2000-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <_lock.h>

_CODE_ACCESS void _nop()
{
  /* Do nothing. */
}

_DATA_ACCESS void (*  _lock)() = _nop;
_DATA_ACCESS void (*_unlock)() = _nop;

_CODE_ACCESS void _register_lock(void (*lock)())
{
    _lock = lock;
}

_CODE_ACCESS void _register_unlock(void (*unlock)())
{
    _unlock = unlock;
}

_lock.h/        1146129405  0     0     0       756       `
/*****************************************************************************/
/*  _lock.h v4.1.3                                                           */
/*  Copyright (c) 2000-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef __LOCK_H
#define __LOCK_H

#include <linkage.h>

#ifdef __cplusplus
extern "C" namespace std {
#endif

_CODE_ACCESS void _nop();

extern _DATA_ACCESS void (  *_lock)();
extern _DATA_ACCESS void (*_unlock)();

_CODE_ACCESS void _register_lock  (void (  *lock)());
_CODE_ACCESS void _register_unlock(void (*unlock)());

#ifdef __cplusplus
} /* extern "C" namespace std */
#endif

#endif /* __LOCK_H */
_log.c/         1146129405  0     0     0       3252      `
/****************************************************************************/
/*  _log    v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  _LOG() - natural log (w/o error checking)				    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double _log(double x)
{
    double a, b, f, r, w, z, znum;
    int n;

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
        --n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}
_printfi.c/     1146129405  0     0     0       51861     `
/*****************************************************************************/
/*  _PRINTFI.C v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all six variations of the    */
/*    printf function use.  The main function in the file is _printfi,       */
/*    and the other functions here are called by it.                         */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _printfi       -  Perform the main printf routine                      */
/*    _pproc_fflags  -  Process the format flags for a conversion            */
/*    _pproc_fwp     -  Convert field width and precision into numbers       */
/*    _pproc_str     -  Process the string (%s) conversion                   */
/*    _setfield      -  Performs conversions when the '%' is encountered     */
/*    _pproc_fge     -  Process the conversion for f, g, G, e, and E         */
/*    _pconv_f       -  Perform the %f conversion                            */
/*    _pconv_e       -  Perform the %e conversion                            */
/*    _pconv_g       -  Perform the %g conversion                            */
/*    _fcpy          -  Copy the fraction part of a float to a string        */
/*    _ecpy          -  Copy the "E+xx" part of a float to a string          */
/*    _mcpy          -  Copy the whole number part of a float to a string    */
/*    _pproc_diouxp  -  Process the conversion for d, i, o, u, x, and p      */
/*    _getarg_diouxp -  Get the argument for d, i, o, u, x, or p conversion  */
/*    _ltostr        -  Convert an integer to a string of up to base 16      */
/*    _div           -  Divide two integers                                  */
/*                                                                           */
/* Note:  If NOFLOAT is defined at compile time, this file will be compiled  */
/*        without floating point support.                                    */
/*****************************************************************************/
#include <stdio.h>
#include <format.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <limits.h>
#include <math.h>
#include <_lock.h>

#define SIGNED_CONV (pfield->conv != 'u' && pfield->conv != 'o' && \
                     pfield->conv != 'x' && pfield->conv != 'X')

extern _CODE_ACCESS char *fcvt(long double value, register int ndigit, 
			       int *decpt, int *sign);
extern _CODE_ACCESS char *ecvt(long double value, register int ndigit, 
			       int *decpt, int *sign);
extern _CODE_ACCESS char *memccpy(char *dest, const char *src, int ch,
				  int count);

extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static void _pproc_fflags(_PFIELD *pfield, char **it);
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap);
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *));
static char *_setfield(_PFIELD *pfield, va_list *_ap);
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it,
                       va_list *_ap);
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it);
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision,
                   char **a_it);
static char *_ecpy(int exp, char letter, char **a_it);
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it);
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it,
                         va_list *_ap);
static uintmax_t _getarg_diouxp(_PFIELD *pfield, va_list *_ap);
static int _ltostr(uintmax_t cvt, int base, char conv, char **a_it);
static uintmax_t _div(uintmax_t cvt, int base);

/*****************************************************************************/
/* _PRINTFI -  Perform the main printf routine                               */
/*                                                                           */
/*    This function processes the format string.  It copies the format       */
/*    string into the result string until a '%' is encountered, where any    */
/*    flags, the field width, the precision, and the type of conversion are  */
/*    read in, stored in a structure called PFIELD, and passed to _SETFIELD, */
/*    where the actual conversion is processed.  This function returns       */
/*    the number of characters output.                                       */
/*                                                                           */
/*****************************************************************************/
int _printfi(char **_format, va_list _ap, void *_op, 
             int (*_outc)(char, void *), int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*                                                                        */
   /*    *end     -  A pointer to the end of the format string               */
   /*    *pfield  -  A pointer to a structure _PFIELD, which stores all of   */
   /*                flags and parameters needed to perform a conversion.    */
   /*------------------------------------------------------------------------*/
   char     *end           =  *_format + strlen(*_format);
   int      count          =  0;
   _PFIELD  pfield;

   /*------------------------------------------------------------------------*/
   /* Iterate through the format string until the end of it is reached.      */
   /*------------------------------------------------------------------------*/
   while(*_format < end)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize PFIELD.                                                  */
      /*---------------------------------------------------------------------*/
      pfield.flags     = 0;
      pfield.fwidth    = 0;
      pfield.precision = -1;
      pfield.conv      = 0;

      /*---------------------------------------------------------------------*/
      /* Copy the format string directly to the target string until a '%'    */
      /* is encountered.                                                     */
      /*---------------------------------------------------------------------*/
      for(; **_format != '%' && **_format != '\0'; 
          _outc(*((*_format)++), _op), count++);

      /*---------------------------------------------------------------------*/
      /* If the end of the format string has been reached, break out of the  */
      /* while loop.                                                         */
      /*---------------------------------------------------------------------*/
      if(! (**_format)) break;

      (*_format)++;                   /* Skip to the character after the '%' */

      /*---------------------------------------------------------------------*/
      /* Process the flags immediately after the '%'.                        */
      /*---------------------------------------------------------------------*/
      _pproc_fflags(&pfield, _format);

      /*---------------------------------------------------------------------*/
      /* Convert the field width and precision into numbers.                 */
      /*---------------------------------------------------------------------*/
      _pproc_fwp(&pfield, _format, &_ap);
 
      /*---------------------------------------------------------------------*/
      /* If the h, l, or L flag was specified, set the corresponding flag    */
      /* in pfield.                                                          */
      /*---------------------------------------------------------------------*/
      switch (**_format)
      {
	  case 'L': _SET(&pfield, _MFLD); (*_format)++; break;
	  case 'h': _SET(&pfield, _MFH);  (*_format)++; break;
	  case 'l':
	  {
	      (*_format)++; 
	      if (**_format == 'l') { _SET(&pfield, _MFLL); (*_format)++; }
	      else _SET(&pfield, _MFL);
	  }
      }

      /*---------------------------------------------------------------------*/
      /* Set the conversion character in pfield.                             */
      /*---------------------------------------------------------------------*/
      pfield.conv = *((*_format)++);

      /*---------------------------------------------------------------------*/
      /* If 'n' is the conversion specifier, process it in this function,    */
      /* since it is the only one that makes no conversions.  It just stores */
      /* the number of characters printed so far into the next argument.     */
      /* Otherwise, call _SETFIELD which performs the conversion.            */
      /*---------------------------------------------------------------------*/
      if(pfield.conv == 'n')
         switch (pfield.flags & (_MFLL | _MFL | _MFH))
         {
#ifdef LLONG_MAX
                           /* The 'll' flag was specified */
            case _MFLL  :  *(va_arg(_ap, long long*)) = (long long)count;
                           break;
#endif
                           /* The 'l' flag was specified */
            case _MFL   :  *(va_arg(_ap, long*)) = (long)count;
                           break;

                           /* The 'h' flag was specified */
            case _MFH   :  *(va_arg(_ap, short*)) = (short)count;
                           break;

            default     :  *(va_arg(_ap, int*)) = (int)count;
                           break;

         }
      else if(pfield.conv == 's') 
         _pproc_str(&pfield, _op, &_ap, &count, _outs);   
      else
      {
         /*------------------------------------------------------------------*/
         /* Append the converted string to the result string, and reposition */
         /* its iterator, it2.                                               */
         /*------------------------------------------------------------------*/
	 /* Must hold the system lock to call _setfield() because it returns
	    a static buffer. */
	 _lock();
         count += _outs(_setfield(&pfield, &_ap), _op);
	 _unlock();
      }
   }

   return (count);
}


/*****************************************************************************/
/* _PPROC_FFLAGS   -  Process the format flags for a conversion              */
/*                                                                           */
/*    This function takes the flags directly after the '%' and stores them   */
/*    in the _PFIELD structure PFIELD for later reference.                   */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fflags(_PFIELD *pfield, char **it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int flags_done = 0;

   /*---------------------------------------------------------------------*/
   /* Read in all of the flags associated with this conversion, and set   */
   /* the corresponding flags in the PFIELD structure.                    */
   /*---------------------------------------------------------------------*/
   while(! flags_done)
      switch (**it)
      {
         case '-' :  _SET(pfield, _PFMINUS);
                     (*it)++;
                     break;   

         case '+' :  _SET(pfield, _PFPLUS);
                     (*it)++;
                     break;

         case ' ' :  _SET(pfield, _PFSPACE);
                     (*it)++;
                     break;

         case '#' :  _SET(pfield, _PFPOUND);
                     (*it)++;
                     break;

         case '0' :  _SET(pfield, _PFZERO);
                     (*it)++;
                     break;

         default  :  flags_done = 1;
      }

   return;
}


/*****************************************************************************/
/* _PPROC_FWP   -  Convert the field width and precision from the format     */
/*                 string into numbers.                                      */
/*                                                                           */
/*    This function reads the field and precision out of the format string   */
/*    and converts them into numbers that will be stored in the _PFIELD      */
/*    structure pointed to by PFIELD.  They will be needed for future        */
/*    reference.                                                             */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap)
{
   char tmpstr[10];
   char *tmpptr;

   /*------------------------------------------------------------------------*/
   /* If a '*' was given for the field width, use the next argument as       */
   /* the field width for the conversion.  Otherwise, copy the following     */
   /* numerical characters into a temporary string, and convert that         */
   /* string into an integer, which will be used for the field width.        */
   /*------------------------------------------------------------------------*/
   if(**it == '*')
   {
      pfield->fwidth = va_arg(*_ap, int);

      /*---------------------------------------------------------------------*/
      /* If the argument given for the field width is negative, treat it as  */
      /* if the '-' flag was used, and the field width was positive.         */
      /*---------------------------------------------------------------------*/
      if(pfield->fwidth < 0) 
      {
         pfield->fwidth = -(pfield->fwidth);
         _SET(pfield, _PFMINUS);
      }

      (*it)++;
   }
   else
   {
      /*---------------------------------------------------------------------*/
      /* Initialize the temporary string and iterator that will hold the     */
      /* field width temporarily.                                            */
      /*---------------------------------------------------------------------*/
      tmpptr = tmpstr;
      memset(tmpptr, '\0', 10);

      while((**it >= '0') && (**it <= '9')) *(tmpptr++) = *((*it)++);

      if(*tmpstr != '\0') pfield->fwidth = atoi(tmpstr);
   }

   /*------------------------------------------------------------------------*/
   /* If a '.' appears as the next character, process the following          */
   /* characters as a precision.                                             */
   /*------------------------------------------------------------------------*/
   if(**it == '.')
   {
      (*it)++;

      /*---------------------------------------------------------------------*/
      /* If a '*' was given for the precision, use the next argument as      */
      /* the precision for the conversion.  Otherwise, copy the following    */
      /* numerical characters into a temporary string, and convert that      */
      /* string into an integer, which will be used for the precision.       */
      /*---------------------------------------------------------------------*/
      if(**it == '*')
      {
         pfield->precision = va_arg(*_ap, int);
         (*it)++;
      }
      else
      {
         /*------------------------------------------------------------------*/
         /* Initialize the temporary string and iterator that will hold      */
         /* the field width temporarily.                                     */
         /*------------------------------------------------------------------*/
         tmpptr = tmpstr;
         memset(tmpptr, '\0', 10);

         while((**it >= '0') && (**it <= '9'))  *(tmpptr++) = *((*it)++);

         if(*tmpstr != '\0') pfield->precision = atoi(tmpstr);
         else                pfield->precision = 0;
      }
   }
   return;
}


/*****************************************************************************/
/* _PPROC_STR  -  Processes the string conversion (%s)                       */
/*                                                                           */
/*    This function places all or a portion of the input string into the     */
/*    the temporary string.  It returns a zero, unless the input string had  */
/*    a length of zero.  In this case, a one is returned.                    */
/*                                                                           */
/*****************************************************************************/
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *strbuf;
   char  *tmpstr;
   char  *tmpptr;
   int   len, buflen;

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   strbuf = va_arg(*_ap, char*);

   /*------------------------------------------------------------------------*/
   /* Handle NULL strings.                                                   */
   /*------------------------------------------------------------------------*/
   if(strbuf == NULL)
   {
      _outs("(null)", _op);
      return;
   }

   buflen = (pfield->precision >= 0 && pfield->precision < strlen(strbuf)) ?
            pfield->precision : strlen(strbuf);
   len = (pfield->fwidth > buflen) ? pfield->fwidth : buflen;
   *count += len;

   if(!(tmpstr = (char *)malloc(len + 1))) return;
   tmpptr = tmpstr;

   if(buflen < len && !_STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);  
   }

   strncpy(tmpptr, strbuf, buflen);
   tmpptr += buflen;

   if(buflen < len && _STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);
   }

   *(tmpstr + len) = '\0';

   _outs(tmpstr, _op);

   free(tmpstr);

   return;
}


/*****************************************************************************/
/* _SETFIELD   -  Performs conversions when the '%' is encountered           */
/*                                                                           */
/*    This function takes pfield, and calls the appropriate processing       */
/*    function for the conversion required in the _PFIELD structure.  It     */
/*    returns a pointer to the result string.                                */
/*                                                                           */
/*****************************************************************************/
static char *_setfield(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variable declarations, and a description of their use            */
   /*                                                                        */
   /*    FLD is a temporary string that will hold the conversion.  F_START   */
   /*    will be a pointer to the beginning of the field, and if a           */
   /*    field width was specified, F_END will be a pointer to the end of    */
   /*    the field.  This designated field is located at the beginning of    */
   /*    the string FLD.   A_END is a pointer to the end of the string FLD,  */
   /*    and this is where the primary conversion will take place.  Using    */
   /*    A_IT, an iterator beginning at the end of FLD, the number will be   */
   /*    written one digit at a time starting with the rightmost digit.      */
   /*    Using the pointer WHERE, the number in string form will be moved    */
   /*    to its appropriate place within the field after making adjustments  */
   /*    called for by various flags in the format specification (a minus    */
   /*    sign, leading zeros, etc.).  The string FLD will then be returned.  */
   /*                                                                        */
   /*    MINUS_FLAG is exactly what it says ( = 1 if number is negative).    */
   /*                                                                        */
   /*------------------------------------------------------------------------*/
   static _DATA_ACCESS char fld[_ARSIZE];

   char *f_start   =  (char *)fld;
   char *f_end     =  f_start + pfield->fwidth;
   char *a_end     =  f_start + _ARSIZE -1; 
   char *a_it      =  a_end;
   char *where;
   int  minus_flag = 0;
   int  plus_flag  = 0;

   /*------------------------------------------------------------------------*/
   /* Initialize the temporary string.  Then, since we are working from      */
   /* right to left, begin with the NULL character.                          */
   /*------------------------------------------------------------------------*/
   memset(fld, ' ', _ARSIZE);
   *(a_it--) = '\0'; 

   /*------------------------------------------------------------------------*/
   /* Call the appropriate processing function.                              */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'd' :
      case 'i' :
      case 'o' :
      case 'u' :
      case 'x' :
      case 'X' :  
      case 'p' :  _pproc_diouxp(pfield, &minus_flag, &a_it, _ap);
                  break;  

#ifndef NOFLOAT
      case 'g' :  
      case 'G' : 
      case 'e' :
      case 'E' :
      case 'f' :  _pproc_fge(pfield, &minus_flag, &a_it, _ap);
                  break;
#endif
  
      case 'c' :  *(a_it--) = va_arg(*_ap, int);
                  _UNSET(pfield, _PFPLUS);
                  break;

      case '%' :  strcpy(f_start, "%"); return((char *)fld);


   }

   plus_flag = (_STCHK(pfield, _PFPLUS) && SIGNED_CONV);

   /*------------------------------------------------------------------------*/
   /* If the number was negative, or the '+' flag was used, insert the sign. */
   /* Make sure unsigned conversions don't get a '+' sign.                   */
   /*------------------------------------------------------------------------*/
   if (minus_flag) *(a_it--) = '-';
   else if (plus_flag) *(a_it--) = '+';

   /*------------------------------------------------------------------------*/
   /* If the number was positive, the '+' flag was not used, and the ' '     */
   /* flag was used, insert a space.                                         */
   /*------------------------------------------------------------------------*/
   if(! minus_flag && ! plus_flag && _STCHK(pfield, _PFSPACE)) *(a_it--) = ' ';

   /*------------------------------------------------------------------------*/
   /* If the '-' flag was used or the resulting string is larger than the    */
   /* field, left justify the result in the array.  Otherwise right-justify  */
   /* it.                                                                    */
   /*------------------------------------------------------------------------*/
   where = (_STCHK(pfield, _PFMINUS) ||
           ((a_end - a_it) > pfield->fwidth)) ? f_start :
           (f_end - (a_end - a_it)+1);

   a_it = (char *)memccpy(where, a_it+1, '\0', _ARSIZE);

   /*------------------------------------------------------------------------*/
   /* If a resulting left-justified string is smaller than the field width,  */
   /* move the terminating NULL character to the end of the field.           */
   /*------------------------------------------------------------------------*/
   if(a_it <= f_end)
   {
      memset(a_it - 1, ' ', f_end - a_it + 1);
      *f_end = '\0';
   }

   /*------------------------------------------------------------------------*/
   /* If the '0' flag was used, and the resulting string is right-justified, */
   /* fill in the leading zeros.                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(pfield, _PFZERO))
   {
      memset(f_start, '0', (where - f_start));

      /*---------------------------------------------------------------------*/
      /* Make sure any sign or leading space is moved to the left side of    */
      /* any leading zeros.                                                  */
      /*---------------------------------------------------------------------*/
      if((minus_flag || plus_flag || _STCHK(pfield, _PFSPACE)) &&
          where != f_start)
      {
         *f_start = *where;
         *where = '0';
      }
   }
   else
      memset(f_start, ' ', (where - f_start));

   /*------------------------------------------------------------------------*/
   /* Return the result string.                                              */
   /*------------------------------------------------------------------------*/
   return ((char *)fld);                     
}


#ifndef NOFLOAT
/*****************************************************************************/
/* _PPPROC_FGE   -  Process the conversion for f, g, G, e, and E             */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*****************************************************************************/
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it, 
                       va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   long double cvt =  0;

   /*------------------------------------------------------------------------*/
   /* Determine what kind of argument is coming next, and read it into CVT.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, _MFLD))
   {
      case  0  :  cvt = (double)va_arg((*_ap), double);
                  break;

      default  :  cvt = va_arg((*_ap), long double);

   }

   /*------------------------------------------------------------------------*/
   /* If CVT is negative, set the MINUS_FLAG and reverse the sign of CVT.    */
   /*------------------------------------------------------------------------*/
   if((*minus_flag = (cvt < 0)) != 0) cvt = -cvt;

   /*------------------------------------------------------------------------*/
   /* Call the proper conversion function                                    */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'f' :  _pconv_f(cvt, pfield, a_it);
                  break;
      case 'e' :
      case 'E' :  _pconv_e(cvt, pfield, a_it);
                  break;
      case 'g' :
      case 'G' :  _pconv_g(cvt, pfield, a_it);
   }
}


/*****************************************************************************/
/* _PCONV_F -  Perform the %f conversion                                     */
/*****************************************************************************/
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[400];
   char *frac_ptr;
   int   dpt, 
         sign, 
         putdec;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, then copy the fractional part, */
   /* determine whether or not a decimal point should be placed, and copy    */
   /* whole number part.                                                     */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   frac_ptr = *a_it;
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);

   /*------------------------------------------------------------------------*/
   /* If the output has no fractional part, don't write the decimal point.   */
   /* If # flag was specified, then we write the decimal point always.       */
   /*------------------------------------------------------------------------*/
   putdec = (frac_ptr != *a_it || _STCHK(pfield, _PFPOUND));
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_E -  Perform the %e conversion                                     */
/*****************************************************************************/
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec, 
         exp      = 0;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Check if CVT is within legal range -HUGE_VALL <= CVT <= HUGE_VALL      */
   /*------------------------------------------------------------------------*/
   if (cvt >= HUGE_VALL) cvt = HUGE_VALL;
   else if (cvt <= -HUGE_VALL) cvt = -HUGE_VALL;

   /*------------------------------------------------------------------------*/
   /* Convert CVT to x.xxxe+xx form, keeping the exponent in EXP.            */
   /*------------------------------------------------------------------------*/
   if(cvt)
   {
      for(;cvt < 1; cvt *= 10, exp--);
      for(;cvt >= 10; cvt /= 10, exp++);
   }

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, copy the exponent part, the    */
   /* fractional part, then determine whether or not a decimal point should  */
   /* be placed, and copy the whole number part.                             */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   if(dpt==2) /* fcvt() might have rounded the number */
   {
       dpt--; exp++; tmpbuf[strlen(tmpbuf)-1] = 0;
   }
   _ecpy(exp, pfield->conv, a_it);
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_G -  Perform the %g conversion                                     */
/*****************************************************************************/
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   char  *check;
   int   dpt, 
         sign, 
         putdec, 
         exp         = 0, 
         change_test = 0;

   /*------------------------------------------------------------------------*/
   /* If the precision was given as 0, set it to one.                        */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0) pfield->precision = 1;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   strcpy(tmpbuf, ecvt(cvt, pfield->precision, &dpt, &sign));

   /*------------------------------------------------------------------------*/
   /* If the exponent is less than -4, or greater than or equal to the       */
   /* precision, convert the number as a %e conversion.  Otherwise convert   */
   /* it as a %f conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if(dpt < -3 || dpt > pfield->precision)
   {
      for(;dpt > 1; dpt--, exp++);
      for(;dpt < 1; dpt++, exp--);

      _ecpy(exp, pfield->conv-2, a_it);
   }

   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the number.  CHANGE_TEST will be set if    */
   /* there was a fractional part, otherwise it will remain a zero.          */
   /*------------------------------------------------------------------------*/
   check = *a_it;
   _fcpy(tmpbuf, dpt, (_STCHK(pfield, _PFPOUND)) ? 1 : 0, pfield->precision,
         a_it);
   change_test = (check != *a_it);

   /*------------------------------------------------------------------------*/
   /* If the '#' flag was used, or there was a fractional part to the number */
   /* a decimal point will be placed.                                        */
   /*------------------------------------------------------------------------*/
   putdec = (_STCHK(pfield, _PFPOUND) || change_test) ? 1 : 0;

   _mcpy(tmpbuf, dpt, putdec, a_it);

}


/*****************************************************************************/
/* _FCPY -  Copy the fraction part of a float to a string                    */
/*****************************************************************************/
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision, 
                   char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = (char *)tmpbuf + strlen(tmpbuf) -1;

   /*------------------------------------------------------------------------*/
   /* Fill all unused precision spaces with zeros.                           */
   /*------------------------------------------------------------------------*/
   for(i = 0; i < precision && dpt > (int)strlen(tmpbuf) && trail; i++)
      *((*a_it)--) = '0';
 
   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the float into the string.                 */
   /*------------------------------------------------------------------------*/
   if(dpt < (int)strlen(tmpbuf) && dpt >= 0)
   {
      i = (int)strlen(tmpbuf) - dpt;

      /*---------------------------------------------------------------------*/
      /* Skip trailing zeros if TRAIL is not set.                            */
      /*---------------------------------------------------------------------*/
      if(! trail) for(; i > 0 && *tmpptr == '0'; tmpptr--, i--);

      for(; i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;

   }

 
   /*------------------------------------------------------------------------*/
   /* Place any leading fractional zeros if necessary.                       */
   /*------------------------------------------------------------------------*/
   if(dpt < 0)
   {
      if (-dpt < precision)
          for(i = strlen(tmpbuf); i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;
      if (-dpt > precision) dpt = -precision;
      for(i = -dpt; i > 0; i--) *((*a_it)--) = '0';
   }

   return (*a_it);
}


/*****************************************************************************/
/* _ECPY -  Copy the "e+xx" part of a float to a string                      */
/*****************************************************************************/
static char *_ecpy(int exp, char letter, char **a_it)
{
   _ltostr((exp > 0) ? exp : -exp, 10, 'd', a_it);
   if(exp < 10 && exp > -10) *((*a_it)--) = '0';
   *((*a_it)--) = (exp < 0) ? '-' : '+';
   *((*a_it)--) = letter;

   return (*a_it);
}


/*****************************************************************************/
/* _MCPY -  Copy the whole number part of a float to a string                */
/*****************************************************************************/
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = NULL;

   /*------------------------------------------------------------------------*/
   /* If the number has both a whole number part and a fractional part,      */
   /* position TMPPTR to the last character of the whole number.             */
   /*------------------------------------------------------------------------*/
   if(dpt > 0 && dpt <= (int)strlen(tmpbuf)) tmpptr = (char *)tmpbuf + dpt -1;

   /*------------------------------------------------------------------------*/
   /* Place a decimal point if PUTDEC is set.                                */
   /*------------------------------------------------------------------------*/
   if(putdec) *((*a_it)--) = '.';

   /*------------------------------------------------------------------------*/
   /* Place any whole number trailing zeros.                                 */
   /*------------------------------------------------------------------------*/
   for(i = dpt; i > (int)strlen(tmpbuf); i--) *((*a_it)--) = '0';

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the whole number.                                     */
   /*------------------------------------------------------------------------*/
   if(i > 0) for(; tmpptr >= tmpbuf; tmpptr--) *((*a_it)--) = *tmpptr;
   else *((*a_it)--) = '0';

   return (*a_it);
}
#endif


/*****************************************************************************/
/* _PPROC_DIOUXP   -  Process the conversion for d, i, o, u, x, and p        */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*                                                                           */
/*****************************************************************************/
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it, 
                         va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int digits =  0;
   int base   = 10;
   uintmax_t cvt;

   /*------------------------------------------------------------------------*/
   /* If no precision was given, set it to 1.                                */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 1; 
   else                      _UNSET(pfield, _PFZERO);

   /*------------------------------------------------------------------------*/
   /* Set the base of the number by the type of conversion specified.        */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'p' :
      case 'x' :
      case 'X' :  base = 16;
                  break;

      case 'o' :  base = 8;
                  break;

      default  :
      case 'u' :
      case 'd' :
      case 'i' :  base = 10;
  	          break;
   }  

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   cvt = _getarg_diouxp(pfield, _ap);

   /*------------------------------------------------------------------------*/
   /* If the precision is 0, and the number is 0, do nothing and return 1.   */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0 && cvt == 0) return 1;

   /*------------------------------------------------------------------------*/
   /* If the number is signed and negative, set the minus sign flag, and     */
   /* negate the number.                                                     */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'd' || pfield->conv == 'i')
      && ((intmax_t)cvt < 0))
   {
      *minus_flag = 1;
      cvt = -(intmax_t)cvt;
   }

   /*------------------------------------------------------------------------*/
   /* Call the function to convert the number to a string, and add the       */
   /* total number of digits assigned into DIGITS.                           */
   /*------------------------------------------------------------------------*/
   digits += _ltostr(cvt, base, pfield->conv, a_it);

   /*------------------------------------------------------------------------*/
   /* Fill in the remainder of the precision with zeros.                     */
   /*------------------------------------------------------------------------*/
   while(digits++ < pfield->precision) *((*a_it)--) = '0';


   /*------------------------------------------------------------------------*/
   /* If the "#" flag was used in the X or x conversion, prefix a "0x" or    */
   /* "0X" to the hexadecimal number.                                        */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'x' || pfield->conv == 'X') && _STCHK(pfield, _PFPOUND))
   {
      *((*a_it)--) = pfield->conv;
      *((*a_it)--) = '0';
   }

   /*------------------------------------------------------------------------*/
   /* If the "#' flag was used in the o conversion, prefix a "0" to the      */
   /* octal number.                                                          */
   /*------------------------------------------------------------------------*/
   if(pfield->conv == 'o' && _STCHK(pfield, _PFPOUND)) *((*a_it)--) = '0';

   return (0);

}


/*****************************************************************************/
/* _GETARG_DIOUXP -  Get the argument for a d, i, o, u, x, or p conversion   */
/*                                                                           */
/*    This function takes the next argument off the argument list, after     */
/*    determining what kind of argument it is.  It decides this by checking  */
/*    to see if the 'h' or the 'l' flag was used.  It returns the next       */
/*    argument.                                                              */
/*****************************************************************************/
static uintmax_t _getarg_diouxp(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   uintmax_t cvt = 0;

   if (pfield->conv == 'p') cvt = (uintmax_t)va_arg(*_ap, void *);
   else
   /*------------------------------------------------------------------------*/
   /* Get the number from the next argument.  Determine what kind of         */
   /* argument by checking for the h or l flag in the format specification.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, (_MFH | _MFL | _MFLL)))
   {
      case _MFH   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, int);
			    break;
			    
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : 
			    cvt = (unsigned short) va_arg(*_ap, unsigned int);
                     }
                     break;

      case _MFL   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, long int);
			    break;

                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : 
			    cvt = va_arg(*_ap, unsigned long int);
                     }
                     break;
#ifdef LLONG_MAX
      case _MFLL  :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, long long int);
			    break;

                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : 
			    cvt = va_arg(*_ap, unsigned long long int);
                     }
                     break;
#endif   
      default     :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, int);
			    break;
 
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' :
			    cvt = va_arg(*_ap, unsigned int);
                     }
   }

   return (cvt);
}


/*****************************************************************************/
/* _LTOSTR  -  Convert an integer to a string of up to base 16               */
/*                                                                           */
/*    This function takes an uintmax_t integer, converts it to a string      */
/*    which is pointed to by *A_IT.  The result will also be converted to    */
/*    a base corresponding to the variable base.                             */
/*                                                                           */
/*****************************************************************************/
static int _ltostr(uintmax_t cvt, int base, char conv, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*------------------------------------------------------------------------*/
   uintmax_t  quot,
              rem;
       char  *bnum = "0123456789abcdef0123456789ABCDEF";

   /*------------------------------------------------------------------------*/
   /* The number CVT will be converted to a string by taking the remainder   */
   /* of a division of it by its base, and converting it to a character.     */
   /* The number CVT is then set equal to itself divided by its base, and    */
   /* this continues until CVT is 0.                                         */
   /*------------------------------------------------------------------------*/

   if(! cvt) *((*a_it)--) = '0';

   while(cvt)
   {
      quot = _div(cvt, base);
      rem = cvt - (quot * base);

      if(conv == 'X') rem += 16;

      *((*a_it)--) = bnum[rem];
      cvt = quot;
   }

   return (strlen(*a_it) - 1);
}


/*****************************************************************************/
/* _DIV  -  Divide two integers                                              */
/*                                                                           */
/*    This function takes a uintmax_t, and divides it by an integer.         */
/*    Division must take place in unsigned arithmetic, because signed '/'    */
/*    can overflow.  This function is used by _LTOSTR when it is converting  */
/*    an unsigned int to a string.                                           */
/*                                                                           */
/*****************************************************************************/
static uintmax_t _div(uintmax_t cvt, int base)
{
    /*-----------------------------------------------------------------------*/
    /* Use shifts to optimize power-of-two bases                             */
    /*-----------------------------------------------------------------------*/
    switch(base)
    {
	case  8: return cvt >> 3;
	case 16: return cvt >> 4;
    }

    /*-----------------------------------------------------------------------*/
    /* Perform divide in narrowest arithmetic possible, for speed.	     */
    /*-----------------------------------------------------------------------*/
         if (cvt < UINT_MAX)  return (unsigned int)cvt / base;
    else if (cvt < ULONG_MAX) return (unsigned long)cvt / base;
    else return cvt / base;
}


_scanfi.c/      1146129405  0     0     0       35888     `
/*****************************************************************************/
/*  _SCANFI.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all three variations of the  */
/*    scanf function use.  The main function in the file is _scanfi, and     */
/*    the other functions here are called by it.                             */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _scanfi        -  The main scanf handling routine                      */
/*    _sget_conv     -  Read the format flags into the _SFIELD pointer sfield*/
/*    _sget_scanset  -  Read in the scanset from the format statement        */
/*    _sproc_int     -  Read an integer string into a temporary string       */
/*    _sproc_float   -  Read a float string into a temporary string          */
/*    _sproc_str     -  Copy a string from the input source to a temporary   */
/*                      string                                               */
/*    _sproc_lb      -  Process the %[ conversion                            */
/*    _sset_arg      -  Assign the converted value to the next argument      */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#ifdef LLONG_MAX
_CODE_ACCESS long long strtoll(const char *_st, char **_endptr, int _base);
_CODE_ACCESS unsigned long long strtoull(const char *_st, char **_endptr,
					 int _base);
#endif

_CODE_ACCESS long double strtold(const char *st, char **endptr);

static int _sget_conv(char **_format, _SFIELD *sfield);
static int _sget_scanset(_SFIELD *sfield, char **_format);
static int _sproc_int(int w_counter, int (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, int outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_float(int w_counter, int (*_inpchar)(void **inp),
                         void (*_uninpchar)(void **inp, int outchar),
                         char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_str(int w_counter, int (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, int outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_lb(int (*_inpchar)(void **inp),
                      void (*_uninpchar)(void **inp, int outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read);
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf);

/*****************************************************************************/
/* _SCANFI  -  The main scanf handling routine                               */
/*                                                                           */
/*    This function parses all non-conversion characters in the format       */
/*    string, passes control to the appropriate function when a '%' is       */
/*    encountered, then calls _SSET_ARG, which assignes the result to the    */
/*    next argument.                                                         */
/*                                                                           */
/*****************************************************************************/
int _scanfi(void *inp, const char *_format, va_list _ap, 
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            int (*_inpchar)(void **inp), 
            void (*_uninpchar)(void **inp, int outchar))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   _SFIELD  sfield;
   char     tmpbuf[256],
           *tmpptr,
           *f_ptr        = (char *)_format;
   int      num_assigned =  0,
            inchar,
            num_read     =  0,
            stat         =  0;

   /*------------------------------------------------------------------------*/
   /* If the first character in the format string is a white space character */
   /* parse the format string until a non-white space character is found.    */
   /* Do the same for the input, but put the first non-white space character */
   /* back onto the input stream when finished.                              */
   /*------------------------------------------------------------------------*/
   if (isspace(*f_ptr))
   {
      for(;isspace(*f_ptr);f_ptr++);

      inchar = _inpchar(&inp);
      if(inchar == EOF) return EOF;
      num_read++;

      for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);

      _uninpchar(&inp, inchar);
      num_read--;

      if(inchar == EOF) return EOF;
   }

   while(1)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize sfield                                                   */
      /*---------------------------------------------------------------------*/
      memset(&sfield, 0, sizeof(_SFIELD));
      sfield.fwidth = -1;

      /*---------------------------------------------------------------------*/
      /* Call _chkmbc to compare the format string to the input.  If a       */
      /* mismatch occurs, return an EOF, if the end of the format string     */
      /* is reached, return the number of arguments assigned.  Otherwise     */
      /* a '%' has been encountered, so call _sget_conv to process it.       */
      /*---------------------------------------------------------------------*/
      switch(_chkmbc(&inp, &f_ptr, &num_read))
      {
         case  EOF   : return (EOF);
   
         case  0     : return (num_assigned);
   
         case  1     :  _sget_conv(&f_ptr, &sfield);
   
      }
   
      tmpptr = tmpbuf;

      /*---------------------------------------------------------------------*/
      /* Unless the conversion specifier is a [, c, or n, skip to the next   */
      /* non-white space character in the input.                             */
      /*---------------------------------------------------------------------*/
      if (sfield.conv != '[' && sfield.conv != 'c' && sfield.conv != 'n')
      {
         inchar = _inpchar(&inp);
         num_read++;
    
         for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);
    
         _uninpchar(&inp, inchar);
         num_read--;

         /*---------------------------------------------------------------*/
         /* If we've encountered the end of the stream AND we haven't     */
         /* matched anything yet, return EOF.                             */
         /*---------------------------------------------------------------*/
         if(inchar == EOF && num_read == 0) return EOF;
      }
      else
      {
         /*---------------------------------------------------------------*/
         /* If we've encountered the end of the stream AND we haven't     */
         /* matched anything yet, return EOF.                             */
         /*---------------------------------------------------------------*/
         inchar = _inpchar(&inp);
         _uninpchar(&inp, inchar);
         if(inchar == EOF && num_read == 0) return EOF;
      }

      /*---------------------------------------------------------------------*/
      /* The flags have been set in sfield, so process the conversion by     */
      /* calling the appropriate function.                                   */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'X'   :  sfield.conv = 'x';
         case  'i'   :
         case  'p'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :
         case  'd'   :  stat = _sproc_int(sfield.fwidth, _inpchar, _uninpchar, 
                                         tmpptr, sfield.conv, &inp, &num_read); 
                        break;
         case  'f'   :
         case  'e'   :
         case  'E'   :
         case  'g'   :
         case  'G'   :  stat = _sproc_float(sfield.fwidth, _inpchar, _uninpchar,
                                     tmpptr, sfield.conv, &inp, &num_read);
                        break;

         case  'c'   :  
         case  's'   : {
                          char *stptr = (sfield.flags & _SFSTAR) ?
                                         NULL : va_arg(_ap, char*);

                          stat = _sproc_str(sfield.fwidth, _inpchar, _uninpchar,
                                     stptr, sfield.conv, &inp, &num_read);
                       }
                       stat = (stat != EOF);
                       if (!(sfield.flags & _SFSTAR) && stat) num_assigned++;
                       break;

         case  '['   :  stat = _sproc_lb(_inpchar, _uninpchar, tmpptr, &sfield,
                                         &inp, &num_read);

      }

      stat = (stat != EOF);

      /*---------------------------------------------------------------------*/
      /* Now, call the function to handle the actual assignment, or if there */
      /* is no assignment to take place, process it here.                    */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'i'   :
         case  'd'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :  
         case  'p'   : 
         case  'e'   :
         case  'f'   :
         case  'g'   :
         case  'E'   :
         case  'G'   :  _sset_arg(&sfield, &_ap, tmpbuf);
                        if ((!(sfield.flags & _SFSTAR)) && stat) num_assigned++;
                        break;
 
         case  'n'   :  if (!(sfield.flags & _SFSTAR))
                           switch(sfield.flags & (_MFH | _MFHH | _MFL | _MFLL))
                           {
                              case  _MFH  :  *(va_arg(_ap, short int*)) =
                                             (short int)num_read;
                                             break;
 
                              case  _MFHH :  *(va_arg(_ap, char*)) =
                                             (char)num_read;
                                             break;
 
                              case _MFL   :  *(va_arg(_ap, long int*)) =
                                             (long int)num_read;
                                             break;
#ifdef LLONG_MAX
                              case _MFLL  :  *(va_arg(_ap, long long int*)) =
                                             (long long int)num_read;
                                             break;
#endif
                              default     :  *(va_arg(_ap, int*)) =
                                             num_read;
                                             break;
                           }
                        break;

         case  '%'   :  inchar = _inpchar(&inp);
                        if (inchar != '%') return (EOF);
                        else num_read++;
                        break;
                              
         case  '['   :  if ((!(sfield.flags & _SFSTAR)) && stat)
                        {
                           strcpy(va_arg(_ap, char *), tmpbuf);
                           num_assigned++;
                        }
      }
   }

}

/*****************************************************************************/
/* _SGET_CONV  -  Read the format flags into the _SFIELD pointer sfield      */
/*                                                                           */
/*    This function reads the characters directly after the '%' character,   */
/*    and stores them as flags in sfield, a pointer to a _SFIELD structure.  */
/*    These flags will later be used to process the conversion.              */
/*                                                                           */
/*****************************************************************************/
static int _sget_conv(char **_format, _SFIELD *sfield)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[8],
         *tmpptr     =  tmpbuf,
         *strend     =  (*_format) + strlen(*_format);

   (*_format)++;                        /* Go to the character after the '%' */

   /*------------------------------------------------------------------------*/
   /* If the next character in the format statement is a '*', set the        */
   /* _SFSTAR flag in sfield                                                 */
   /*------------------------------------------------------------------------*/
   if (**_format == '*')
   {
      _SET(sfield, _SFSTAR);
      (*_format)++;
   }
 
   /*------------------------------------------------------------------------*/
   /* If numerical characters follow, read them into a temporary string,     */
   /* convert it into a number, and store it as the field width in sfield    */
   /*------------------------------------------------------------------------*/
   for(;**_format >= '0' && **_format <= '9'; *(tmpptr++) = *((*_format)++));
   *tmpptr = '\0';
 
   if (strlen(tmpbuf)) sfield->fwidth = atoi(tmpbuf);
 
   /*------------------------------------------------------------------------*/
   /* Set the h, l, or L flags if they were specified                        */
   /*------------------------------------------------------------------------*/
   switch(**_format)
   {
       case 'L': _SET(sfield, _MFLD); (*_format)++; break;
       case 'h':
       {
           (*_format)++;
           if (**_format == 'h') { _SET(sfield, _MFHH); (*_format)++; }
           else _SET(sfield, _MFH);
           break;
       }
       case 'l': 
       {
	   (*_format)++;
	   if (**_format == 'l') { _SET(sfield, _MFLL); (*_format)++; }
	   else _SET(sfield, _MFL);
       }
   }

   /*------------------------------------------------------------------------*/
   /* Read in the last character as the conversion specifier                 */
   /*------------------------------------------------------------------------*/
   sfield->conv = *((*_format)++);

   /*------------------------------------------------------------------------*/
   /* For the '[' conversion, read in the scanset.  Return an EOF if         */
   /* _SGET_SCANSET fails.                                                   */
   /*------------------------------------------------------------------------*/
   if ((sfield->conv == '[') && _sget_scanset(sfield, _format)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If we read past the end of the format string, return an error          */
   /*------------------------------------------------------------------------*/
   if (*_format > strend) return (EOF);
   else return (0);
}

/*****************************************************************************/
/* _SGET_SCANSET  -  Read in the scanset from the format statement           */
/*                                                                           */
/*    This function is called when the '[' conversion specifier has been     */
/*    encountered.  It reads in the scanset from the format statement,       */
/*    and stores it in sfield for later reference during the conversion.     */
/*                                                                           */
/*****************************************************************************/
static int _sget_scanset(_SFIELD *sfield, char **_format)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *tmpptr  =  sfield->scanset;

   if (**_format == '^')
   {
      _SET(sfield, _SFCIRC);
      (*_format)++;
   }

   if (**_format == ']') *(tmpptr++) = *((*_format)++);

   while(**_format != ']' && **_format != '\0') *(tmpptr++) = *((*_format)++);

   *tmpptr = '\0';
   if (**_format == ']') (*_format)++;
   if (**_format == '\0') return (EOF);

   return(0);
}

/*****************************************************************************/
/* _SPROC_INT  -  Read an integer string into a temporary string             */
/*                                                                           */
/*    This function takes the next integer in character form from the        */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_int(int w_counter, int (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, int outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read) 
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/

   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign for the number               */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }


   /*------------------------------------------------------------------------*/
   /* Accept a leading '0' for an octal number, or a '0x' or '0X' for a      */
   /* hexadecimal number.                                                    */
   /*------------------------------------------------------------------------*/
   if ((conv == 'o' || conv == 'i' || conv =='x' || conv == 'p') && 
      w_counter != 0 && inchar == '0')
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   if ((conv == 'x' || conv == 'p' || conv == 'i') && w_counter != 0 &&
     (inchar == 'x' || inchar == 'X'))
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   /*------------------------------------------------------------------------*/
   /* Accept digits 0-9 for decimal numbers, or 0-F for hexadecimal numbers  */
   /*------------------------------------------------------------------------*/
   while(((inchar >= '0' && inchar <= '9') || 
          ((conv == 'x' || conv == 'p' || conv == 'i') &&
          ((inchar >= 'A' && inchar <= 'F') ||
          (inchar >= 'a' && inchar <= 'f')))) && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SPROC_FLOAT   -  Read a float string into a temporary string             */
/*                                                                           */
/*    This function takes the next float in character form from the          */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_float(int w_counter, int (*_inpchar)(void **inp), 
                         void (*_uninpchar)(void **inp, int outchar), 
                         char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/
 
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          invalid   = 0;
   int          bnum_read = *num_read;
   int          dec_flag  =  0;
   int          e_flag    =  0;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign                              */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }
 
   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a numerical digit.                  */
   /* The characters '.', 'e', 'E', '+', and '-' are accepted under the      */
   /* following conditions:                                                  */
   /*                                                                        */
   /* '.'         :  a '.', an 'e', or an 'E' has not yet been encountered   */
   /* 'e' or 'E'  :  neither of these characters have been encounterd yet    */
   /* '+' or '-'  :  If the last character read was an 'E' or an 'e'         */
   /*------------------------------------------------------------------------*/
   while((inchar >= '0' && inchar <= '9') || inchar == '.' || inchar == 'e'
          || inchar == 'E' || inchar == '+' || inchar == '-')
   {

      switch(inchar)
      {
         case  '.'   :  if (dec_flag || e_flag) { invalid = 1; break; } 
                        else dec_flag = 1;
                        break;

         case  'e'   :
         case  'E'   :  if (e_flag) { invalid = 1; break; }
                        else e_flag = 1;
                        break;

         case  '+'   :  
         case  '-'   :  if (*(tmpptr-1) != 'E' && *(tmpptr-1) != 'e')
                        { invalid = 1; break; }
      }

      if (invalid) break;
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      if (inchar != EOF) (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   if (inchar != EOF) (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SPROC_STR  -  Copy a string from the input source to a temporary string  */
/*                                                                           */
/*    This function takes a string from the input source, and copies it      */
/*    into a temporary string, to be later assigned to a scanf argument.     */
/*                                                                           */
/*****************************************************************************/
static int _sproc_str(int w_counter, int (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, int outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /*	If no precision was given for the %c conversion, set it to one.        */
   /*------------------------------------------------------------------------*/
   if ((conv == 'c') && (w_counter < 0)) w_counter = 1;

   /*------------------------------------------------------------------------*/
   /* Read in the next character, then while that character is not a white   */
   /* space character, a null terminator, an EOF character, and the field    */
   /* width has not been exceeded, copy it to the temporary string, and      */
   /* get another character.                                                 */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   while((conv == 'c' || !isspace(inchar)) && inchar != '\0' &&
         inchar != EOF && w_counter--)
   { 
      if (tmpptr) *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
   }
   
   /*------------------------------------------------------------------------*/
   /* The %s conversion specifies that a null terminator be placed at the    */
   /* end of the conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if (conv == 's' && tmpptr) *tmpptr = '\0';

   _uninpchar(inp, inchar);
   (*num_read)--;

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SPROC_LB   -  Process the %[ conversion                                  */
/*                                                                           */
/*    This function copies characters from the input stream into a           */
/*    temporary string until it satisfies the field width, or encounters a   */
/*    character that is not in the scanset.  The scanset is defined as the   */
/*    characters passed between the left and right brackets.  If a '^' is    */
/*    first character after the left bracket, then the scanset is every      */
/*    character that is not listed between the two brackets.                 */
/*                                                                           */
/*****************************************************************************/
static int _sproc_lb(int (*_inpchar)(void **inp), 
                      void (*_uninpchar)(void **inp, int outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          bnum_read = *num_read;
   int          w_counter =  sfield->fwidth;
   int          test;

   inchar = _inpchar(inp);
   (*num_read)++;

   for (; w_counter != 0 && inchar != EOF; w_counter--)
   {
      test = (strrchr(sfield->scanset, inchar) != NULL);
      if (_STCHK(sfield, _SFCIRC)) test = !test;
             
      if (test)
      {
         *(tmpptr++) = inchar;
         inchar = _inpchar(inp);
         (*num_read)++;
      }
      else
      {
         _uninpchar(inp, inchar);
         (*num_read)--;
         break;
      }
   }

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SSET_ARG   -  Assign the converted value to the next argument            */
/*                                                                           */
/*    This function takes a pointer to the result conversion string, and     */
/*    assigns it to the next argument.  The type of argument to be assigned  */
/*    is determined by the conversion specifier, and the h, l, or L flags    */
/*    if they were used.                                                     */
/*                                                                           */
/*****************************************************************************/
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int base;

   /*------------------------------------------------------------------------*/
   /* Do the assignment only if the result string has a length greater than  */
   /* zero, and the '*' flag was not used                                    */
   /*------------------------------------------------------------------------*/
   if (tmpbuf[0] != '\0' && !_STCHK(sfield, _SFSTAR))
      switch(sfield->conv)
      {
         case  'i'   :
         case  'd'   :  base = (sfield->conv == 'd') ? 10 : 0;
   
                        switch(_STCHK(sfield, (_MFH | _MFHH | _MFL | _MFLL)))
                        {
                           case  _MFH  :  *(va_arg(*_ap, short int*)) =
                                          (short int)strtol(tmpbuf, NULL,
                                          base);
                                          break;

                           case  _MFHH :  *(va_arg(*_ap, char*)) =
                                          (char)strtol(tmpbuf, NULL, base);
                                          break;

                           case _MFL   :  *(va_arg(*_ap, long int*)) =
                                          strtol(tmpbuf, NULL, base);
                                          break;
#ifdef LLONG_MAX
                           case _MFLL  :  *(va_arg(*_ap, long long int*)) =
                                          strtoll(tmpbuf, NULL, base);
                                          break;
#endif
                           default     :  *(va_arg(*_ap, int*)) =
                                          (int)strtol(tmpbuf, NULL, base);
                                          break;
                        }
                        break;

      /*---------------------------------------------------------------------*/
      /* Suppress "conversion from integer to smaller pointer" warning for   */
      /* the %p case.                                                        */
      /*---------------------------------------------------------------------*/
#pragma DIAGNOSTIC_SUPPRESS(1107)
      case  'p'   :  *(va_arg(*_ap, void **))=(void *)strtoul(tmpbuf, NULL, 16);
		     break;
#pragma DIAGNOSTIC_RESET(1107)

      case  'x'   :
      case  'u'   :
      case  'o'   :  base = (sfield->conv == 'u') ? 10 :
                            (sfield->conv == 'x') ? 16 : 8;

                     switch(_STCHK(sfield, (_MFH | _MFHH | _MFL | _MFLL)))
                     {
                        case _MFH : *(va_arg(*_ap, unsigned short int*))=
                                    (unsigned short int)strtoul(tmpbuf,
                                    NULL, base);
                                    break;

                        case _MFHH: *(va_arg(*_ap, unsigned char*))=
                                    (unsigned char)strtoul(tmpbuf, NULL, base);
                                    break;

                        case _MFL : *(va_arg(*_ap, unsigned long int*)) =
                                    strtoul(tmpbuf, NULL, base);
                                    break;
#ifdef LLONG_MAX
                        case _MFLL: *(va_arg(*_ap, unsigned long long int*)) =
                                    strtoull(tmpbuf, NULL, base);
                                    break;
#endif
                        default   : *(va_arg(*_ap, unsigned int*)) =
                                    (unsigned int)strtoul(tmpbuf, NULL,
                                    base);
                                    break;
                     }
                     break;

      case  'e'   :
      case  'f'   :
      case  'g'   :
      case  'E'   :
      case  'G'   :  switch(_STCHK(sfield, (_MFL | _MFLD)))
                     {
                        case _MFL : *(va_arg(*_ap, double*))=
                                    strtod(tmpbuf, NULL);
                                    break;

                        case _MFLD: *(va_arg(*_ap, long double*)) =
                                    strtold(tmpbuf, NULL);
                                    break;

                        default   : *(va_arg(*_ap, float*)) =
                                    (float)strtod(tmpbuf, NULL);
                                    break;
                     }
                     break;

   }
}
abs.c/          1146129405  0     0     0       586       `
/*****************************************************************************/
/* abs     v4.1.3                                                            */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include "stdlib.h"

int  abs (int i)  { return abs(i);  }  /* NOTE: ABS() IS A BUILTIN FUNCTION  */
long labs(long i) { return labs(i); }  /* NOTE: LABS() IS A BUILTIN FUNCTION */

long long llabs(long long i)
{
    if (i < 0) i = -i;
    return i;
}
abstract.asm/   1146129405  0     0     0       625       `
;******************************************************************************
;* ABSTRACT_C28X  v4.1.3                                                       *
;* Copyright (c) 2001-2006 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* ABSTRACT_C28x.ASM
;****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "abstract28.inc"
        .endif

abstract28.inc/ 1146129405  0     0     0       1601      `
;*****************************************************************************
;* PROCEDURAL ABSTRACTION FUNCTIONS FOR C28X v4.1.3                           *
;* Copyright (c) 2001-2006 Texas Instruments Incorporated                    *
;*****************************************************************************

;*****************************************************************************
;* ABSTRACT FUNCTION FOR SATLOW16 INTRINSIC                                  *
;*****************************************************************************
	.sect	".text"
	.global	_satlow16

_satlow16:	.asmfunc
	SETC	OVM
	CLRC	SXM
	ADD	ACC,#65535 << 15
	SUB	ACC,#65535 << 15
	SUB	ACC,#65535 << 15
	ADD	ACC,#65535 << 15
	CLRC	OVM
	LRETR
	.endasmfunc

;*****************************************************************************
;* ABSTRACT FUNCTION FOR ARRAY COPIES                                        *
;*****************************************************************************
	.sect	".text"
	.global	_abstract_func1_c28x

_abstract_func1_c28x:	.asmfunc
	MOV 	AL,*XAR5++
	MOV 	*XAR4++,AL
	BANZ 	_abstract_func1_c28x,AR6--
	LRETR
	.endasmfunc

;*****************************************************************************
;* ABSTRACT FUNCTION FOR ARRAY COPIES                                        *
;*****************************************************************************
	.sect	".text"
	.global	_abstract_func2_c28x

_abstract_func2_c28x:	.asmfunc
	MOV 	AL,*XAR4++
	MOV 	*XAR5++,AL
	BANZ 	_abstract_func2_c28x,AR6--
	LRETR
	.endasmfunc

access.h/       1146129405  0     0     0       34        `
/* access.h: Empty by default */
acos.c/         1146129405  0     0     0       2851      `
/****************************************************************************/
/*  acos   v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ACOS() - Arccosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = bi - result + bi 				    */
/*  if x > 0, result = ci + result + ci 				    */
/****************************************************************************/
double acos(double x)
{
  double p, q, g, y;
  static const _DATA_ACCESS double b[2] = {1.57079632679489661923, 
					   0.78539816339744830962};
  static const _DATA_ACCESS double c[2] = {0.0, 0.78539816339744830962};
  int i = 1;

  /*************************************************************************/
  /* acos(x) = acos(-x)                                                    */  
  /*************************************************************************/
  if ((y = fabs(x)) > 0.5)
  {
     /**********************************************************************/
     /* check if x is out of domain                                        */
     /**********************************************************************/
     if (y > 1.0) { errno = EDOM; return (0.0); }

     i = 0;
     g = (1.0 - y) * 0.5;
     y = -2.0 * sqrt(g);
  }
  else g = y * y;

  /*************************************************************************/
  /* determine polynomial expansion                                        */
  /*************************************************************************/
#if BITS<=24
  p = (ASP2 * g + ASP1) * g;
  q = (g + ASQ1) * g + ASQ0;
#elif BITS>=25 && BITS<=36
  p = ((ASP3 * g + ASP2) * g + ASP1) * g;
  q = ((g + ASQ2) * g + ASQ1) * g + ASQ0;
#elif BITS>=37 && BITS<=48
  p = (((ASP4 * g + ASP3) * g + ASP2) * g + ASP1) * g;
  q = (((g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#else
  p = ((((ASP5 * g + ASP4) * g + ASP3) * g + ASP2) * g + ASP1) * g;
  q = ((((g + ASQ4) * g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#endif

  return (x < 0) ? ((b[i] + y + y * p / q) + b[i])
		 : ((c[i] - y - y * p / q) + c[i]);
}

ankcio.h/       1146129405  0     0     0       3039      `
/*****************************************************************************/
/*  ANKCIO.H v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*  This file contains OTIS-driven CIO constant definitions                  */
/*****************************************************************************/

#ifndef _ANKCIO
#define _ANKCIO

/*---------------------------------------------------------------------------*/
/* constants for the data transfer functions for the predefined driver       */
/*---------------------------------------------------------------------------*/
#define _DTOPEN    (0xF0)
#define _DTCLOSE   (0xF1)
#define _DTREAD    (0xF2)
#define _DTWRITE   (0xF3)
#define _DTLSEEK   (0xF4)
#define _DTUNLINK  (0xF5)
#define _DTGETENV  (0xF6)
#define _DTRENAME  (0xF7)
#define _DTGETTIME (0xF8)
#define _DTGETCLK  (0xF9)
#define _DTSYNC    (0xFF)

#define CIOBUFSIZ BUFSIZ+32

/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z)   ((short) ( (((long) x[(z)]   << 16) + \
			               ((long) x[(z)+1] << 24)) >> 16))

#define LOAD32(x,y,z)   { x[(z)]   = (unsigned long) (y); \
                          x[(z)+1] = (unsigned long) (y) >> 8; \
                          x[(z)+2] = (unsigned long) (y) >> 16;  \
                          x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOAD32(x,z)   ( (long) x[(z)]           +  \
                         ((long) x[(z)+1] << 8)   +  \
                         ((long) x[(z)+2] << 16)  +  \
			 ((long) x[(z)+3] << 24))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( ((byte)%2 == 0) ?  \
	 (*((base) + ((byte)/2))  = ((val) & 0xFF)) : \
	 (*((base) + ((byte)/2)) |= ((val) & 0xFF) << (((byte)%2) * 8)) )

#define UNPACKCHAR(base, byte) \
         ( (*((base) + ((byte)/2)) >> (((byte)%2) * 8)) & 0xFF )

#define BSSCIOBUF 1

#endif /* _ANKCIO */

ankmsg.c/       1146129405  0     0     0       4772      `
/*****************************************************************************/
/*  ANKMSG.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Bottom level data transfer routines for host communication with the       */
/* target.                                                                   */
/*                                                                           */
/* Functions:                                                                */
/*  writemsg()  -  Sends the passed data and parameters on to the host.      */
/*  readmsg()   -  Reads the data and parameters passed from the host.       */
/*****************************************************************************/
#include <stdio.h>
#include "ankcio.h"


#define STR(x) #x
#define DEFCIO(size) __asm("__CIOBUF_: .usect  .cio," STR(size) ",4"); \
		     extern unsigned char _CIOBUF_[size]

DEFCIO(CIOBUFSIZ);


/***************************************************************************/
/*                                                                         */
/*  WRITEMSG()  -  Sends the passed data and parameters on to the host.    */
/*                                                                         */
/***************************************************************************/
void writemsg(unsigned char           command,
              register unsigned char *parm,
              register const char    *data,
              unsigned int            length)
{
    register unsigned char *p = (unsigned char *) _CIOBUF_;
    register unsigned int i;

    /***********************************************************************/
    /* THE LENGTH IS WRITTEN AS A TARGET INT                               */
    /***********************************************************************/ 
    *(unsigned int *)p = length; 
    p += sizeof(unsigned int);

    /***********************************************************************/ 
    /* THE COMMAND IS WRITTEN AS A TARGET BYTE                             */
    /***********************************************************************/ 
    *p++ = command;

    /***********************************************************************/ 
    /* PACK THE PARAMETERS AND DATA SO THE HOST READS IT AS BYTE STREAM    */
    /***********************************************************************/ 
    for (i = 0; i < 8; i++)      PACKCHAR(*parm++, p, i);
    for (i = 0; i < length; i++) PACKCHAR(*data++, p, i+8);

    /***********************************************************************/ 
    /* THE EMULATOR BREAKPOINTS IN DECODE PHASE, SO HAVE TO ADD IN SOME    */
    /* NOPS TO MAKE SURE LAST REAL INSTRUCTION COMPLETES BEFORE BREAKPOINT */
    /***********************************************************************/ 
    __asm("	nop");
    __asm("	nop");
    __asm("	nop");

    /***********************************************************************/
    /* THE BREAKPOINT THAT SIGNALS THE HOST TO DO DATA TRANSFER            */
    /***********************************************************************/
    __asm("	.global	C$$IO$$");
    __asm("C$$IO$$:nop");
}



/***************************************************************************/
/*                                                                         */
/*  READMSG()   -  Reads the data and parameters passed from the host.     */
/*                                                                         */
/***************************************************************************/
void readmsg(register unsigned char *parm,
	     register char          *data)
{
    register unsigned char *p = (unsigned char *) _CIOBUF_;

    register unsigned int i;
    unsigned int length;

    /***********************************************************************/
    /* THE LENGTH IS READ AS A TARGET INT                                  */
    /***********************************************************************/
    length = *(unsigned int *)p;
    p += sizeof(unsigned int);
    
    /***********************************************************************/
    /* UNPACK THE PARAMETERS AND DATA                                      */
    /***********************************************************************/
    for (i = 0; i < 8; i++) *parm++ = UNPACKCHAR(p, i);
    if (data != NULL) 
       for (i = 0; i < length; i++) *data++ = UNPACKCHAR(p, i+8);
}
args_main.c/    1146129405  0     0     0       1924      `
/******************************************************************************/
/* The ARGS data structure is defined according to a convention with linker.  */
/*                                                                            */
/* If the user want to pass arguments to loader, "--args=###" option has to   */
/* be used in linking to generate executable. With this option, the linker    */
/* will allocate a section starting with __c_args__, and with this "###" many */
/* bytes. The loader when parses the arguments, will dump the number of       */
/* arguments, argc as the 1st arguments at address __c_args__, all the actual */
/* arguments will be dumped after that. The total space for these arguments   */
/* will not exceed "###" bytes.                                               */
/*                                                                            */
/* if "--args="###" is not used as a linker option, linker will put -1 at     */
/* __c_args__ location.                                                       */ 
/*                                                                            */
/* Based on the above convention, the following code implements the access to */
/* these arguments when main is called.                                       */
/*                                                                            */
/* This function is called from boot.asm or boot.c.                           */
/******************************************************************************/

typedef struct { int argc; char *argv[1]; } ARGS;
extern ARGS __c_args__;
extern int main(int argc, char *argv[]);

int _args_main()
{
   register ARGS *pargs = &__c_args__;
   register int    argc = 0;
   register char **argv = 0;
   
   if (pargs != (ARGS *)-1) 
      { argc = pargs->argc; argv = pargs->argv; }
  
   return main(argc, argv);
}
array_del.cpp/  1146129405  0     0     0       1828      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator delete();

*/


#include "basics.h"
#include "runtime.h"

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

void operator delete[](void *ptr) THROW_NOTHING()
/*
Default array operator delete.  Just call the normal operator delete.
*/
{
  operator delete(ptr);
}  /* operator delete[] */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
array_new.cpp/  1146129405  0     0     0       1839      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator new[]();

*/


#include "basics.h"
#include "runtime.h"

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

void *operator new[](size_t size) THROW(STD_NAMESPACE::bad_alloc)
/*
Default array operator new.  Just call the normal operator new.
*/
{
  return operator new(size);
}  /* operator new[] */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

array_nodel.cpp/1146129405  0     0     0       1936      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator delete();

*/


#include "basics.h"
#include "runtime.h"

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

void operator delete[](void				*ptr,
                       const STD_NAMESPACE::nothrow_t&	nothrow_arg)
THROW_NOTHING()
/*
Nothrow version of array operator delete.  Just call the normal nothrow
operator delete.
*/
{
  operator delete(ptr, nothrow_arg);
}  /* operator delete[] */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

array_nonew.cpp/1146129405  0     0     0       1954      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Placement version of C++ operator new[]();

*/


#include "basics.h"
#include "runtime.h"

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE

void *operator new[](size_t			     size,
                     const STD_NAMESPACE::nothrow_t& nothrow_arg)
THROW_NOTHING()
/*
Nothrow version of array operator new.  Just call the normal nothrow
operator new.
*/
{
  return operator new(size, nothrow_arg);
}  /* operator new[] */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

array_pdel.cpp/ 1146129405  0     0     0       1890      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator delete[](size_t, void*);

*/

#include "basics.h"
#include "runtime.h"


#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && ABI_CHANGES_FOR_PLACEMENT_DELETE

void operator delete[](void*, void*) THROW_NOTHING()
/*
Placement operator delete -- does nothing.
*/
{
}  /* operator delete[](void*, void*) */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE &&
          ABI_CHANGES_FOR_PLACEMENT_DELETE*/

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
array_pnew.cpp/ 1146129405  0     0     0       1912      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

/*

C++ operator new[](size_t, void*) (placement array new).

*/


#include "basics.h"
#include "runtime.h"

#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && DEFINE_PLACEMENT_NEW_ROUTINES

void *operator new[](size_t, void* ptr) THROW_NOTHING()
/*
Placement array operator new.
*/
{
  return ptr;
}  /* operator new[](size_t, void*) */

#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE &&
          DEFINE_PLACEMENT_NEW_ROUTINES*/

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/


asctime.c/      1146129405  0     0     0       1094      `
/****************************************************************************/
/*  asctime v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h> 

extern _CODE_ACCESS int sprintf(char *_string, const char *_format, ...);

static _DATA_ACCESS const char *const day[7]  = {
		      "Sun","Mon","Tue","Wed","Thu","Fri","Sat" };
static _DATA_ACCESS const char *const mon[12] = {
		     "Jan","Feb","Mar","Apr","May","Jun", 
                     "Jul","Aug","Sep","Oct","Nov","Dec" };

_CODE_ACCESS char *asctime(const struct tm *timeptr)
{
    struct tm   tptr = *timeptr;
    static _DATA_ACCESS char result[26];

    mktime(&tptr);      /* MAKE SURE THIS A SANE TIME */

    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",
		    day[tptr.tm_wday], mon[tptr.tm_mon], tptr.tm_mday, 
		    tptr.tm_hour, tptr.tm_min, tptr.tm_sec,
		    tptr.tm_year + 1900);

    return (result);
}
asin.c/         1146129405  0     0     0       2553      `
/****************************************************************************/
/*  asin   v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ASIN() - Arcsine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = -ci - result - ci 				    */
/*  if x > 0, result = ci + result + ci		  			    */
/****************************************************************************/
double asin(double x)
{
    double p, q, g, y;
    static const _DATA_ACCESS double c[2] = {0.0, 0.78539816339744830962};
    int i = 0;

    if ((y = fabs(x)) > 0.5)
    {
       /*******************************************************************/
       /* check if input is out of the domain of the function             */
       /*******************************************************************/
       if (y > 1.0) { errno = EDOM; return (0.0); }

       i = 1;	
       g = (1.0 - y) * 0.5;	
       y = -2.0 * sqrt(g);
    }
    else g = y * y;		

  /************************************************************************/
  /* determine polynomial expression                                      */
  /************************************************************************/
#if BITS<=24
    p = (ASP2 * g + ASP1) * g;
    q = (g + ASQ1) * g + ASQ0;
#elif BITS>=25 && BITS<=36
    p = ((ASP3 * g + ASP2) * g + ASP1) * g;
    q = ((g + ASQ2) * g + ASQ1) * g + ASQ0;
#elif BITS>=37 && BITS<=48
    p = (((ASP4 * g + ASP3) * g + ASP2) * g + ASP1) * g;
    q = (((g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#else
    p = ((((ASP5 * g + ASP4) * g + ASP3) * g + ASP2) * g + ASP1) * g;
    q = ((((g + ASQ4) * g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#endif

    return (x < 0) ? (-((c[i] + y + y * p / q) + c[i]))
		   : ((c[i] + y + y * p / q) + c[i]);
}

assert.c/       1146129405  0     0     0       1561      `
/****************************************************************************/
/*  assert   v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

/****************************************************************************/
/* _ABORT_MSG() - Write out a string and never return.  Abort function for  */
/*                false assertions.                                         */
/****************************************************************************/
void _abort_msg(const char *string)
{
   fputs(string, stderr);
   fflush(stderr);
   abort();
}

/****************************************************************************/
/* _ASSERT() - Implements the assert macro. Checks the argument. Aborts     */
/*             with a message if not true.                                  */
/****************************************************************************/
void _assert(int expr, const char *string)  { if (!expr) _abort_msg(string); }

/****************************************************************************/
/* _NASSERT() - Special version of assert, which assumes the expression is  */
/*              true.                                                       */
/****************************************************************************/
void _nassert(int expr)  { }

assert.h/       1146129405  0     0     0       1916      `
/*****************************************************************************/
/* assert.h   v4.1.3                                                         */
/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _ASSERT
#define _ASSERT

#include <linkage.h>

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cassert> IS RECOMMENDED OVER <assert.h>.  <assert.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------

#define _NAMESPACE_PREFIX std::

extern "C" namespace std
{
#else
#define _NAMESPACE_PREFIX
#endif

/* this #ifndef can go away when C2000 uses extern C builtins */
extern _CODE_ACCESS void _abort_msg(const char *);

#define _STR(x)  __STR(x)
#define __STR(x) #x

#if defined(NDEBUG)
#define assert(_ignore) ((void)0)
#elif defined(NASSERT)
#define assert(_expr)   _NAMESPACE_PREFIX _nassert(_expr)
#else
#define assert(_expr)   _NAMESPACE_PREFIX _assert((_expr) != 0,          \
                   "Assertion failed, (" _STR(_expr) "), file " __FILE__ \
                   ", line " _STR(__LINE__) "\n")
#endif /* NDEBUG, NASSERT */

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::_nassert;
#endif /* _CPP_STYLE_HEADER */

#if 0
extern _CODE_ACCESS void std::_nassert(int), _assert(int, const char *);
extern _CODE_ACCESS void std::_abort_msg(const char *);
#endif /* 0 */

#ifndef _CPP_STYLE_HEADER
using std::_nassert;
#endif  /* !_CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::_nassert;
#endif /* _CPP_STYLE_HEADER */

#endif

#endif /* _ASSERT */
atan.c/         1146129405  0     0     0       3276      `
/****************************************************************************/
/*  atan   v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  ATAN() - Arctangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x > 1, x = 1 / x 						    */
/*  if x > 2 - sqrt(3), x = (x * sqrt(3) - 1) / (sqrt(3) + x)		    */
/*  g = x * x								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = (t * (x + x * R) + an) * s					    */
/****************************************************************************/
double atan(double x)
{
    double g, p, q;
    int    sign = x < 0.0;       /* REMEMBER SIGN (1 == negative) */
    int    t = 0;                /* PARTIAL RESULT SIGN FLAG      */
    int    n = 0;
    double result; 

    static const _DATA_ACCESS double a[4] = {0.0, 0.52359877559829887308, 
		     	     		        1.57079632679489661923,
		                     		1.04719755119659774615};

    if ((x = fabs(x)) > 1.0)
    {
	x = 1.0 / x;	
	n = 2;	

	/******************************************************************/
	/* the partial result needs to be negated                         */
	/******************************************************************/
	t = 1;    
    }

    /**********************************************************************/
    /* for x > (2 - sqrt(3)  )                                            */
    /**********************************************************************/
    if (x > TWO_SQRT3)			
    {
	/******************************************************************/
	/* x = (x * sqrt(3) -1)	/ (sqroot(3) + x)                         */
	/******************************************************************/
	x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x);
	++n; 			
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    g = x * x;	

#if BITS<=24
    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;
#elif BITS>=25 && BITS<=32
    p = (ATP1 * g + ATP0) * g;
    q = (g + ATQ1) * g + ATQ0;
#elif BITS>=33 && BITS<=50
    p = ((ATP2 * g + ATP1) * g + ATP0) * g;
    q = ((g + ATQ2) * g + ATQ1) * g + ATQ0;
#else
    p = (((ATP3 * g + ATP2) * g + ATP1) * g + ATP0) * g;
    q = (((g + ATQ3) * g + ATQ2) * g + ATQ1) * g + ATQ0;
#endif

    /**********************************************************************/
    /* calculate the result multiplied by the correct sign                */
    /**********************************************************************/
    result = ((p / q) * x + x); 
    result = (t ? -result : result) + a[n];
    return sign ? -result : result; 
}
atan2.c/        1146129405  0     0     0       3739      `
/****************************************************************************/
/*  atan2  v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ATAN2() - Arctangent2						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x >= 0, result = atan(y / x)		  			    */
/*  if x < 0 & y >= 0, result = pi + atan(y / x)			    */
/*  if x < 0 & y < 0, result = atan (y / x) - pi			    */
/*									    */
/****************************************************************************/
double atan2(double y, double x)
{
    double g, p, q, r;
    int    sign;
    int    t = 0;
    int   ys = (y >= 0);
    int   xs = (x >= 0);
    int    n = 0;

    static const _DATA_ACCESS double a[4] = {0.0, 0.52359877559829887308, 
			             		1.57079632679489661923,
		                     		1.04719755119659774615};

    /*********************************************************************/
    /* check for error in domain                                         */
    /*********************************************************************/
    if (x == 0)
    {
       if (y == 0) { errno = EDOM; return (0.0); }
       else          return (ys ? HALFPI : -HALFPI);
    }

    /*********************************************************************/
    /* check for negative                                                */
    /*********************************************************************/
    sign = ((x = y / x) < 0.0);

    if ((x = fabs(x)) > 1.0)
    {
       x = 1.0 / x;	
       n = 2;	
       t = 1;	                         /* negate partial result */
    }

    /**********************************************************************/
    /* if (x > (2 - sqrt(3)) x = (x * sqrt(3) -1) / (sqrt(3) + x)         */
    /**********************************************************************/
    if (x > TWO_SQRT3)
    {
       x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x); 
       ++n;
    }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = x * x;

#if BITS<=24
    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;
#elif BITS>=25 && BITS<=32
    p = (ATP1 * g + ATP0) * g;
    q = (g + ATQ1) * g + ATQ0;
#elif BITS>=33 && BITS<=50
    p = ((ATP2 * g + ATP1) * g + ATP0) * g;
    q = ((g + ATQ2) * g + ATQ1) * g + ATQ0;
#else
    p = (((ATP3 * g + ATP2) * g + ATP1) * g + ATP0) * g;
    q = (((g + ATQ3) * g + ATQ2) * g + ATQ1) * g + ATQ0;
#endif

    /*********************************************************************/
    /* calculate the result multiplied by the correct sign               */
    /*********************************************************************/
    r = ((p / q) * x + x);
    r = (t ? -r : r) + a[n];
    r = (sign ? -r : r); 

    /*********************************************************************/
    /* adjust result to be in correct quadrant                           */
    /*********************************************************************/
    if (!xs && ys)  r = (PI + r);
    if (!xs && !ys) r = (r - PI);

    return (r);
}

atoi.c/         1146129405  0     0     0       787       `
/****************************************************************************/
/*  atoi v4.1.3                                                             */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

_CODE_ACCESS int atoi(const char *st)
{
    int  result = 0;
    char cp;
    int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}


atol.c/         1146129405  0     0     0       788       `
/****************************************************************************/
/*  atol v4.1.3                                                             */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

_CODE_ACCESS long atol(const char *st)
{
    long result = 0;
    char cp;
    int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}

atoll.c/        1146129405  0     0     0       799       `
/****************************************************************************/
/*  atoll v4.1.3                                                            */
/*  Copyright (c) 2003-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

_CODE_ACCESS long long atoll(const char *st)
{
    long long result = 0;
    char cp;
    int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}


basics.h/       1146129405  0     0     0       3220      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Declarations for all runtime routines.

*/

#ifndef BASICS_H
#define BASICS_H 1

/*
Include the header file that supplies the default configuration
parameters for this version.
*/
#include "defines.h"
/*
EXTERN is defined usually as "extern"; in the translation unit that
actually defines storage for external variables, it is defined as an
empty string.  EXTERN is used on the declarations of external variables
in .h files.  This scheme makes it easy to define them in only one
place while using the same source in all places.  Likewise, 
VAR_INITIALIZERS is defined to cause inclusion of initializers for those
variables.
*/
#ifndef EXTERN
#define EXTERN extern
#endif /* ifndef EXTERN */
#ifndef VAR_INITIALIZERS
#define VAR_INITIALIZERS 0
#endif /* ifndef VAR_INITIALIZERS */

/* Macro used to provide an initial value for variables declared EXTERN. */
#if VAR_INITIALIZERS
#define initial_value(value) = value
#else /* VAR_INITIALIZERS */
#define initial_value(value) /* nothing */
#endif /* VAR_INITIALIZERS */

#ifndef CHECKING
/* Include consistency-checking code. */
#define CHECKING 1
#endif /* ifndef CHECKING */

/*
EXTERN_C is used to declare an external function with C linkage.  When
compiling with a C compiler this is just set to ``extern'', but when
compiling with a C++ compiler it is set to ``extern "C"''.
*/
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else /* !defined(__cplusplus) */
#define EXTERN_C extern
#endif /* __cplusplus */

/*
Definition of a generic byte.  Always "unsigned char".
*/
typedef unsigned char a_byte;

/* Simple boolean type: */
typedef int	a_boolean;
typedef a_byte	a_byte_boolean;
#define FALSE 0
#define TRUE 1

#endif /* BASICS_H */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
boot.asm/       1146129405  0     0     0       823       `
;******************************************************************************
;* BOOT  v4.1.3                                                                *
;* Copyright (c) 2000-2006 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* BOOT.ASM
;*
;* THIS INCLUDES THE APPROPRIATE INITAL BOOT ROUTINE FOR C2000 C++ PROGRAMS.
;* IT MUST BE LINKED AND LOADED WITH ALL C++ PROGRAMS.
;*
;****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "boot27.inc"
        .elseif .TMS320C2800
                .include "boot28.inc"
        .endif

boot27.inc/     1146129405  0     0     0       12080     `
;******************************************************************************
;* BOOT  v4.1.3
;* Copyright (c) 1998-2006 Texas Instruments Incorporated
;******************************************************************************

;****************************************************************************
;* BOOT.ASM
;*
;* THIS IS THE INITAL BOOT ROUTINE FOR C27xx C++ PROGRAMS.
;* IT MUST BE LINKED AND LOADED WITH ALL C++ PROGRAMS.
;* 
;* THIS MODULE PERFORMS THE FOLLOWING ACTIONS:
;*   1) SET RESET VECTOR TO POINT AT _C_INT00
;*   2) ALLOCATES THE STACK AND INITIALIZES THE STACK POINTER
;*   3) SET UP PROPER STATUS
;*   4) PERFORMS AUTO-INITIALIZATION
;*   5) CALLS INITALIZATION ROUTINES FOR FILE SCOPE CONSTRUCTION
;*   6) CALLS THE FUNCTION MAIN TO START THE C++ PROGRAM
;*   7) CALLS THE STANDARD EXIT ROUTINE
;*
;* THIS MODULE DEFINES THE FOLLOWING GLOBAL SYMBOLS:
;*   1) __stack     STACK MEMORY AREA
;*   2) _c_int00    BOOT ROUTINE
;*
;****************************************************************************
CONST_COPY	.set 0

	.global  _c_int00, cinit, pinit
	.global  __args_main, _exit

****************************************************************************
* Declare the stack.  Size is determined by the linker option -stack.  The *
* default value is 1K words.                                               *
****************************************************************************
__stack:	.usect	".stack",0

****************************************************************************
*  INITIALIZE RESET VECTOR TO POINT AT _c_int00                            *
****************************************************************************
	.sect .reset
	.long _c_int00

	.text
****************************************************************************
* FUNCTION DEF : _c_int00                                                  *
*                                                                          *
****************************************************************************

_c_int00:	.asmfunc
****************************************************************************
*  INITIALIZE STACK POINTER.                                               *
****************************************************************************
	MOV  	SP,#__stack		; set to beginning of stack space

****************************************************************************
* INITIALIZE STATUS BIT FIELDS *NOT* INITIALIZED AT RESET                  *
****************************************************************************
	SPM	0			; set product shift to 0

****************************************************************************
* SETTING THESE STATUS BITS/REGISTER TO RESET VALUES.  IF YOU RUN          *
* _c_int00 FROM RESET, YOU CAN REMOVE THIS CODE                            *
****************************************************************************
	CLRC    PAGE0			; use stack addressing mode
        MOVW    DP,#0			; initialize DP to point at low 64K
	CLRC    OVM         		; turn off overflow mode

	ASP				; ensure SP is aligned

****************************************************************************
* SET THE EALLOW BIT BEFORE THE CINIT TABLE IS COPIED.                     *
****************************************************************************
        EALLOW

****************************************************************************
*  IF cinit IS NOT -1, PROCESS CINIT INITIALIZATION TABLE	           *
****************************************************************************
	MOV	AL,#cinit
	MOV	AH,#hi16(cinit)
	ADDB	ACC,#1
	B	DO_PINIT,EQ		; if cinit < 0 (-1) no init tables

****************************************************************************
*  PROCESS CINIT INITIALIZATION TABLE.  TABLE IS IN PROGRAM MEMORY IN THE  *
*  FOLLOWING FORMAT:                                                       *
*                                                                          *
*       .word  <length of init data in words>                              *
*       .word  or .long <address of variable to initialize>                *
*       .word  <init data>                                                 *
*       .word  ...                                                         *
*                                                                          *
*  If the variable's address is greater than 65535 (located in 'far'       *
*  memory), then the address field of the cinit record will be 32-bits     *
*  instead of the default 16-bits. The length value is negated to tag      *
*  cinit records for those variables located in far memory.                *
*                                                                          *
*  The init table is terminated with a zero length                         *
*                                                                          *
****************************************************************************
	MOV	XAR7,#cinit		; point XAR7 at start of table	
	CLRC    TC		        ; reset TC bit used as far flag 
	B 	START			; jump to start processing
LOOP:
	MOVB    AH,#0		        ; zero out upper addr bits
	PREAD   AL,*XAR7		; load address of variable to be inited
	ADDB    XAR7,#1			; point to initialization data
       	B	GET_DATA,NTC	        ; get data if variable is not far 
	CLRC    TC		        ; reset TC bit used as far flag 
	PREAD   AH,*XAR7	        ; otherwise, get hi bits of 22-bit addr
	ADDB    XAR7,#1
GET_DATA:	
	MOVL	XAR6,ACC	        ; address
	RPT	AR1			; repeat length + 1 times
||	PREAD   *XAR6++,*XAR7		; copy data from table to memory
	
	MOVL	ACC,XAR7		; using ACC as temp, point XAR7 to 
	ADD  	ACC,AR1			; next cinit record since PREAD 
	ADDB	ACC,#1			; doesn't change value of XAR7. 
	MOVL	XAR7,ACC	
START:
	PREAD	AL,*XAR7		; load length
	B	GET_ADDR,GEQ	        ; a length < 0 denotes far data	 
        NEG     AL		        ; negate value to get real length	
	SETC    TC		        ; flag that the address field is 32-bits
GET_ADDR:	
	MOV	AR1,AL		        ; copy length value to loop register
	NOP			        ; nops required for AR/BANZ pipeline bug
	NOP			        ; in C1 core
        ADDB    XAR7,#1			; point to address field
	BANZ	LOOP,AR1--		; if (length-- != 0) continue 

****************************************************************************
*  IF pinit IS NOT -1, PROCESS CONSTRUCTOR ROUTINES                        *
****************************************************************************
DO_PINIT:			

****************************************************************************
* CLEAR THE EALLOW BIT AFTER THE CINIT TABLE IS COPIED.                    *
****************************************************************************
        EDIS

	MOV	AL,#pinit
	MOV	AH,#hi16(pinit)
	ADDB	ACC,#1
	B	DONE_INIT,EQ		; if pinit < 0 (-1) no pinit table

****************************************************************************
*  PROCESS PINIT SECTION. TABLE CONSISTS OF CONSTRUCTOR ROUTINE ADDRESSES  *
*  THAT POINT TO C++ INITIALIZATION FUNCTIONS. THESE ROUTINES MUST EXECUTE *
*  BEFORE MAIN IS CALLED                                                   *
****************************************************************************
	MOV     XAR7,#pinit	        ; set up pointer to initialization table
	B	START_PINIT	        ; jump to start processing

LOOP_PINIT:	
	ADDB    XAR7,#1			; point to next table entry	
	PUSH	XAR7			; save off table entry address 
	MOVL	XAR7,ACC		; load constructor routine address
	CALL    *XAR7			; execute routine
	POP	XAR7			; reload table entry address 
	
START_PINIT:	
	PREAD   AL,*XAR7	        ; unpack constructor routine address 
	ADDB    XAR7,#1		
	PREAD   AH,*XAR7	
	TEST	ACC			; test for table end condition (zero)	
	B	LOOP_PINIT,NEQ		; process table entry if not zero
	
	
****************************************************************************
*  COPY CONSTANTS TO DATA MEMORY, IF NECESSARY                             *
****************************************************************************
DONE_INIT:
	.if CONST_COPY
        CALL	_const_init
	.endif

****************************************************************************
*  CALL USER'S PROGRAM                                                     *
****************************************************************************
	CALL    __args_main		; execute main()
	CALL 	_exit
	.endasmfunc

	.if CONST_COPY

****************************************************************************
* FUNCTION DEF : __const_init                                              *
*                                                                          *
*  COPY .CONST AND .ECONST SECTION FROM PROGRAM TO DATA MEMORY             *
*                                                                          *
*   The function depends on the following variables                        *
*   defined in the linker command file                                     *
*                                                                          *
*   __c_load         ; global var containing start                         *
*                      of .const in program memory                         *
*   __const_run      ; global var containing run                           *
*                      address in data memory                              *
*   __const_length   ; global var length of .const                         *
*                      section                                             *
*                                                                          *
*                                                                          *
*   Similarly for constants to be placed into extended memory (far):       *
*                                                                          *
*   __ec_load         ; global var containing start                        *
*                      of .econst in program memory                        *
*   __econst_run      ; global var containing run                          *
*                      address in data memory                              *
*   __econst_length   ; global var length of .econst                       *
*                      section                                             *
*                                                                          *
****************************************************************************
        .global __const_length,  __c_load,  __const_run
        .global __econst_length, __ec_load, __econst_run
 
        .sect ".c_mark"              ; establish LOAD adress of
        .label __c_load              ; .const section
 
        .sect ".ec_mark"              ; establish LOAD adress of
        .label __ec_load              ; .econst section
 
        .text
_const_init:	.asmfunc
 
        MOV     AL,#__const_length
        B       __econst_init,EQ
        DEC     AL
        MOV     XAR6,#__const_run
        MOV     XAR7,#__c_load
        RPT     AL
||      PREAD   *XAR6++,*XAR7
 
__econst_init:
        MOV     XAR6, #__econst_length
        MOV     ACC,XAR6
        B       __end_const,EQ
        MOV     XAR6,#__econst_run
        MOV     XAR7,#__ec_load
        DEC     AL
        B       __econst_loop,GEQ
        DEC     AH
__econst_loop:
        MOV     AR0,AH
        RPT     AL
||      PREAD   *XAR6++,*XAR7
        MOV     AH,#0
        ADDL    ACC,XAR7
        ADDB    ACC, #1
        MOV     XAR7,ACC
        MOV     AL, #0xffff
        MOV     AH,AR0
        SUBB    AH,#1
        B       __econst_loop,GEQ
  
******************************************************
*  AT END OF CONSTANT SECTIONS RETURN TO CALLER      *
******************************************************
__end_const:
        RET
	.endasmfunc
        .endif			;  if CONST_COPY
boot28.inc/     1146129405  0     0     0       12431     `
;******************************************************************************
;* BOOT  v4.1.3
;* Copyright (c) 2000-2006 Texas Instruments Incorporated
;******************************************************************************

;****************************************************************************
;* BOOT.ASM
;*
;* THIS IS THE INITAL BOOT ROUTINE FOR C27xx C++ PROGRAMS.
;* IT MUST BE LINKED AND LOADED WITH ALL C++ PROGRAMS.
;* 
;* THIS MODULE PERFORMS THE FOLLOWING ACTIONS:
;*   1) SET RESET VECTOR TO POINT AT _C_INT00
;*   2) ALLOCATES THE STACK AND INITIALIZES THE STACK POINTER
;*   3) SET UP PROPER STATUS
;*   4) PERFORMS AUTO-INITIALIZATION
;*   5) CALLS INITALIZATION ROUTINES FOR FILE SCOPE CONSTRUCTION
;*   6) CALLS THE FUNCTION MAIN TO START THE C++ PROGRAM
;*   7) CALLS THE STANDARD EXIT ROUTINE
;*
;* THIS MODULE DEFINES THE FOLLOWING GLOBAL SYMBOLS:
;*   1) __stack     STACK MEMORY AREA
;*   2) _c_int00    BOOT ROUTINE
;*
;****************************************************************************
CONST_COPY	.set 0

	.global  _c_int00, cinit, pinit
	.global  __args_main, _exit

****************************************************************************
* Declare the stack.  Size is determined by the linker option -stack.  The *
* default value is 1K words.                                               *
****************************************************************************
__stack:	.usect	".stack",0

****************************************************************************
*  INITIALIZE RESET VECTOR TO POINT AT _c_int00                            *
****************************************************************************
	.sect .reset
	.long _c_int00

	.text
****************************************************************************
* FUNCTION DEF : _c_int00                                                  *
*                                                                          *
****************************************************************************

_c_int00:	.asmfunc
****************************************************************************
*  INITIALIZE STACK POINTER.                                               *
****************************************************************************
	MOV  	SP,#__stack		; set to beginning of stack space

****************************************************************************
* INITIALIZE STATUS BIT FIELDS *NOT* INITIALIZED AT RESET                  *
****************************************************************************
	SPM	0			; set product shift to 0

****************************************************************************
* SET C28x MODES                                                           *
****************************************************************************
        C28OBJ                          ; select C28x object mode
        C28ADDR                         ; clear the addressing mode
        C28MAP                          ; set block M0 and M1 mode

****************************************************************************
* SETTING THESE STATUS BITS/REGISTER TO RESET VALUES.  IF YOU RUN          *
* _c_int00 FROM RESET, YOU CAN REMOVE THIS CODE                            *
****************************************************************************
	CLRC    PAGE0			; use stack addressing mode
        MOVW    DP,#0			; initialize DP to point at low 64K
	CLRC    OVM         		; turn off overflow mode

	ASP				; ensure SP is aligned

****************************************************************************
* SET THE EALLOW BIT BEFORE THE CINIT TABLE IS COPIED.                     *
****************************************************************************
	EALLOW

****************************************************************************
*  IF cinit IS NOT -1, PROCESS CINIT INITIALIZATION TABLE	           *
****************************************************************************
	MOV	AL,#cinit
	MOV	AH,#hi16(cinit)
	ADDB	ACC,#1
	B	DO_PINIT,EQ		; if cinit < 0 (-1) no init tables

****************************************************************************
*  PROCESS CINIT INITIALIZATION TABLE.  TABLE IS IN PROGRAM MEMORY IN THE  *
*  FOLLOWING FORMAT:                                                       *
*                                                                          *
*       .word  <length of init data in words>                              *
*       .word  or .long <address of variable to initialize>                *
*       .word  <init data>                                                 *
*       .word  ...                                                         *
*                                                                          *
*  If the variable's address is greater than 65535 (located in 'far'       *
*  memory), then the address field of the cinit record will be 32-bits     *
*  instead of the default 16-bits. The length value is negated to tag      *
*  cinit records for those variables located in far memory.                *
*                                                                          *
*  The init table is terminated with a zero length                         *
*                                                                          *
****************************************************************************
	MOVL	XAR7,#cinit		; point XAR7 at start of table	
	CLRC    TC		        ; reset TC bit used as far flag 
	B 	START, UNC		; jump to start processing
LOOP:
	MOVB    AH,#0		        ; zero out upper addr bits
	PREAD   AL,*XAR7		; load address of variable to be inited
	ADDB    XAR7,#1			; point to initialization data
       	B	GET_DATA,NTC	        ; get data if variable is not far 
	CLRC    TC		        ; reset TC bit used as far flag 
	PREAD   AH,*XAR7	        ; otherwise, get hi bits of 22-bit addr
	ADDB    XAR7,#1
GET_DATA:	
	MOVL	XAR6,ACC	        ; address
	RPT	AR1			; repeat length + 1 times
||	PREAD   *XAR6++,*XAR7		; copy data from table to memory
	
	MOVL	ACC,XAR7		; using ACC as temp, point XAR7 to 
	ADD  	ACC,AR1			; next cinit record since PREAD 
	ADDB	ACC,#1			; doesn't change value of XAR7. 
	MOVL	XAR7,ACC	
START:
	PREAD	AL,*XAR7		; load length
	B	GET_ADDR,GEQ	        ; a length < 0 denotes far data	 
        NEG     AL		        ; negate value to get real length	
	SETC    TC		        ; flag that the address field is 32-bits
GET_ADDR:	
	MOVZ	AR1,AL		        ; copy length value to loop register
        ADDB    XAR7,#1			; point to address field
	BANZ	LOOP,AR1--		; if (length-- != 0) continue 

****************************************************************************
*  IF pinit IS NOT -1, PROCESS CONSTRUCTOR ROUTINES                        *
****************************************************************************
DO_PINIT:			

****************************************************************************
* CLEAR THE EALLOW BIT AFTER THE CINIT TABLE IS COPIED.                    *
****************************************************************************
	EDIS

	MOV	AL,#pinit
	MOV	AH,#hi16(pinit)
	ADDB	ACC,#1
	B	DONE_INIT,EQ		; if pinit < 0 (-1) no pinit table

****************************************************************************
*  PROCESS PINIT SECTION. TABLE CONSISTS OF CONSTRUCTOR ROUTINE ADDRESSES  *
*  THAT POINT TO C++ INITIALIZATION FUNCTIONS. THESE ROUTINES MUST EXECUTE *
*  BEFORE MAIN IS CALLED                                                   *
****************************************************************************
	MOVL    XAR7,#pinit	        ; set up pointer to initialization table
	B	START_PINIT, UNC        ; jump to start processing

LOOP_PINIT:	
	ADDB    XAR7,#1			; point to next table entry	
	PUSH	XAR7			; save off table entry address 
	MOVL	XAR7,ACC		; load constructor routine address
	LCR     *XAR7			; execute routine
	POP	XAR7			; reload table entry address 
	
START_PINIT:	
	PREAD   AL,*XAR7	        ; unpack constructor routine address 
	ADDB    XAR7,#1		
	PREAD   AH,*XAR7	
	TEST	ACC			; test for table end condition (zero)	
	B	LOOP_PINIT,NEQ		; process table entry if not zero
	
	
****************************************************************************
*  COPY CONSTANTS TO DATA MEMORY, IF NECESSARY                             *
****************************************************************************
DONE_INIT:
	.if CONST_COPY
        LCR	_const_init
	.endif

****************************************************************************
*  CALL USER'S PROGRAM                                                     *
****************************************************************************
	LCR     __args_main			; execute main()
	LCR  	_exit
	.endasmfunc

	.if CONST_COPY

****************************************************************************
* FUNCTION DEF : __const_init                                              *
*                                                                          *
*  COPY .CONST AND .ECONST SECTION FROM PROGRAM TO DATA MEMORY             *
*                                                                          *
*   The function depends on the following variables                        *
*   defined in the linker command file                                     *
*                                                                          *
*   __c_load         ; global var containing start                         *
*                      of .const in program memory                         *
*   __const_run      ; global var containing run                           *
*                      address in data memory                              *
*   __const_length   ; global var length of .const                         *
*                      section                                             *
*                                                                          *
*                                                                          *
*   Similarly for constants to be placed into extended memory (far):       *
*                                                                          *
*   __ec_load         ; global var containing start                        *
*                      of .econst in program memory                        *
*   __econst_run      ; global var containing run                          *
*                      address in data memory                              *
*   __econst_length   ; global var length of .econst                       *
*                      section                                             *
*                                                                          *
****************************************************************************
        .global __const_length,  __c_load,  __const_run
        .global __econst_length, __ec_load, __econst_run
 
        .sect ".c_mark"              ; establish LOAD adress of
        .label __c_load              ; .const section
 
        .sect ".ec_mark"              ; establish LOAD adress of
        .label __ec_load              ; .econst section
 
        .text
_const_init:	.asmfunc
 
        MOV     AL,#__const_length
        B       __econst_init,EQ
        DEC     AL
        MOVL    XAR6,#__const_run
        MOVL    XAR7,#__c_load
        RPT     AL
||      PREAD   *XAR6++,*XAR7
 
__econst_init:
        MOVL    XAR6, #__econst_length
        MOVL    ACC,XAR6
        B       __end_const,EQ
        MOVL    XAR6,#__econst_run
        MOVL    XAR7,#__ec_load
        DEC     AL
        B       __econst_loop,GEQ
        DEC     AH
__econst_loop:
        MOV     AR0,AH
        RPT     AL
||      PREAD   *XAR6++,*XAR7
        MOV     AH,#0
        ADDL    ACC,XAR7
        ADDB    ACC, #1
        MOVL    XAR7,ACC
        MOV     AL, #0xffff
        MOV     AH,AR0
        SUBB    AH,#1
        B       __econst_loop,GEQ
 
******************************************************
*  AT END OF CONSTANT SECTIONS RETURN TO CALLER      *
******************************************************
__end_const:
        LRETR
	.endasmfunc
        .endif			;  if CONST_COPY

bsearch.c/      1146129405  0     0     0       1250      `
/****************************************************************************/
/*  bsearch v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>

_CODE_ACCESS void *bsearch(
	      register const void *key,     /* ITEM TO SEARCH FOR           */
              register const void *base,    /* POINTER TO ARRAY OF ELEMENTS */
              size_t nmemb,                 /* NUMBER OF ELEMENTS TO SORT   */
              size_t size,                  /* SIZE IN BYTES OF EACH ITEM   */
              int (*compar)(const void *,const void *)) /* COMPARE FUNCTION */

{
   register int i       = 0;             /* left scan index  */
   register int j       = nmemb - 1;     /* right scan index */

   while( i <= j )
   {
      register int pivot = (j + i) / 2;            
      int result = (*compar) (key, (char *)base + (pivot * size));
      if (result == 0) return((char *)base + (pivot * size));
      if (result < 0) j = pivot - 1;
		 else i = pivot + 1;
   }

   return ((void *)0);   /* IF WE GET TO HERE, WE FAILED */
}


c2000asm.inc/   1146129405  0     0     0       3550      `
* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       c2000asm.inc -- pseudo-op compatibility bridge for pre-5.00 tools   *
*                                                                           *
*   USAGE                                                                   *
*       Just .include at top of your source file.  Alternately, use         *
*       the compiler flag -ahi or -ahc to force inclusion in the            *
*       source-file.                                                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       This file provides a set of pseudo-operations that are intended     *
*       to replace existing mnemonics in certain usage scenarios.  The      *
*       point of the new pseudo-ops is to allow the tools to provide more   *
*       precise information to the profiler as to the *purpose* of a        *
*       branch, so that it can provide more accurate profile data.          *
*                                                                           *
*       Mnemonic    Purpose                                                 *
*       FFCRET      Return from a Fast-Function Call.                       *
*                   Equivalent to "LB", but only accepts *XAR7 as an        *
*                   operand.                                                *
*                                                                           *
*   NOTES                                                                   *
*       This file is actually just a compatibility shim, intended to        *
*       provide forward compatibility between tool versions < 5.00          *
*       and tool versions >= 5.00.  The purpose of this file it purely      *
*       compatibility.  Tool versions >= 5.00 are required to gain the      *
*       greater-precision information for the profiler.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

* ========================================================================= *
* Create "asmver" with current version of assembler. Value is 0 if assembler
* version predates the predefined symbol.
* ========================================================================= *
           .if $isdefed("__TI_ASSEMBLER_VERSION__")
           .asg    __TI_ASSEMBLER_VERSION__, asmver
           .else
           .asg    0, asmver
           .endif

* ========================================================================= *
* If the assembler version predates the support call mnemonics
* ========================================================================= *
           .if asmver < 500
           .asg    LB,    FFCRET     ; Return from Fast-Function Call
           .asg ";", .asmfunc
           .asg ";", .endasmfunc
           .endif

cassert/        1146129405  0     0     0       880       `
/*****************************************************************************/
/* cassert   v4.1.3                                                          */
/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CASSERT
#define _CASSERT

#include <linkage.h>

#define _CPP_STYLE_HEADER
#include <assert.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* #ifndef _CASSERT */
cctype/         1146129405  0     0     0       1461      `
/*****************************************************************************/
/* cctype    v4.1.3                                                          */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CCTYPE
#define _CCTYPE

#define _CPP_STYLE_HEADER
#include <ctype.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* #ifndef _CCTYPE */

cerrno/         1146129405  0     0     0       830       `
/*****************************************************************************/
/*  CERRNO  v4.1.3                                                           */
/*  Copyright (c) 1999-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _CERRNO
#define _CERRNO

#define _CPP_STYLE_HEADER
#include <errno.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif
cfloat/         1146129405  0     0     0       392       `
/*****************************************************************************/
/* cfloat    v4.1.3                                                          */
/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CFLOAT
#define _CFLOAT

#include <float.h>

#endif
ciso646/        1146129405  0     0     0       567       `
/*****************************************************************************/
/* CISO646   v4.1.3                                                          */
/* Copyright (c) 2002-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
/* The identifiers defined in iso646.h are keywords in C++.  That means this */
/* file must be empty.                                                       */
/*****************************************************************************/

clearerr.c/     1146129405  0     0     0       896       `
/*****************************************************************************/
/*  CLEARERR.C v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* CLEARERR -  Clear the I/O error flag (_STATERR)                           */
/*                                                                           */
/*    This function calls a macro defined in stdio.h                         */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS void clearerr(FILE *_fp) { _clearerr(_fp); }

climits/        1146129405  0     0     0       643       `
/*****************************************************************************/
/* limits.h   v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

//----------------------------------------------------------------------------
// <climits> IS RECOMMENDED OVER <limits.h>.  <limits.h> IS PROVIDED FOR 
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
#include <limits.h>

clock.c/        1146129405  0     0     0       1093      `
/****************************************************************************/
/*  clock v4.1.3                                                            */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

/****************************************************************************/
/* OBVIOUSLY, THIS IS SIMPLY A STUB, WHICH BY DEFINITION RETURNS -1         */
/* IF THE SYSTEM TIME IS UNAVAILABLE.                                       */ 
/*--------------------------------------------------------------------------*/
/* OBVIOUSLY, THIS IS NO LONGER A STUB.  THIS WILL RETURN THE CLK REGISTER  */
/* FROM THE EMULATOR OR SIMULATOR.  THIS IS A CYCLE ACURATE COUNT OF THE    */ 
/* NUMBER OF CYCLES THAT HAVE ELAPSED SINCE THE START OF THE PROGRAM.       */ 
/****************************************************************************/
#include <time.h> 
extern clock_t HOSTclock();

_CODE_ACCESS clock_t clock(void)   
{
    return (clock_t)HOSTclock();
}

cmath/          1146129405  0     0     0       1888      `
/*****************************************************************************/
/* cmath     v4.1.3                                                          */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CMATH
#define _CMATH

#include <cfloat>
#define HUGE_VAL  DBL_MAX

extern "C" namespace std
{
   /***************************************************************/
   /* FUNCTION DEFINITIONS.                                       */
   /***************************************************************/
          double modf(double x, double *y); 
          double asin(double x);
          double acos(double x);
          double atan(double x);
          double atan2(double y, double x);
 __inline double ceil(double x)  { double y; return (modf(x, &y) > 0 ? y+1:y); }
          double cos(double x);
          double cosh(double x);
          double exp(double x);
 __inline double floor(double x) { double y; return (modf(x, &y) < 0 ? y-1:y); }
          double fmod(double x, double y);
          double frexp(double x, int *exp);
          double ldexp(double x, int exp);
          double log(double x);
          double log10(double x);
          double pow(double x, double y);
          double sin(double x);
          double sinh(double x);
          double tan(double x);
          double tanh(double x);
          double sqrt(double x);
}

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif

#endif 
config.h/       1146129405  0     0     0       15006     `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Configuration parameters for the runtime.

*/

#ifndef CONFIG_H
#define CONFIG_H 1

/*
Flag used to retain ABI (Application Binary Interface, i.e., runtime layout
and calling sequence) compatibility with older versions.  The value is the
version number of the EDG C++ front end, e.g., 227 for version 2.27, for
which compatibility should be maintained.  ABI changes made after that
version will be suppressed.  Of course, that may suppress certain language
features that cannot be implemented without the corresponding ABI changes.
The default is 228, which results in the ABI being compatible with earlier
versions of the front end.

Beginning with version 2.29, the front end defines a preprocessing symbol
called __EDG_ABI_COMPATIBILITY_VERSION that defines the ABI level
being used by the front end.  This value is used, if it is defined.
*/
#ifndef ABI_COMPATIBILITY_VERSION
#ifdef __EDG_ABI_COMPATIBILITY_VERSION
#define ABI_COMPATIBILITY_VERSION __EDG_ABI_COMPATIBILITY_VERSION
#else /* ifndef __EDG_ABI_COMPATIBILITY_VERSION */
#define ABI_COMPATIBILITY_VERSION 228
#endif /* ifdef __EDG_ABI_COMPATIBILITY_VERSION */
#endif /* ifndef ABI_COMPATIBILITY_VERSION */

/*
This flag indicates that the runtime system may be called by cfront-generated
code, and consequently that it must behave as expected by the cfront code.
For example, cfront passes eight NULL pointers to constructors called
from vec_new.  The NULL pointers initialize parameters that point to
virtual base classes.  We only do this in cfront compatibility mode.
*/
#ifndef CFRONT_COMPATIBILITY_MODE
#ifdef __EDG_IA64_ABI
#define CFRONT_COMPATIBILITY_MODE FALSE
#else /* !defined(__EDG_IA64_ABI) */
#define CFRONT_COMPATIBILITY_MODE TRUE
#endif /* !defined(__EDG_IA64_ABI) */
#endif /* ifndef CFRONT_COMPATIBILITY_MODE */
#if CFRONT_COMPATIBILITY_MODE && defined(__EDG_IA64_ABI)
 #error -- CFRONT_COMPATIBILITY_MODE TRUE is incompatible with \
           __EDG_IA64_ABI
#endif /* CFRONT_COMPATBILITY_MODE && defined(__EDG_IA64_ABI) */

/*
The runtime uses one of several different mechanisms to invoke static
destructors upon completion of the program.  On Suns, on_exit is used.
For ANSI C environments, atexit is used.  Otherwise a version of
exit is supplied in our runtime library to replace the one normally
found in the C library (e.g., libc.a).  Using our exit may affect
usage that requires an alternate version of the exit function, such
as generating profiling information.

USE_ATEXIT indicates that the atexit function should be used.
*/
#ifndef USE_ATEXIT
#if defined(sun) && __EDG_BSD
#define USE_ATEXIT FALSE
#else /* !(defined(sun) && __EDG_BSD) */
#define USE_ATEXIT TRUE
#endif /* !(defined(sun) && __EDG_BSD) */
#endif /* ifndef USE_ATEXIT */

/*
Should the components of the runtime system that implement
exception handling be included.
*/

#ifdef __EXCEPTIONS 
#define EXCEPTION_HANDLING TRUE
#endif /* ifndef EXCEPTION_HANDLING */

/*
Should the EDG-supplied exception classes be used.  This flag may be
set to FALSE if a third party standard library is being used that includes
classes such as bad_alloc, etc.
*/
#ifndef USE_EDG_EXCEPTION_CLASSES
#define USE_EDG_EXCEPTION_CLASSES TRUE
#endif /* ifndef USE_EDG_EXCEPTION_CLASSES */

/*
Should the out-of-line copy of the placement new routines be defined?
This flag may be set to FALSE if a third party library defines these
routines inline.
*/
#ifndef DEFINE_PLACEMENT_NEW_ROUTINES
#define DEFINE_PLACEMENT_NEW_ROUTINES TRUE
#endif /* ifndef DEFINE_PLACEMENT_NEW_ROUTINES */



/*
Should the components of the runtime system that implement run-time
type identification be included.  Note that enabling ABI_CHANGES_FOR_RTTI
alters the structure of the a_type_info_impl that is shared by
ABI_CHANGES_FOR_RTTI and exception handling, consequently
ABI_CHANGES_FOR_RTTI cannot be enabled when preserving ABI compatibility
with versions up to 2.28.  When the --building_runtime option is specified,
the front end defines __EDG_ABI_CHANGES_FOR_RTTI as 0 or 1 to indicate
how it is configured.
*/
#ifndef ABI_CHANGES_FOR_RTTI
#ifdef __EDG_ABI_CHANGES_FOR_RTTI
#define ABI_CHANGES_FOR_RTTI __EDG_ABI_CHANGES_FOR_RTTI
#else /* !defined(__EDG_ABI_CHANGES_FOR_RTTI) */
#if ABI_COMPATIBILITY_VERSION <= 228
#define ABI_CHANGES_FOR_RTTI FALSE /* Versions up to 2.28. */
#else /* ABI_COMPATIBILITY_VERSION > 228 */
#define ABI_CHANGES_FOR_RTTI TRUE  /* Versions after 2.28. */
#endif /* ABI_COMPATIBILITY_VERSION <= 228 */
#endif /* ifdef __EDG_ABI_CHANGES_FOR_RTTI */
#endif /* ifndef ABI_CHANGES_FOR_RTTI */
#if ABI_CHANGES_FOR_RTTI && (ABI_COMPATIBILITY_VERSION <= 228)
 #error -- ABI_CHANGES_FOR_RTTI TRUE is incompatible with \
           ABI_COMPATIBILITY_VERSION <= 228
#endif /* ABI_CHANGES_FOR_RTTI && (ABI_COMPATIBILITY_VERSION <= 228) */

/*
This switch controls whether or not the ABI changes for array
new and delete are done.  New runtime routines are added.
The changes are upward-compatible (you can use old object code
with new object code and the new library).  If the switch is off,
compatibility with versions up to 2.28 is preserved, but the
array new and delete language features are turned off.
When the --building_runtime option is specified, the front end
defines __EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE as 0 or 1 to
indicate how it is configured.
*/
#ifndef ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE
#ifdef __EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE
#define ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE \
				__EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE
#else /* !defined(__EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE) */
#if ABI_COMPATIBILITY_VERSION <= 228
#define ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE FALSE /* Versions up to 2.28. */
#else /* ABI_COMPATIBILITY_VERSION > 228 */
#define ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE TRUE  /* Versions after 2.28. */
#endif /* ABI_COMPATIBILITY_VERSION <= 228 */
#endif /* ifdef __EDG_ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */
#endif /* ifndef ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */
#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && (ABI_COMPATIBILITY_VERSION <= 228)
 #error -- ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE TRUE is incompatible with \
           ABI_COMPATIBILITY_VERSION <= 228
#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE && ... */


/*
This switch controls whether or not the ABI changes for placement
delete are done.  New runtime routines/variables are added.
The changes are upward-compatible (you can use old object code
with new object code and the new library).  If the switch is off,
compatibility with versions up to 2.33 is preserved, but the
placement delete language feature is turned off.  Allocating an
array with placement new and then using the delete operator on it
is also considered part of "placement delete" and is controlled by
this switch.
*/
#ifndef ABI_CHANGES_FOR_PLACEMENT_DELETE
/* If this value is not defined, use the value defined by the front end,
   if one is provided.  Otherwise, assume that the feature is not supported. */
#ifdef __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE
#define ABI_CHANGES_FOR_PLACEMENT_DELETE __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE
#else /* ifndef __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE */
#define ABI_CHANGES_FOR_PLACEMENT_DELETE FALSE
#endif /* ifndef __EDG_ABI_CHANGES_FOR_PLACEMENT_DELETE */
#endif /* ifndef ABI_CHANGES_FOR_PLACEMENT_DELETE */

/*
This switch controls how the runtime keeps track of information about the
size of arrays that have been allocated.  Through version 2.28 this
information was maintained using a separate data structure allocated
by vec_new.  Beginning with 2.29 this information is maintained in
header block that is part of the array memory allocated.  The new
mechanism can be used with older ABI versions.   The only consequences
of this are that the size of the memory blocks requested from operator
new will change because they now include the size of the prefix information,
and the behavior of programs that perform undefined operations (e.g.,
writing to memory that preceded the beginning of the array) may change.
*/
#ifndef USE_PREFIX_FOR_ARRAY_ALLOC_INFO
#if ABI_COMPATIBILITY_VERSION <= 228
#define USE_PREFIX_FOR_ARRAY_ALLOC_INFO FALSE /* Versions up to 2.28. */
#else /* ABI_COMPATIBILITY_VERSION > 228 */
#define USE_PREFIX_FOR_ARRAY_ALLOC_INFO TRUE  /* Versions after 2.28. */
#endif /* ABI_COMPATIBILITY_VERSION <= 228 */
#endif /* ifndef USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO && defined(__EDG_IA64_ABI)
 #error -- USE_PREFIX_FOR_ARRAY_ALLOC_INFO FALSE is not compatible with \
           __EDG_IA64_ABI
#endif /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO && ... */  

/*
This flag is used with the IA-64 ABI to specify that the underlying system
runtime includes certain of the IA-64 facilities (so this runtime does not
need to provide them).
*/
#ifndef SYSTEM_RUNTIME_HAS_IA64_SUPPORT

#ifdef __EDG_IA64_ABI

#ifdef __linux__
#define SYSTEM_RUNTIME_HAS_IA64_SUPPORT TRUE
#else /* ifndef __linux__ */
#define SYSTEM_RUNTIME_HAS_IA64_SUPPORT FALSE
#endif /* ifdef __linux__ */

#else /* ifndef __EDG_IA64_ABI */
#define SYSTEM_RUNTIME_HAS_IA64_SUPPORT FALSE
#endif /* ifdef __EDG_IA64_ABI */

#endif /* ifndef SYSTEM_RUNTIME_HAS_IA64_SUPPORT */

/*
Some systems have partial IA-64 support in their runtime, but lack the
__cxa_atexit function.  This flag (when TRUE) indicates that the system
runtime includes the __cxa_atexit function.
*/
#ifdef __EDG_IA64_ABI
#ifndef SYSTEM_RUNTIME_HAS_IA64_ATEXIT

#if SYSTEM_RUNTIME_HAS_IA64_SUPPORT
#ifdef __linux__
#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT TRUE
#else /* ifndef __linux__ */
#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT FALSE
#endif /* ifdef __linux__ */
#else /* !SYSTEM_RUNTIME_HAS_IA64_SUPPORT */
/* The system does not have IA-64 support, so it can't have atexit. */
#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT FALSE
#endif /* SYSTEM_RUNTIME_HAS_IA64_SUPPORT */
#endif /* ifndef SYSTEM_RUNTIME_HAS_IA64_ATEXIT */

#else /* ifndef __EDG_IA64_ABI */
#define SYSTEM_RUNTIME_HAS_IA64_ATEXIT FALSE
#endif /* ifdef __EDG_IA64_ABI */

#if EXCEPTION_HANDLING
/*
The EH runtime allocates a static block of memory to be used for purposes
of tracking pending exceptions, making a copy of the thrown object, etc.
Additional space is allocated if needed.  This parameter specifies the
size of the initial block of memory allocated and the minimum size of
any additional blocks that are required.
*/
#ifndef EH_MEMORY_ALLOCATION_INCREMENT
#define EH_MEMORY_ALLOCATION_INCREMENT 128
#endif /* ifndef EH_MEMORY_ALLOCATION_INCREMENT */

/*
A type that, when used, will be aligned with the strictest alignment
requirements.
*/
#ifndef TYPE_WITH_MOST_STRICT_ALIGNMENT
#define TYPE_WITH_MOST_STRICT_ALIGNMENT double
#endif /* ifndef TYPE_WITH_MOST_STRICT_ALIGNMENT */

#if ABI_CHANGES_FOR_RTTI
/*
The mangled name of the unique ID for a void type.
*/
#ifndef MANGLED_NAME_OF_UNIQUE_ID_OF_VOID
#define MANGLED_NAME_OF_UNIQUE_ID_OF_VOID __TID_v
#endif /* ifndef MANGLED_NAME_OF_UNIQUE_ID_OF_VOID */
#else /* ! ABI_CHANGES_FOR_RTTI */
/*
The mangled name of the typeinfo record for a void type.
*/
#ifndef MANGLED_NAME_OF_VOID
#define MANGLED_NAME_OF_VOID __T_v
#endif /* ifndef MANGLED_NAME_OF_VOID */
#endif /* ! ABI_CHANGES_FOR_RTTI */

/*
Flag that is TRUE if the definition of jmp_buf from the setjmp.h header
file should be used instead of the element type and array size passed
by the front end.  This is useful on systems where the setjmp buffer
is a structure instead of an array.
*/
#ifndef USE_SYSTEM_JMP_BUF_DEFINITION
#if defined(__linux__) || defined(__hpux)
#define USE_SYSTEM_JMP_BUF_DEFINITION TRUE
#else /* if !(defined(__linux__) || defined(__hpux)) */
/*** START TI ADD ***/
#define USE_SYSTEM_JMP_BUF_DEFINITION TRUE
/*** END TI ADD ***/
/* #define USE_SYSTEM_JMP_BUF_DEFINITION FALSE */
#endif /* if defined(__linux__) || defined(__hpux) */
#endif /* ifndef USE_SYSTEM_JMP_BUF_DEFINITION */

/*
Flag that is TRUE if the stack should be unwound before terminate()
is called when an exception with no matching handler is thrown.
According to the Working Paper, it is unspecified whether or not the
stack is unwound in this case.
*/
#ifndef UNWIND_STACK_BEFORE_CALLING_TERMINATE
#define UNWIND_STACK_BEFORE_CALLING_TERMINATE TRUE
#endif /* ifndef UNWIND_STACK_BEFORE_CALLING_TERMINATE */

#endif /* EXCEPTION_HANDLING */

/*
Define macros that are used to define exception specifications.  The
macros are used so that the throw specifications can be discarded when
exception handling is not being used.
*/
#if EXCEPTION_HANDLING
#define THROW(throw_spec) throw(throw_spec)
#define THROW_NOTHING() throw()
#else /* !EXCEPTION_HANDLING */
#define THROW(throw_spec) /* Nothing. */
#define THROW_NOTHING() /* Nothing. */
#endif /* EXCEPTION_HANDLING */

/*
The strictest alignment required of any data type.  This should be
the alignment that malloc uses for memory that is allocated.
*/
#ifndef MOST_STRICT_ALIGNMENT
#define MOST_STRICT_ALIGNMENT 8
#endif /* ifndef MOST_STRICT_ALIGNMENT */

/*
Flag that is TRUE if a message containing the reason for a runtime
abort should be displayed.
*/
#ifndef DISPLAY_ABORT_DESCRIPTION
#define DISPLAY_ABORT_DESCRIPTION FALSE
#endif /* ifndef DISPLAY_ABORT_DESCRIPTION */



#endif /* CONFIG_H */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

cos.c/          1146129405  0     0     0       3017      `
/****************************************************************************/
/*  cos    v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  COS() - Cosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI + 1/2) - 0.5					    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = f + f * R							    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double cos(double x)
{
    int sign;           /* the sign of the result */
    double xn, f, g, rg, result;
    int n;

    /**************************************************************************/
    /* cos(x) = cos(-x)                                                       */
    /**************************************************************************/
    x = fabs(x);

    /**************************************************************************/
    /* n = round(x/PI + 1/2) (can be rounded this way, since positive number) */
    /**************************************************************************/
    n  = (int) (((x + HALFPI) * INVSPI) + 0.5);
    xn = (double) n - 0.5;

    /**************************************************************************/
    /* if n is odd, negate the sign                                           */
    /**************************************************************************/
    sign = n % 2;

    /**************************************************************************/
    /* f = x - xn * PI (but more mathematically stable)                       */
    /**************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    g = f * f;

#if BITS<=24
    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=25 && BITS<=32
    rg = ((((R5 * g + R4) * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=33 && BITS<=50
    rg = ((((((R7*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#else
    rg = (((((((R8*g+R7)*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#endif

    result = f + f * rg; 
    return sign ? -result : result; 
}

cosh.c/         1146129405  0     0     0       3637      `
/****************************************************************************/
/*  cosh   v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  COSH() - Hyperbolic Cosine						    */
/*               							    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*               							    */
/*  result = (exp(x) + 1 / exp(x)) / 2		  			    */
/****************************************************************************/
double cosh(double x)
{
  double g, z, q, p, r, a, b;
  int n;

  /****************************************************************************/
  /* cosh(x) = cosh(-x)                                                       */
  /****************************************************************************/
  x = fabs(x);

  /****************************************************************************/
  /* check to see if overflow would occur                                     */
  /****************************************************************************/
  if (x > MAXH) { errno = ERANGE; return (HUGE_VAL); }

  if (x < 0) n = (int) (x * INVLOGe2 - 0.5);       /* since (int) -1.5 = -1.0 */
  else       n = (int) (x * INVLOGe2 + 0.5);

  /****************************************************************************/
  /* g = x - n * ln(2) (but more mathematically stable)                       */
  /****************************************************************************/
  g  = (x - n * C3) - n * C4;

  /****************************************************************************/
  /* determine polynomial expression                                          */
  /****************************************************************************/
  z  = g * g;

#if BITS <=29
  p = (EXP1 * z + EXP0) * g;
  q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
  p = (EXP1 * z + EXP0) * g;
  q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
  p = ((EXP2 * z + EXP1) * z + EXP0) * g;
  q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
  p = ((EXP2 * z + EXP1) * z + EXP0) * g;
  q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

  /****************************************************************************/
  /* calculate exp(g)                                                         */
  /****************************************************************************/
  r  = 0.5 + p / (q - p);

  /****************************************************************************/
  /* exp(x)/2 = exp(g) * 2 ^ (n)                                              */
  /****************************************************************************/
  a = ldexp(r, n);

  /****************************************************************************/
  /* exp(-x)*2 = 1 / (exp(x)/2)                                               */
  /****************************************************************************/
  b  = 1.0 / a;

  /****************************************************************************/
  /* cosh(x) = exp(x)/2 + exp(-x)*2 / 4                                       */
  /****************************************************************************/
  return (a + b * 0.25);
}

cpy_tbl.c/      1146129405  0     0     0       1533      `
/*****************************************************************************/
/* cpy_tbl.c  v4.1.3                                                         */
/* Copyright (c) 2003 Texas Instruments Incorporated                         */
/*                                                                           */
/* General purpose copy routine.  Given the address of a linker-generated    */
/* COPY_TABLE data structure, effect the copy of all object components       */
/* that are designated for copy via the corresponding LCF table() operator.  */
/*****************************************************************************/
#include <cpy_tbl.h>

/*****************************************************************************/
/* COPY_IN()                                                                 */
/*****************************************************************************/
void copy_in(COPY_TABLE *tp)
{
   unsigned int i;
   for (i = 0; i < tp->num_recs; i++)
   {
      COPY_RECORD *crp = &tp->recs[i];
      unsigned int cpy_type = 0;

      if (crp->src_pgid) cpy_type += 2;
      if (crp->dst_pgid) cpy_type += 1;

      switch (cpy_type)
      {
         case 3: ddcopy(crp->src_addr, crp->dst_addr, crp->size); break;
         case 2: dpcopy(crp->src_addr, crp->dst_addr, crp->size); break;
         case 1: pdcopy(crp->src_addr, crp->dst_addr, crp->size); break;
         case 0: ppcopy(crp->src_addr, crp->dst_addr, crp->size); break;
      }
   }            
}

cpy_tbl.h/      1146129405  0     0     0       2349      `
/*****************************************************************************/
/* cpy_tbl.h  v4.1.3                                                         */
/* Copyright (c) 2003 Texas Instruments Incorporated                         */
/*                                                                           */
/* Specification of copy table data structures which can be automatically    */
/* generated by the linker (using the table() operator in the LCF).          */
/*****************************************************************************/

/*****************************************************************************/
/* Copy Record Data Structure                                                */
/*****************************************************************************/
typedef struct copy_record
{
   unsigned int		 src_pgid;
   unsigned int		 dst_pgid;
   unsigned long	 src_addr;
   unsigned long	 dst_addr;
   unsigned long	 size;
} COPY_RECORD;

/*****************************************************************************/
/* Copy Table Data Structure                                                 */
/*****************************************************************************/
typedef struct copy_table 
{
   unsigned int		 rec_size;
   unsigned int		 num_recs;
   COPY_RECORD		 recs[1];
} COPY_TABLE;

/*****************************************************************************/
/* Prototypes for near and far general purpose copy routines.                */
/*****************************************************************************/
extern void copy_in(COPY_TABLE *tp);
extern void far_copy_in(far COPY_TABLE *tp);

/*****************************************************************************/
/* Prototypes for utilities used by copy_in() to move code/data between      */
/* program and data memory (see cpy_utils.asm for source).                   */
/*****************************************************************************/
extern void ddcopy(unsigned long src, unsigned long dst, unsigned long size);
extern void dpcopy(unsigned long src, unsigned long dst, unsigned long size);
extern void pdcopy(unsigned long src, unsigned long dst, unsigned long size);
extern void ppcopy(unsigned long src, unsigned long dst, unsigned long size);


cpy_utils.asm/  1146129405  0     0     0       6722      `
;******************************************************************************
;* CPY_UTILS v4.1.3                                                           *
;* Copyright (c) 2003                                                         *
;******************************************************************************
        .include "c2000asm.inc"

;********************************************************************
; CPY_UTILS.ASM
;
; Copy utility functions to perform 4 different types of copy,
; data -> data, data -> program, program -> data, and
; program -> program.
;
; source address always arrives in the accumulator 'ACC'
; destination address arrives on the stack '*-SP[2]'
;
; We will use XAR6 and XAR7 as temporary registers in 
; these routines.
;
;********************************************************************

	.if	.TMS320C2800
;********************************************************************
; In C28x, the memory is unified and hence the data and program can be
; accessed using data or program access. So the 4 different types of 
; copy ends up being the same. Since we don't support huge model to reach
; all the 32-bit data address space in the compiler here we assume that
; both data and program address range are limited to 0x3fffff. Hence 
; we use RPT PREAD. The user can modify this implementation to suite
; their needs.
;********************************************************************
	.sect	".text"
	.global	_ddcopy
	.global	_dpcopy
	.global	_pdcopy
	.global	_ppcopy
_ddcopy:
_dpcopy:
_pdcopy:
_ppcopy:
        MOVL    XAR7,ACC         ; place source addr into XAR7   
        MOVL    XAR4,*-SP[4]     ; load destination addr into XAR4
        MOVL    ACC,*-SP[6]      ; load copy size in bytes into ACC

        CMPB    AL, #0
        BF      $10, EQ          ; If AL is zero jump to check AH

        SUBB    AL, #1           ; First copy LO16(copy_size) bytes.
        RPT     AL
     || PREAD	*XAR4++,*XAR7

$10
        CMPB    AH, #0           ; 
        BF      $30, EQ          ; If AH is zero then we are done.
                                 ; else copy remaining data in 64K chunks
        MOV     PL, *-SP[6]      ; 
        MOV     PH, #0           ; Since XAR7 is not updated in PREAD,         
        ADDUL   P, XAR7          ; keep track of the udpated source addr in P
$20:
        MOVL    XAR7, P          ; Get the source address from P
                                 ; A simulator bug prevents using 0xffff as
        PREAD	*XAR4++,*XAR7    ; repeat count. So copy one byte and do   
                                 ; repeat pread on 64K-1 bytes.
        ADDB    XAR7, #1         ; 
        MOV     AL, #0xfffe      ; 
        RPT     AL
     || PREAD	*XAR4++,*XAR7

        ADD     PH, #1           ; Update the source address in P.
        LSR     AH, #1           ; Copy 64K chunks of data repeatedly until
        BF      $20, NEQ         ; all the bytes are copied.
$30:
        LRETR
        .else

	.sect	".text"
	.global	_ddcopy
;********************************************************************
; Data Memory -> Data Memory
;********************************************************************
_ddcopy:
        MOVL    XAR6,ACC         ; place source addr into XAR6
        MOV     XAR7,*-SP[4]     ; load destination addr into XAR7
        MOVL    ACC,*-SP[6]      ; load copy size in bytes into ACC
        B       $20, EQ
$10:
        MOV	AR4,*XAR6++      ; copy copy_size bytes in this loop
        SUBB    ACC,#1
        MOV	*XAR7++,AR4
        B       $10, NEQ

$20:
        RET

	.sect	".text"
	.global	_dpcopy
;********************************************************************
; Data Memory -> Program Memory
;
; Transfer the dest address into XAR7 so that we can use a PWRITE
; instruction to store the data into program memory.
;********************************************************************
_dpcopy:
        MOVL    XAR6,ACC         ; place source addr into XAR7   
        MOV     XAR7,*-SP[4]     ; load destination addr into XAR4
        MOVL    ACC,*-SP[6]      ; load copy size in bytes into ACC
        B       $40, EQ          
$30:
        PWRITE  *XAR7,*XAR6++    ; copy copy_size bytes in this loop
        ADDB    XAR7, #1
        SUBB    ACC, #1 
        B       $30, NEQ
$40:
        RET   

	.sect	".text"
	.global	_pdcopy
;********************************************************************
; Program Memory -> Data Memory
;
; Put source address into XAR7 so we can use a PREAD instruction to
; get the data from program memory.
;********************************************************************
_pdcopy:
        MOVL    XAR7,ACC         ; place source addr into XAR7   
        MOV     XAR6,*-SP[4]     ; load destination addr into XAR4
        MOVL    ACC,*-SP[6]      ; load copy size in bytes into ACC
        B       $60, EQ          
$50:
        PREAD   *XAR6++,*XAR7    ; copy copy_size bytes in this loop
        ADDB    XAR7, #1
        SUBB    ACC, #1 
        B       $50, NEQ
$60:
        RET   

	.sect	".text"
	.global	_ppcopy
;********************************************************************
; Program Memory -> Program Memory
;
; First read the data from program memory into the accumulator.
; Then store it into the destination location (also in program 
; memory).  We use XAR7 to hold first the source address and then
; the dest address so that we can make use of the PREAD and 
; PWRITE instructions for reading/writing data from/to program
; memory.
;********************************************************************
        .asg *-SP[2], SADDR
        .asg XAR6,    DADDR
_ppcopy:
        PUSH    ACC              ; push source address into stack
        MOV     DADDR,*-SP[6]    ; load destination addr into DADDR
        MOVL    ACC,*-SP[8]      ; load copy size in bytes into ACC
        B       $80, EQ
$70:
        MOV 	XAR7,SADDR       ; Load Source Address into XAR7
	PREAD	AR4,*XAR7        ; Read from Program Memory into AR4
        MOV     AR5, *XAR7++     ; Increment XAR7; AR5 is discarded
        MOV     SADDR,XAR7       ; Store incremented source address 

        MOV   	XAR7,DADDR       ; Load destination address into XAR7
	PWRITE	*XAR7,AR4        ; Write AR4 contents to Program Memory
        MOV     AR5, *XAR7++     ; Increment XAR7; AR5 is discarded
        MOV     DADDR,XAR7       ; Store incremented destination address 

        SUBB    ACC, #1          ; decrement count and return when zero
        B       $70, NEQ         ; 
$80:
        RET
        .endif

csetjmp/        1146129405  0     0     0       848       `
/*****************************************************************************/
/* csetjmp   v4.1.3                                                          */
/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSETJMP
#define _CSETJMP

#define _CPP_STYLE_HEADER
#include <setjmp.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* _CSETJMP */
cstdarg/        1146129405  0     0     0       849       `
/*****************************************************************************/
/* cstdarg   v4.1.3                                                          */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTDARG
#define _CSTDARG

#define _CPP_STYLE_HEADER
#include <stdarg.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* _CSTDARG */

cstddef/        1146129405  0     0     0       848       `
/*****************************************************************************/
/* cstddef   v4.1.3                                                          */
/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTDDEF
#define _CSTDDEF

#define _CPP_STYLE_HEADER
#include <stddef.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* _CSTDDEF */
cstdio/         1146129405  0     0     0       852       `
/*****************************************************************************/
/* CSTDIO v4.1.3                                                             */
/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _CSTDIO 
#define _CSTDIO

#define _CPP_STYLE_HEADER
#include <stdio.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* #ifndef _CSTDIO */
cstdlib/        1146129405  0     0     0       3586      `
/*****************************************************************************/
/* cstdlib   v4.1.3                                                          */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTDLIB
#define _CSTDLIB

#include <linkage.h>

#define MB_CUR_MAX    1
   
#ifndef NULL
#define NULL          0
#endif
   
#define EXIT_FAILURE  1
#define EXIT_SUCCESS  0
   
#define RAND_MAX      32767
   
namespace std 
{
   typedef struct { int quot, rem; } div_t;
   typedef struct { long quot, rem; } ldiv_t;
   typedef struct { long long quot, rem; } lldiv_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned long size_t;
#endif
   
          /* These functions need C++ linkage */

          int           abs (int i);
          long          labs(long i);
          long          far_calloc  (unsigned long num, unsigned long size);
          long          far_malloc  (unsigned long size);
          long          far_realloc (long ptr, unsigned long size);
          void          far_free    (long ptr);
          long          far_free_memory(void);
	  long          far_max_free(void);
	  long 		far_chkheap(void);

          /* These functions can have C linkage */

extern "C" {
          long          strtol (const char *st, char **endptr, int base);
          unsigned long strtoul(const char *st, char **endptr, int base);
          double        strtod (const char *st, char **endptr);
          long double   strtold (const char *st, char **endptr);
   
          long long          strtoll (const char *st, char **endptr, int base);
          unsigned long long strtoull(const char *st, char **endptr, int base);
   
          int           atoi(const char *st);
          long          atol(const char *st);
 __inline double        atof(const char *st) { return strtod(st, NULL); }

 	  long long     atoll(const char *st);
   
          int           rand (void);
          void          srand(unsigned seed);
   
          void         *calloc  (size_t num, size_t size);
          void         *malloc  (size_t size);
          void         *realloc (void *ptr, size_t size);
          void          free    (void *ptr);
          int           free_memory(void);
	  int           max_free(void);
	  void         *chkheap(void);
          void         *memalign(size_t aln, size_t size);
   
          void          abort  (void); 
          int           atexit (void (*func)(void));
          void         *bsearch(const void *key, const void *base, 
				size_t nmemb, size_t size,
				int (*compar)(const void *,const void *));
          void          qsort  (void *base, size_t nmemb, size_t size, 
				int (*compar)(const void *, const void *));
          void          exit   (int status);
   
          div_t         div (int numer, int denom);
          ldiv_t        ldiv(long numer, long denom);

	  lldiv_t	lldiv(long long numer, long long denom);
   
          char         *getenv(const char *string);
          int           system(const char *name);
}
}

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif

#endif
cstring/        1146129405  0     0     0       849       `
/*****************************************************************************/
/* cstring   v4.1.3                                                          */
/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTRING
#define _CSTRING

#define _CPP_STYLE_HEADER
#include <string.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* _CSTRING */

ctime/          1146129405  0     0     0       849       `
/*****************************************************************************/
/* ctime     v4.1.3                                                          */
/* Copyright (c) 1999-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CTIME
#define _CTIME

#define _CPP_STYLE_HEADER
#include <time.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* #ifndef _CTIME */

ctime_.c/       1146129405  0     0     0       377       `
/****************************************************************************/
/*  ctime   v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _CTIME_

#include <time.h>

ctype.c/        1146129405  0     0     0       7661      `
/****************************************************************************/
/*  ctype.c v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <ctype.h>

/****************************************************************************/
/*  DECLARATION OF CHARACTER TYPING LOOKUP TABLE                            */
/****************************************************************************/
_DATA_ACCESS const unsigned char _ctypes_[] = {
                     /*  -1   EOF   */      0,
                     /* 0x00  NUL   */     _C_,
                     /* 0x01  SOH   */     _C_,
                     /* 0x02  STX   */     _C_,
                     /* 0x03  ETX   */     _C_,
                     /* 0x04  EOT   */     _C_,
                     /* 0x05  ENQ   */     _C_,
                     /* 0x06  ACK   */     _C_,
                     /* 0x07  BEL   */     _C_,
                     /* 0x08  BS    */     _C_,
                     /* 0x09  HT    */     _C_ | _S_,
                     /* 0x0A  LF    */     _C_ | _S_,
                     /* 0x0B  VT    */     _C_ | _S_,
                     /* 0x0C  FF    */     _C_ | _S_,
                     /* 0x0D  CR    */     _C_ | _S_,
                     /* 0x0E  SO    */     _C_,
                     /* 0x0F  SI    */     _C_,

                     /* 0x10  DLE   */     _C_,
                     /* 0x11  DC1   */     _C_,
                     /* 0x12  DC2   */     _C_,
                     /* 0x13  DC3   */     _C_,
                     /* 0x14  DC4   */     _C_,
                     /* 0x15  NAK   */     _C_,
                     /* 0x16  SYN   */     _C_,
                     /* 0x17  ETB   */     _C_,
                     /* 0x18  CAN   */     _C_,
                     /* 0x19  EM    */     _C_,
                     /* 0x1A  SUB   */     _C_,
                     /* 0x1B  ESC   */     _C_,
                     /* 0x1C  FS    */     _C_,
                     /* 0x1D  GS    */     _C_,
                     /* 0x1E  RS    */     _C_,
                     /* 0x1F  US    */     _C_,

                     /* 0x20  ' '   */     _S_ | _B_,
                     /* 0x21  '!'   */     _P_,
                     /* 0x22  '"'   */     _P_,
                     /* 0x23  '#'   */     _P_,
                     /* 0x24  '$'   */     _P_,
                     /* 0x25  '%'   */     _P_,
                     /* 0x26  '&'   */     _P_,
                     /* 0x27  '''   */     _P_,
                     /* 0x28  '('   */     _P_,
                     /* 0x29  ')'   */     _P_,
                     /* 0x2A  '*'   */     _P_,
                     /* 0x2B  '+'   */     _P_,
                     /* 0x2C  ','   */     _P_,
                     /* 0x2D  '-'   */     _P_,
                     /* 0x2E  '.'   */     _P_,
                     /* 0x2F  '/'   */     _P_,

                     /* 0x30  '0'   */     _N_ | _H_,
                     /* 0x31  '1'   */     _N_ | _H_,
                     /* 0x32  '2'   */     _N_ | _H_,
                     /* 0x33  '3'   */     _N_ | _H_,
                     /* 0x34  '4'   */     _N_ | _H_,
                     /* 0x35  '5'   */     _N_ | _H_,
                     /* 0x36  '6'   */     _N_ | _H_,
                     /* 0x37  '7'   */     _N_ | _H_,
                     /* 0x38  '8'   */     _N_ | _H_,
                     /* 0x39  '9'   */     _N_ | _H_,
                     /* 0x3A  ':'   */     _P_,
                     /* 0x3B  ';'   */     _P_,
                     /* 0x3C  '<'   */     _P_,
                     /* 0x3D  '='   */     _P_,
                     /* 0x3E  '>'   */     _P_,
                     /* 0x3F  '?'   */     _P_,

                     /* 0x40  '@'   */     _P_,
                     /* 0x41  'A'   */     _U_ | _H_,
                     /* 0x42  'B'   */     _U_ | _H_,
                     /* 0x43  'C'   */     _U_ | _H_,
                     /* 0x44  'D'   */     _U_ | _H_,
                     /* 0x45  'E'   */     _U_ | _H_,
                     /* 0x46  'F'   */     _U_ | _H_,
                     /* 0x47  'G'   */     _U_,
                     /* 0x48  'H'   */     _U_,
                     /* 0x49  'I'   */     _U_,
                     /* 0x4A  'J'   */     _U_,
                     /* 0x4B  'K'   */     _U_,
                     /* 0x4C  'L'   */     _U_,
                     /* 0x4D  'M'   */     _U_,
                     /* 0x4E  'N'   */     _U_,
                     /* 0x4F  'O'   */     _U_,

                     /* 0x50  'P'   */     _U_,
                     /* 0x51  'Q'   */     _U_,
                     /* 0x52  'R'   */     _U_,
                     /* 0x53  'S'   */     _U_,
                     /* 0x54  'T'   */     _U_,
                     /* 0x55  'U'   */     _U_,
                     /* 0x56  'V'   */     _U_,
                     /* 0x57  'W'   */     _U_,
                     /* 0x58  'X'   */     _U_,
                     /* 0x59  'Y'   */     _U_,
                     /* 0x5A  'Z'   */     _U_,
                     /* 0x5B  '['   */     _P_,
                     /* 0x5C  '\'   */     _P_,
                     /* 0x5D  ']'   */     _P_,
                     /* 0x5E  '^'   */     _P_,
                     /* 0x5F  '_'   */     _P_,

                     /* 0x60  '`'   */     _P_,
                     /* 0x61  'a'   */     _L_ | _H_,
                     /* 0x62  'b'   */     _L_ | _H_,
                     /* 0x63  'c'   */     _L_ | _H_,
                     /* 0x64  'd'   */     _L_ | _H_,
                     /* 0x65  'e'   */     _L_ | _H_,
                     /* 0x66  'f'   */     _L_ | _H_,
                     /* 0x67  'g'   */     _L_,
                     /* 0x68  'h'   */     _L_,
                     /* 0x69  'i'   */     _L_,
                     /* 0x6A  'j'   */     _L_,
                     /* 0x6B  'k'   */     _L_,
                     /* 0x6C  'l'   */     _L_,
                     /* 0x6D  'm'   */     _L_,
                     /* 0x6E  'n'   */     _L_,
                     /* 0x6F  'o'   */     _L_,

                     /* 0x70  'p'   */     _L_,
                     /* 0x71  'q'   */     _L_,
                     /* 0x72  'r'   */     _L_,
                     /* 0x73  's'   */     _L_,
                     /* 0x74  't'   */     _L_,
                     /* 0x75  'u'   */     _L_,
                     /* 0x76  'v'   */     _L_,
                     /* 0x77  'w'   */     _L_,
                     /* 0x78  'x'   */     _L_,
                     /* 0x79  'y'   */     _L_,
                     /* 0x7A  'z'   */     _L_,
                     /* 0x7B  '{'   */     _P_,
                     /* 0x7C  '|'   */     _P_,
                     /* 0x7D  '}'   */     _P_,
                     /* 0x7E  '~'   */     _P_,
                     /* 0x7F  DEL   */     _C_,

		     /* 0x80-0x8F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0x90-0x9F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xA0-0xAF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xB0-0xBF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xC0-0xCF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xD0-0xDF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xE0-0xEF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xF0-0xFF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  };

ctype.h/        1146129405  0     0     0       6490      `
/*****************************************************************************/
/* ctype.h    v4.1.3                                                         */
/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CTYPE
#define _CTYPE

#include <linkage.h>

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cctype> IS RECOMMENDED OVER <ctype.h>.  <ctype.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std
{
#endif /* __cplusplus */

extern _DATA_ACCESS const unsigned char _ctypes_[];

/************************************************************************/
/*   FUNCTION DECLARATIONS                                              */
/************************************************************************/
_IDECL int isalnum(int _c);
_IDECL int isalpha(int _c);
_IDECL int iscntrl(int _c);
_IDECL int isdigit(int _c);
_IDECL int isgraph(int _c);
_IDECL int islower(int _c);
_IDECL int isprint(int _c);
_IDECL int ispunct(int _c);
_IDECL int isspace(int _c);
_IDECL int isupper(int _c);
_IDECL int isxdigit(int _c);
_IDECL int isascii(int _c);

_IDECL int toupper(int _c);
_IDECL int tolower(int _c);
_IDECL int toascii(int _c);

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::_ctypes_;
using std::isalnum;
using std::isalpha;
using std::iscntrl;
using std::isdigit;
using std::isgraph;
using std::islower;
using std::isprint;
using std::ispunct;
using std::isspace;
using std::isupper;
using std::isxdigit;
using std::isascii;
using std::toupper;
using std::tolower;
using std::toascii;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

/************************************************************************/
/*  MACRO DEFINITIONS                                                   */
/************************************************************************/
#define _U_   0x01
#define _L_   0x02
#define _N_   0x04
#define _S_   0x08
#define _P_   0x10
#define _C_   0x20
#define _H_   0x40
#define _B_   0x80

#define _isalnum(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_))
#define _isalpha(a)  (_ctypes_[(a)+1] & (_U_ | _L_))
#define _iscntrl(a)  (_ctypes_[(a)+1] & _C_)
#define _isdigit(a)  (_ctypes_[(a)+1] & _N_)
#define _isgraph(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_ | _P_))
#define _islower(a)  (_ctypes_[(a)+1] & _L_)
#define _isprint(a)  (_ctypes_[(a)+1] & (_B_ | _U_ | _L_ | _N_ | _P_))
#define _ispunct(a)  (_ctypes_[(a)+1] & _P_)
#define _isspace(a)  (_ctypes_[(a)+1] & _S_)
#define _isupper(a)  (_ctypes_[(a)+1] & _U_)
#define _isxdigit(a) (_ctypes_[(a)+1] & _H_)
#define _isascii(a)  (((a) & ~0x7F) == 0)

#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))
#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))
#define _toascii(a)  ((a) & 0x7F)

#ifdef _INLINE

#ifdef __cplusplus
using std::_ctypes_;
namespace std {
#endif /* __cplusplus */

static __inline int isalnum(int c)  { return(_isalnum(c)); }
static __inline int isalpha(int c)  { return(_isalpha(c)); }
static __inline int isascii(int c)  { return(_isascii(c)); }
static __inline int iscntrl(int c)  { return(_iscntrl(c)); }
static __inline int isdigit(int c)  { return(_isdigit(c)); }
static __inline int isgraph(int c)  { return(_isgraph(c)); }
static __inline int islower(int c)  { return(_islower(c)); }
static __inline int isprint(int c)  { return(_isprint(c)); }
static __inline int ispunct(int c)  { return(_ispunct(c)); }
static __inline int isspace(int c)  { return(_isspace(c)); }
static __inline int isupper(int c)  { return(_isupper(c)); }
static __inline int isxdigit(int c) { return(_isxdigit(c));}
static __inline int toascii(int c)  { return(_toascii(c)); }

/****************************************************************************/
/*  tolower                                                                 */
/****************************************************************************/
static __inline int tolower(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'A') <= (unsigned int)('Z' - 'A')) ch += 'a' - 'A';
   return ch;
}

/****************************************************************************/
/*  toupper                                                                 */
/****************************************************************************/
static __inline int toupper(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'a') <= (unsigned int)('z' - 'a')) ch -= 'a' - 'A';
   return ch;
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _INLINE */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::_ctypes_;
using std::isalnum;
using std::isalpha;
using std::iscntrl;
using std::isdigit;
using std::isgraph;
using std::islower;
using std::isprint;
using std::ispunct;
using std::isspace;
using std::isupper;
using std::isxdigit;
using std::isascii;
using std::toupper;
using std::tolower;
using std::toascii;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* ! _CTYPE */
cxxabi.h/       1146129406  0     0     0       6329      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*
cxxabi.h -- Include file for IA-64 ABI entry points.
*/

#ifndef __CXXABI_H
#define __CXXABI_H

#ifndef __STDDEF_H
#include <stddef.h>
#endif  /* ifndef __STDDEF_H */
#include <typeinfo>

#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace __cxxabiv1 {
  using namespace std;
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

  /* type_info implementation classes */

#pragma define_type_info
  class __fundamental_type_info : public type_info {
  public:
    virtual ~__fundamental_type_info();
  };

#pragma define_type_info
  class __array_type_info : public type_info {
  public:
    virtual ~__array_type_info();
  };

#pragma define_type_info
  class __function_type_info : public type_info {
  public:
    virtual ~__function_type_info();
  };

#pragma define_type_info
  class __enum_type_info : public type_info {
  public:
    virtual ~__enum_type_info();
  };

#pragma define_type_info
  class __class_type_info : public type_info {
  public:
    virtual ~__class_type_info();
  };

#pragma define_type_info
  class __si_class_type_info : public __class_type_info {
  public:
    virtual ~__si_class_type_info();
    const __class_type_info *__base_type;
  };

  struct __base_class_type_info {
    const __class_type_info *__base_type;
    long __offset_flags;

    enum __offset_flags_masks {
      __virtual_mask = 0x1,
      __public_mask = 0x2,
      __offset_shift = 8
    };
  };

#pragma define_type_info
  class __vmi_class_type_info : public __class_type_info {
  public:
    virtual ~__vmi_class_type_info();
    unsigned int __flags;
    unsigned int __base_count;
    __base_class_type_info __base_info[1];

    enum __flags_masks {
      __non_diamond_repeat_mask = 0x1,
      __diamond_shaped_mask = 0x2
    };
  };

#pragma define_type_info
  class __pbase_type_info : public type_info {
  public:
    virtual ~__pbase_type_info();
    unsigned int __flags;
    const type_info *__pointee;
    
    enum __masks {
      __const_mask = 0x1,
      __volatile_mask = 0x2,
      __restrict_mask = 0x4,
      __incomplete_mask = 0x8,
      __incomplete_class_mask = 0x10
    };
  }; 

#pragma define_type_info
  class __pointer_type_info : public __pbase_type_info {
    virtual ~__pointer_type_info();
  };

#pragma define_type_info
  class __pointer_to_member_type_info : public __pbase_type_info {
    virtual ~__pointer_to_member_type_info();
    const __class_type_info *__context;
  };

  extern "C" {
    /* Pure virtual function calls. */
    void __cxa_pure_virtual();
  
    /* Guard variables for the initialization of variables with static storage
       duration. */
    int __cxa_guard_acquire(unsigned long long *);
    void __cxa_guard_release(unsigned long long *);
    void __cxa_guard_abort(unsigned long long *);

    /* Construction and destruction of arrays. */
    void *__cxa_vec_new(size_t, size_t, size_t, void (*)(void *),
                        void (*)(void *));
    void *__cxa_vec_new2(size_t, size_t, size_t, void (*)(void *),
                         void (*)(void *), void *(*)(size_t),
                         void (*)(void *));
    void *__cxa_vec_new3(size_t, size_t, size_t, void (*)(void *),
                         void (*)(void *), void *(*)(size_t),
                         void (*)(void *, size_t));
    void __cxa_vec_ctor(void *, size_t, size_t, void (*)(void *),
                        void (*)(void *));
    void __cxa_vec_dtor(void *, size_t, size_t, void (*)(void *));
    void __cxa_vec_cleanup(void *, size_t, size_t, void (*)(void *));
    void __cxa_vec_delete(void *, size_t, size_t, void (*)(void *));
    void __cxa_vec_delete2(void *, size_t, size_t, void (*)(void *),
                           void (*)(void *));
    void __cxa_vec_delete3(void *, size_t, size_t, void (*)(void *),
                           void (*)(void *, size_t));
    void __cxa_vec_cctor(void *, void *, size_t, size_t, 
                         void (*)(void *, void *), void (*)(void *));

    /* Finalization. */
    int __cxa_atexit(void (*)(void *), void *, void *);
    void __cxa_finalize(void *);

/*** START TI ADD ***/
    void __cxa_ia64_exit(int status);
/*** END TI ADD ***/

    /* Exception-handling support. */
    void __cxa_bad_cast();
    void __cxa_bad_typeid();

    /* Demangling interface. */
    char *__cxa_demangle(const char* __mangled_name,
                         char        *__buf,
                         size_t      *__n,
                         int         *__status);

  }  /* extern "C" */
#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace __cxxabiv1 */

/* Create the "abi" namespace alias. */
namespace abi = __cxxabiv1;
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

#endif /* ifndef __CXXABI_H */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

defines.h/      1146129406  0     0     0       2367      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C Front End                            - | \^/ | -      *
*                                                               \   /         *
* Proprietary information of Edison Design Group Inc.         /  | |  \       *
* Copyright 1988-1995 Edison Design Group Inc.                   [_]          *
*                                                                             *
******************************************************************************/
/*

defines.h -- Defines configuration parameters for a given version of the
             runtime library.

*/

/*** START TI ADD ***/
/*---------------------------------------------------------------------------*/
/* Redefine the EDG names for vector new/delete RTS routines from the        */
/* EDG names to the TI names (generated by the parser)                       */
/*---------------------------------------------------------------------------*/
#define __vec_new              __anew 
#define __vec_new_eh           __anew_eh
#define __vec_delete           __adelete
#define __array_new            __canew
#define __placement_array_new  __pcanew
#define __array_delete         __cadelete
#define __vec_cctor            __acctor
#define __vec_cctor_eh         __acctor_eh

#ifndef __EDG_IA64_ABI
#ifndef __eabi__
#define TI_ARRAY_PREFIX 1
#endif
#endif
/*** END TI ADD ***/
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C Front End                            - | \^/ | -      *
*                                                               \   /         *
* Proprietary information of Edison Design Group Inc.         /  | |  \       *
* Copyright 1988-1995 Edison Design Group Inc.                   [_]          *
*                                                                             *
******************************************************************************/

defs.c/         1146129406  0     0     0       2875      `
/*****************************************************************************/
/*  DEFS.C v4.1.3                                                            */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file defines some data structures declared in stdio.h.            */
/*****************************************************************************/
#include <stdio.h>

/*---------------------------------------------------------------------------*/
/* Define the streams for stdin, stdout, and stderr, and assign them as the  */
/* first three streams in _FTABLE upon its initialization.                   */
/*---------------------------------------------------------------------------*/
_DATA_ACCESS
FILE _ftable[_NFILE] = {{  0, NULL, NULL, NULL, NULL, (_MODER | _IOLBF), 0},
                        {  1, NULL, NULL, NULL, NULL, (_MODEW | _IOLBF), 1},
                        {  2, NULL, NULL, NULL, NULL, (_MODEW | _IONBF), 2},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           3},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           4},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           5},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           6},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           7},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           8},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           9},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           10},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           11},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           12},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           13},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           14},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           15},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           16},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           17},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           18},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           19} };

/*---------------------------------------------------------------------------*/
/* Allocate a table to store the filenames of temporary files, so they can   */
/* be deleted when they are closed.                                          */
/*---------------------------------------------------------------------------*/
_DATA_ACCESS char _tmpnams[_NFILE][L_tmpnam];

/*---------------------------------------------------------------------------*/
/* This global variable _FT_END is used to mark the end of used streams in   */
/* the file table.                                                           */
/*---------------------------------------------------------------------------*/
_DATA_ACCESS int _ft_end = 3; 

delete.cpp/     1146129406  0     0     0       1721      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator delete();

*/

#include "basics.h"
#include "runtime.h"


void operator delete(void *ptr) THROW_NOTHING()
/*
Free the memory pointed to by ptr.
*/
{
  if (ptr != NULL) {
    free(ptr);
  }  /* if */
}  /* operator delete */ 

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

delnothrow.cpp/ 1146129406  0     0     0       1757      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

/*

C++ operator delete();

*/

#include "basics.h"
#include "runtime.h"


void operator delete(void				*ptr,
                     const STD_NAMESPACE::nothrow_t&)
THROW_NOTHING()
/*
Nothrow version of operator delete.
*/
{
  operator delete(ptr);
}  /* operator delete */ 

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/


difftime.c/     1146129406  0     0     0       849       `
/****************************************************************************/
/*  difftime v4.1.3                                                         */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#undef _INLINE
#include <time.h> 

_CODE_ACCESS double difftime(time_t time1, time_t time0)
{
    /*----------------------------------------------------------------------*/
    /* THE FOLLOWING CONVERSION INSURES THAT ANY POSSIBLE DIFFERENCE IN THE */
    /* RANGE OF UNSIGNED LONG IS PROPERLY REPRESENTED IN THE RESULT.        */
    /*----------------------------------------------------------------------*/
    return ((time1 > time0) ?  (double)(time1 - time0)
	                    : -(double)(time0 - time1));
}

div.c/          1146129406  0     0     0       742       `
/****************************************************************************/
/*  div ldiv    v4.1.3                                                      */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

div_t div(int numer, int denom)
{
    div_t result;

    if (denom == 0) return;

    result.quot = numer / denom;
    result.rem  = numer - (result.quot * denom);
    return result;
}

ldiv_t ldiv(long numer, long denom)
{
    ldiv_t result;

    if (denom == 0) return;

    result.quot = numer / denom;
    result.rem  = numer - (result.quot * denom);
    return result;
}

dtor_list.cpp/  1146129406  0     0     0       10624     `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
*                                                               \   /         *
* Proprietary information of Edison Design Group Inc.         /  | |  \       *
* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *
*                                                                             *
******************************************************************************/
/*

dtor_list.c -- destruction list processing.

*/

#include "basics.h"
#include "runtime.h"
#pragma hdrstop
/*** START TI ADD ***/
/* TI implementation of RTS does not need the definition in static_init.h.
TI RTS only needs IA64_ABI part of this file. */
#if 0
/*** END TI ADD ***/ 
#include "static_init.h"
/*** START TI ADD ***/
#endif
/*** END TI ADD ***/ 
#include "dtor_list.h"

#if !defined(__EDG_IA64_ABI) || !SYSTEM_RUNTIME_HAS_IA64_SUPPORT || \
    !SYSTEM_RUNTIME_HAS_IA64_ATEXIT

/*
The list of static objects that require destruction.  An entry is
added to the front of this list each time a new destructible static
object is created.
*/
static a_needed_destruction_ptr
		needed_destruction_head /* = NULL*/;

#endif /* !defined(__EDG_IA64_ABI) || !SYSTEM_RUNTIME_HAS_IA64_SUPPORT
          !SYSTEM_RUNTIME_HAS_IA64_ATEXIT */


#ifndef __EDG_IA64_ABI

void __process_needed_destructions(void)
/*
Go through the needed destructions list and perform the required
destructions.
*/
{
  a_needed_destruction_ptr	ndp;
  while (needed_destruction_head != NULL) {
    void	*object_ptr;
    /* Note that the value of needed_destruction_head may change
       during the execution of the destructor.  Consequently, the
       current entry is removed from the list before the destructor
       routine is called. */
    ndp = needed_destruction_head;
    needed_destruction_head = needed_destruction_head->next;
    object_ptr = ndp->object;
    /* Choose between a simple and complex destruction based on whether
       or not the object pointer is NULL. */
    if (object_ptr != NULL) {
      a_destructor_ptr	dp;
      /* Destroy the object by calling a destructor.  The flag value of 2
         indicates the object should be destroyed, but operator delete
         should not be called. */
      dp = (a_destructor_ptr)ndp->destruction_routine;
      (dp)(object_ptr, 2);
    } else {
      /* Destroy the object by calling a special function that will do the
         destruction of this specific object. */
      (ndp->destruction_routine)();
    }  /* if */
  }  /* while */
}  /* __process_needed_destructions */


EXTERN_C void __already_marked_for_destruction()
/*
This routine is called when a needed destruction is recorded more than
once.  It simply calls abort.  The name is intended to describe the nature
of the problem to the user.
*/
{
  __abort_execution(ec_already_marked_for_destruction);
}


EXTERN_C void __record_needed_destruction(a_needed_destruction_ptr ndp)
/*
Called when a static object has been constructed to register a
destruction that must be done at program termination.  ndp points to
a needed destruction entry that is to be added to the front of the
list of needed destructions.
*/
{
  /* If the entry has already been put on the list, terminate the execution. */
  if (ndp->next != NULL ||
      ndp == needed_destruction_head) __already_marked_for_destruction();
  ndp->next = needed_destruction_head;
  needed_destruction_head = ndp;
}  /* __record_needed_destruction */


#if CFRONT_COMPATIBILITY_MODE
EXTERN_C void __std__needed_destruction_list(void)
/*
This routine is provided for use with a cfront runtime library, including
cfront startup and termination code.  This routine will be called by
the cfront static destruction routines and will ensure that any needed
destructions get done.  The sequence of the destructions will not
be standard conforming, but there is no way to get standard conforming
behavior when using the cfront termination routines.

This routine will only be used when munch is being used.  When patch
is being used, the link structure defined below will result in a call to
__process_needed_destructions.
*/
{
  __process_needed_destructions();
}  /* __std__needed_destruction_list */


/*
Define a link structure that will be used when patch is being used.
*/
struct a_link {
  a_link	*next;
  a_void_function_ptr
		ctor;
  a_void_function_ptr
		dtor;
};

static a_link __link = {(a_link*)NULL,
                        (a_void_function_ptr)NULL,
                        (a_void_function_ptr)__process_needed_destructions};


/*
This declaration is used to force the static definition of __link to be
put out (i.e., to make the compiler think that __link is actually used).
*/
a_link* __dummy_variable_used_to_force_definition_of__link = &__link;
#endif /* CFRONT_COMPATIBILITY_MODE */

#else /* defined(__EDG_IA64_ABI) */

#if !SYSTEM_RUNTIME_HAS_IA64_SUPPORT
/* Current versions of Linux already define these routines in the C runtime
   library, and if we attempt to redefine them here we end up with multiple
   versions of these symbols. */

/* The DSO handle.  Initialization to NULL indicates that this is the handle
   for the main program.  */
a_dso_handle __dso_handle;

#endif /* !SYSTEM_RUNTIME_HAS_IA64_SUPPORT */

#if !SYSTEM_RUNTIME_HAS_IA64_ATEXIT

void ABI_NAMESPACE::__cxa_finalize(a_dso_handle dso_handle)
/*
Go through the needed destructions list and perform the required
destructions for the DSO indicated by dso_handle, or all destructions if
dso_handle is NULL.
*/
{
  a_needed_destruction_ptr *ndpp, ndp, old_head;
  
  ndpp = &needed_destruction_head;
  while (*ndpp != NULL) {
    ndp = *ndpp;
    /* Skip destructions that do not apply to this DSO. */
    if (dso_handle != NULL && ndp->dso_handle != dso_handle) {
      ndpp = &ndp->next;
      continue;
    }  /* if */
    /* Note that the value of needed_destruction_head may change
       during the execution of the destructor.  Consequently, the
       current entry is removed from the list before the destructor
       routine is called. */
    *ndpp = ndp->next;
    old_head = needed_destruction_head;
    /* Call the routine. */
    (*ndp->destruction_routine)(ndp->object);
    /* Deallocate the entry. */
    free(ndp);
    /* If the head has changed, start at the beginning of the list 
       again so that we can process the newly added destruction. */
    if (needed_destruction_head != old_head) {
      ndpp = &needed_destruction_head;
    }  /* if */
  }  /* while */
}  /* __cxa_finalize */


int ABI_NAMESPACE::__cxa_atexit(a_destructor_ptr destruction_routine,
                                void             *object,
                                a_dso_handle     dso_handle)
/* 
Register an action to be taken at program termination (or DSO unload) time.
The action is the calling of destruction_routine with the object parameter.
If dso_handle is non-NULL, the action will be taken when __cxa_finalize
is called for the specific dso_handle value, or when __cxa_finalize
is called to process all objects (i.e., the __cxa_finally dso_handle has
a NULL value).  If dso_handle is NULL, the action will be taken only when
__cxa_finalize is called to process all objects.

This version of __cxa_atexit is only intended to be used when the
system's runtime does not include its own version of __cxa_atexit.  When
the system's runtime includes such a function, the system is responsible
for seeing that __cxa_finalize is invoked at program termination.  When
using our own version of this routine, we need to ensure that __cxa_finalize
is invoked at program termination.  This is accomplished by calling
__register_finalization_routine on the first invocation of this function.
*/
{
  int                      success = TRUE;
  a_needed_destruction_ptr ndp;

  ndp = (a_needed_destruction_ptr)malloc(sizeof(a_needed_destruction));
  if (ndp == NULL) {
    success = FALSE;
  }  else {
/*** START TI ADD ***/
/* Here in IA64_ABI mode, we do not need to register the destructor in
any other place. The ndp below record all the destructors and the 
__cxa_finalize will walk through the list to call the destructors
during exit.

"__register_finalization_routine()" defined in static_init.c in
EDGRTS release calls atexit() to record "__call_dtors" function.
"__call_dtors" is a function in EDGRTS release corresponds to 
"__call_ctors" which is also from EDGRTS release. As TI RTS does not
use "__call_Ctors" to do static initialization, here it is also
unnecessary to call "_call_dtors".

For non IA64_ABI mode, we have our own way to record the destructors,
deatils in __add_dtor() in sinit.c */
extern   void abort(void);
#if 0
/*** END TI ADD ***/
    if (needed_destruction_head == NULL)
	      __register_finalization_routine();
/*** START TI ADD ***/
#endif
/*** END TI ADD ***/
    ndp->object = object;
    ndp->destruction_routine = destruction_routine;
    ndp->dso_handle = dso_handle;
    ndp->next = needed_destruction_head;
    needed_destruction_head = ndp;
  }  /* if */
  return success;
}  /* __cxa_atexit */

/*** START TI REPLACE ***/
#if __EDG_IA64_ABI
void ABI_NAMESPACE::__cxa_ia64_exit(int status)
{
    ABI_NAMESPACE::__cxa_finalize((a_dso_handle)NULL);
}
#endif /* defined(__EDG_IA64_ABI) */
/*** END TI REPLACE ***/

#endif /* !SYSTEM_RUNTIME_HAS_IA64_ATEXIT */

#endif /* defined(__EDG_IA64_ABI) */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
*                                                               \   /         *
* Proprietary information of Edison Design Group Inc.         /  | |  \       *
* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *
*                                                                             *
******************************************************************************/
dtor_list.h/    1146129406  0     0     0       3581      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
*                                                               \   /         *
* Proprietary information of Edison Design Group Inc.         /  | |  \       *
* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *
*                                                                             *
******************************************************************************/
/*

Declarations relating to dtor_list.c -- destruction list processing.

*/

#ifndef DTOR_LIST_H
#define DTOR_LIST_H 1
/*** START TI ADD ***/
/* TI implementation of RTS does not need the definition in main.h 
TI RTS only needs IA64_ABI part of this file. */
#if 0
/*** END TI ADD ***/ 
#ifndef MAIN_H
#include "main.h"
#endif /* ifndef MAIN_H */
/*** START TI ADD ***/
#endif
/*** END TI ADD ***/ 
/*
Data structure used to build a list of static object destructions
to be performed at the end of execution.  Entries are added to the
list each time a static object is created.  New objects are added
to the front of the list.
*/
typedef struct a_needed_destruction *a_needed_destruction_ptr;
typedef struct a_needed_destruction {
  a_needed_destruction_ptr
		next;
			/* Pointer to the next entry in the list. */
  void		*object;
			/* Pointer to the object to be destroyed if this
			   is a "simple" destruction, or a NULL pointer
		 	   if this is a "complex" destruction.  A simple
			   destruction is one that can be done with
			   a single call to the destructor passing an
			   object pointer and a destruction flag. */
#ifndef __EDG_IA64_ABI
  a_void_function_ptr
#else /* defined(__EDG_IA64_ABI) */
  a_destructor_ptr
#endif /* defined(__EDG_IA64_ABI) */
		destruction_routine;
			/* For a simple destruction, this points to the
			   destructor to be called. For a complex destruction,
                           this is a pointer to a function that when called,
                           will call the necessary destructors. */
#ifdef __EDG_IA64_ABI
  a_dso_handle  dso_handle;
                        /* The DSO handle associated with this destruction, or
                           NULL if this destruction is associated with the
                           main program. */
#endif /* ifdef EDG_IA64_ABI */
} a_needed_destruction;

#ifndef __EDG_IA64_ABI
extern void __process_needed_destructions(void);

EXTERN_C void __record_needed_destruction(a_needed_destruction_ptr ndp);
#endif /* ifndef __EDG_IA64_ABI */

#endif /* DTOR_LIST_H */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
*                                                               \   /         *
* Proprietary information of Edison Design Group Inc.         /  | |  \       *
* Copyright 1992-1994 Edison Design Group Inc.                   [_]          *
*                                                                             *
******************************************************************************/

ecvt.c/         1146129406  0     0     0       3225      `
/****************************************************************************/
/*  ecvt v4.1.3                                                             */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <math.h>

#define MANTISSA_WORD 0
#define EXPONENT_WORD 1

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */
/* FOR PRINTF.                                                              */
/****************************************************************************/
char *ecvt(long double value, register int ndigit, int *decpt, int *sign)
{
    static char out[100]; 

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VALL OF PROPER SIGN     */
    /*--------------------------------------------------------------------*/
    {
       long *ptr = (long *)&value;

       if (((ptr[EXPONENT_WORD] >> 20) & 0x7ff) == 0x7ff)
          value = (ptr[EXPONENT_WORD] & 0x80000000) ? -HUGE_VALL : HUGE_VALL;
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos    += temp = ltoa((long)value, pos);
    *decpt  = digits + temp;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (temp >= ndigit) 
	pos = out + ndigit + 1;
    else if ((ndigit -= temp) > 0) do
    {
        value -= (long)value;
        *pos++ = (int)(value *= 10.0) + '0';
    } 
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) { *--pos = 0; *decpt += 1; return out; }
    }
	
    *pos = 0;
    return out + 1;
}


eh.h/           1146129406  0     0     0       16216     `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Declarations for exception handling.

*/

#ifndef _EH_H
#define _EH_H 1

#include <stdlib.h>
#include "runtime.h"
#include <exception>
#include "rtti.h"
#include "vec_newdel.h"

#if EXCEPTION_HANDLING

#ifndef NULL
#define NULL (0)
#endif /* NULL */

#include <setjmp.h>

typedef long an_element_count;
			/* Type used to represent a count of the number of
			   elements in an array.  Must be signed because
			   -1 is used to represent an array whose size is
			   only known at run time. */

typedef int	a_conditional_flag;
			/* Type of a flag used for conditional region
			   entries. */

typedef __EDG_VAR_HANDLE_TYPE an_object_handle;
			/* An offset into the object address array. */

typedef void *an_object_ptr;
			/* An address of an object. */

typedef __EDG_REGION_NUMBER_TYPE a_region_number;
			/* Type used to represent a region number.
			   Must be an unsigned type. */

/* Definitions of the values in the flags field of the region description
   entry. */
typedef a_byte a_region_descr_flag_set;
#define RDF_NO_FLAGS		0x0
			/* Value used when no flags are set. */
#define RDF_INDIRECT		0x01
			/* TRUE if the address provided by handle
			   is a pointer to the object. */
#define RDF_CONDITIONAL_FLAG	0x02
			/* TRUE if the object is conditionally constructed.
			   When this flag is TRUE the next entry on the list
			   contains a handle that can be used to get the
			   address of the flag that indicates whether the
			   object has been constructed.  When this flag is
			   set the value of the conditional flag (pointed
			   to by the handle in the region entry) should be
			   tested before trying to make use of the handle
			   in the next region entry. */
#define RDF_NEW_ALLOCATION	0x04
			/* TRUE if the object was allocated by new and
			   is to be freed in the event of a throw. */
#define RDF_ARRAY		0x08
			/* TRUE if the complete object information can
			   be found in the array supplement.  This is used
			   for arrays and for new allocations that require
			   a two-argument operator delete call. */
#define RDF_THIS_PARAM_OFFSET	0x10
			/* TRUE if the object is at an address relative to
			   the "this" parameter of the current routine, i.e.,
			   it's a base class or member being handled in
			   a constructor or destructor.  Not used in the
			   portable scheme. */
#define RDF_SUBOBJECT_VTABLE		0x20
			/* When RDF_BASE_CLASS_SUBOBJECT is TRUE, this
			   flag indicates that a region entry following this
			   one gives the address of the subobject virtual
			   function table table to be used when calling the
			   destructor.  If there is also an extra entry for a
			   conditional flag, the subobject vtable entry
			   follows the flag entry.  Note that this uses the
			   same bit as RDF_LET_THIS. */

#if 0
/*
This flag is used by the Kuck & Associates inliner when not doing
full portable EH lowering.  This flag is not used by the EDG supplied
runtime.  Also, the DO_FULL_PORTABLE_EH_LOWERING and USING_KAI_INLINER
flags are defined in the front end, but are not defined in the runtime
config.h file.
*/
#if !DO_FULL_PORTABLE_EH_LOWERING && USING_KAI_INLINER
#define RDF_LET_THIS            0x20
                        /* TRUE if address computed should be used as a 
                           "formal this" parameter.  The region entry
                           following this one describes what to do
                           with the "formal this" pointer.  The
                           following entry will have the
                           RDF_THIS_PARAM_OFFSET flag set, and
                           possibly the RDF_LET_THIS flag set.
                           Chained RDF_LET_THIS entries allow object
                           addresses to be specified when multiple
                           (indirection+offset) operations are
                           necessary to reach the object from a
                           stack-local variable or the "actual this".
                           More detailed information on RDF_LET_THIS
                           is available from KAI.  Note that this uses
			   the same bit as RDF_SUBOBJECT_VTABLE. */
#endif /* !DO_FULL_PORTABLE_EH_LOWERING && USING_KAI_INLINER */
#endif /* 0 */

#define RDF_BASE_CLASS_SUBOBJECT	0x40
			/* TRUE if the object is a base class of some other
			   object and therefore is not a complete object. */
#define RDF_GUARD_VAR_FOR_LOCAL_STATIC	0x80
			/* TRUE if the object is the guard variable associated
			   with the initialization of a local static variable.
			   The cleanup action is to set the variable back to
			   zero. */

#define NULL_REGION_NUMBER ((a_region_number)__EDG_NULL_EH_REGION_NUMBER)
			/* The value used when there is no active EH
			   region.  Also the value used as the next
			   region number when there is no next region. */


/* Supplement to a region description entry for array entries and for
   entries for new allocations that must be deleted using the
   two-argument form of operator delete. */
typedef struct an_eh_array_supplement *an_eh_array_supplement_ptr;
typedef struct an_eh_array_supplement {
  an_object_handle
		handle;
			/* Offset in stack from or index into
			   the object address array. */
  a_sizeof_t	element_size;
			/* Size of each element in the array. */
  an_element_count	array_size;
			/* Number of elements in an array.  -1 if the
			   size is not known at compile time.  Zero for
			   objects that are not arrays but that must be
			   deleted using the two-argument operator
			   delete. */
} an_eh_array_supplement;


/* Structure that describes a single destructable object. */
typedef struct an_eh_region_descr *an_eh_region_descr_ptr;
typedef struct an_eh_region_descr {
  a_void_function_ptr
		destructor_or_delete_routine;
			/* When new_allocation is FALSE this points to
			   the destructor for the object.  When
			   new_allocation is TRUE this points to the
			   delete operator for the object. */
  an_object_handle
		handle;
			/* Offset in stack from or index into
			   the object address array. When RDF_ARRAY is
			   set the handle contains the index into the
			   array supplement.  When
			   RDF_THIS_PARAM_OFFSET is set the handle
			   contains an offset to be added to the this
			   parameter to get the address of a base
			   class. */
  a_region_number
	        index_of_next_region;
			/* Index of the region description of the
			   next region.  This region will be
			   processed after the processing for this
			   region has been completed. */
  a_region_descr_flag_set
		flags;
			/* A collection of bits that specify how the
			   region entry is to be used.  See the
			   descriptions of the RDF flags above. */
} an_eh_region_descr;


/* Definitions of the values in the flags field of the exception type
   specification entry. */
typedef a_byte an_ETS_flag_set;
#define ETS_NO_FLAGS		0x0
			/* Value used when no flags are set. */
#define ETS_IS_POINTER		0x01
			/* A pointer to an object of the type specified
			   by type_info is being caught. */
#define ETS_CONST		0x02
#define ETS_VOLATILE		0x04
			/* Indication of the type qualifiers on the type
			   pointed to, in the pointer case. */
#define ETS_IS_REFERENCE	0x08
			/* A reference to an object of the type specified
			   by type_info is being caught. */
#define ETS_IS_ELLIPSIS		0x10
			/* The catch clause contains an ellipsis. */
#define ETS_LAST		0x20
			/* TRUE if this is the last catch clause associated
			   with a given try block (i.e., there are no more
			   entries in the array.) */
/*** START TI ADD ***/
#define ETS_IS_FUNC_POINTER     0x40
                        /* TRUE if the catch clause is a pointer to 
			   function  */
/*** END TI ADD ***/
#define ETS_QUALIFIERS	(ETS_CONST | ETS_VOLATILE)
			/* The flags bits that comprise the type qualifiers
			   that must be checked to determine a match. */

/* Macros used for checking ETS flags. */
/* The pointer flags are not used prior to the 2.41 ABI. */
#if ABI_COMPATIBILITY_VERSION >= 241
#define is_pointer(flag, ptr_flags)  ((flag & ETS_IS_POINTER) != 0 ||	\
                                      ptr_flags != NULL)
/*** START TI ADD ***/ 
#define is_pointer_to_func(flag, ptr_flags)  ((flag & ETS_IS_FUNC_POINTER) != 0 ||	\
                                      ptr_flags != NULL)
/*** END TI ADD ***/
#else /* !(ABI_COMPATIBILITY_VERSION >= 241) */
#define is_pointer(flag, ptr_flags)  ((flag & ETS_IS_POINTER) != 0)
#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

/* is_single_level_pointer returns TRUE only if the pointer bit is set in
   the primary flags field, and does not consider the ptr_flags. */
#define is_single_level_pointer(flag)					\
  is_pointer(flag, NULL)

#define is_const(flag)               ((flag & ETS_CONST) != 0)
#define is_volatile(flag)            ((flag & ETS_VOLATILE) != 0)
#define is_reference(flag)           ((flag & ETS_IS_REFERENCE) != 0)
#define is_ellipsis(flag)            ((flag & ETS_IS_ELLIPSIS) != 0)
#define is_last(flag)                ((flag & ETS_LAST) != 0)

/* Return the qualifiers from a flag entry. */
#define get_qualifiers(flag)         (flag & ETS_QUALIFIERS)


/* Exception type specifications are used to describe throw specifications
   for functions and are also used to describe the list of types used in
   the catch clauses associated with a given try block. */
typedef struct an_exception_type_specification
		*an_exception_type_specification_ptr;
typedef struct an_exception_type_specification {
  a_type_info_impl_ptr
		type_info;
			/* Pointer to the type information for the entry.
			   NULL if the entry has no associated type (for
			   ellipsis entries or for empty throw specification
			   lists). */
  an_ETS_flag_set
		flags;
			/* A collection of bits that specify how the
			   catch entry is to be used.  See the
			   descriptions of the ETS flags above. */
#if ABI_COMPATIBILITY_VERSION >= 241
  an_ETS_flag_set
		*ptr_flags;
			/* Present for types that have more than one level
			   of pointer.  Points to an array of flags, terminated
			   by an entry with the ETS_LAST bit set.  This
			   information is used to do qualification conversions
			   on multi-level pointers. */
#endif /* ABI_COMPATIBILITY_VERSION >= 241 */
} an_exception_type_specification;


/* The kinds of stack entries that may exist. */
enum an_eh_stack_entry_kind_tag {
  ehsek_try_block,
  ehsek_function,
  ehsek_throw_spec,
  ehsek_throw_processing_marker,
  ehsek_vec_new_or_delete
};

typedef a_byte an_eh_stack_entry_kind;

typedef struct an_eh_stack_entry *an_eh_stack_entry_ptr;
typedef struct an_eh_stack_entry {
  an_eh_stack_entry_ptr
		next;
			/* The next stack entry. */
  an_eh_stack_entry_kind
		kind;
			/* The kind of stack entry. */
  union {
    /* When kind == ehsek_try_block. */
    struct {
#if USE_SYSTEM_JMP_BUF_DEFINITION
      jmp_buf	setjmp_buffer;
			/* Buffer used by setjmp to save state information.
			   The jmp_buf type is defined in setjmp.h. */
#else /* !USE_SYSTEM_JMP_BUF_DEFINITION */
      __EDG_JMP_BUF_ELEMENT_TYPE
                setjmp_buffer[__EDG_JMP_BUF_NUM_ELEMENTS];
			/* Buffer used by setjmp to save state
			   information.  The element type and size are
			   passed from the front end using predefined
			   macros. */
#endif /* USE_SYSTEM_JMP_BUF_DEFINITION */
      an_exception_type_specification_ptr
		catch_entries;
			/* Pointer to an array of entries that describe the
			   types that can be caught. */
      void*	catch_info;
			/* Pointer to catch information maintained by the
			   runtime system.  Initialized to NULL by the
			   code generated by the compiler. */
      a_region_number
		region_number;
			/* EH region number upon entry to the try block.
			   Used to clean up objects declared in the try
			   block. */
    } try_block;

    /* When kind == ehsek_function. */
    struct {
      an_eh_region_descr
		*regions;
			/* Pointer to an array of region
			   descriptions. */
      an_object_ptr
		*object_address_table;
			/* Pointer to an array of object addresses. */
      an_eh_array_supplement
		*array_table;
			/* Pointer to an array of array description
			   entries. */
      a_region_number
		saved_region_number;
			/* Previous value of eh_curr_region saved on
			   entry to this function. */
    } function;
    /* When kind == ehsek_throw_spec. */
    an_exception_type_specification_ptr
		throw_specification;
			/* Pointer to an array of entries that specify the
			   types that can be thrown. */
    /* When kind == ehsek_vec_new_or_delete. */
    an_array_alloc_eh_info_ptr
		array_alloc_eh_info;
			/* Pointer to a structure used to handle exceptions
			   that occur while processing an array new or delete
			   operation. */
  } variant;
} an_eh_stack_entry;


EXTERN a_region_number
		__eh_curr_region initial_value(0);
			/* Number of the current region in topmost function
			   entry on the EH stack. */

EXTERN an_eh_stack_entry_ptr
		__curr_eh_stack_entry initial_value(NULL);
			/* The pointer to the top of the stack of EH
			   entries. */
EXTERN int	__catch_clause_number;
			/* Contains the sequence number of the catch clause
			   associated with a given try block. */

EXTERN void*	__caught_object_address;
			/* The address of the object to be used as the value
			   of the parameter in the catch clause. */

EXTERN_C void __call_terminate(void);
EXTERN_C void __default_terminate(void);

EXTERN a_void_function_ptr
		__default_terminate_routine
                       initial_value((a_void_function_ptr)__default_terminate);
			/* Pointer to the terminate routine to be used. */

EXTERN_C void __call_unexpected(void);

EXTERN a_void_function_ptr
		__default_unexpected_routine
                                       initial_value(STD_NAMESPACE::terminate);
			/* Pointer to the unexpected routine to be used. */

EXTERN_C void __cleanup_vec_new_or_delete(an_eh_stack_entry_ptr ehsep);

EXTERN_C void __eh_exit_processing(void);

EXTERN_C void __type_of_thrown_object(a_type_info_impl_ptr	*type,
				      an_ETS_flag_set		*flags,
				      an_ETS_flag_set		**ptr_flags);

EXTERN_C a_boolean __can_throw_type(a_type_info_impl_ptr	type,
				    an_ETS_flag_set		flags,
				    an_ETS_flag_set		*ptr_flags);


EXTERN_C an_eh_stack_entry_ptr __get_curr_eh_stack_entry(void);

#endif /* EXCEPTION_HANDLING */

#endif /* ifndef _EH_H */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
eh_util.cpp/    1146129406  0     0     0       6950      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ functions to support exception handling.

*/

#include "basics.h"
#include "runtime.h"
#include "eh.h"

#if EXCEPTION_HANDLING
static a_boolean
		terminate_called = FALSE;
			/* Set to TRUE when terminate() is called by the
			   EH runtime.  This is used by uncaught_exception()
			   to determine whether terminate() has been called. */

/*
If the runtime should be defined in the std namespace, open
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace std {
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */


void terminate()
/*
The default terminate routine.
*/
{
  if (__default_terminate_routine != NULL) __default_terminate_routine();
  __abort_execution(ec_terminate_returned);
}  /* terminate */


EXTERN_C void __default_terminate(void)
/*
The default terminate routine, which is just a wrapup around abort().
*/
{
  __abort_execution(ec_terminate_called);
}  /* __default_terminate */


a_void_function_ptr set_terminate(a_void_function_ptr new_func) THROW_NOTHING()
/*
Set the terminate routine pointer to the value passed by the caller
and return the old value.
*/
{
  a_void_function_ptr	old_func = __default_terminate_routine;
  __default_terminate_routine = new_func;
  return old_func;
}  /* set_terminate */


void unexpected()
/*
The default unexpected routine.  This routine calls terminate.
*/
{
  if (__default_unexpected_routine != NULL) __default_unexpected_routine();
  terminate();
}  /* unexpected */


a_void_function_ptr set_unexpected(a_void_function_ptr new_func)
THROW_NOTHING()
/*
Set the unexpected routine pointer to the value passed by the caller
and return the old value.
*/
{
  a_void_function_ptr	old_func = __default_unexpected_routine;
  __default_unexpected_routine = new_func;
  return old_func;
}  /* set_unexpected */


__bool uncaught_exception()
/*
Return TRUE if an exception is in the process of being thrown.
*/
{
  an_eh_stack_entry_ptr	ehsep;
  __bool		result;

  /* This function is used instead of simply using __curr_eh_stack_entry
     because of a problem using this variable in code that also uses
     it via generated EH code. */
  ehsep = __get_curr_eh_stack_entry();
  /* TRUE should be returned if uncaught_exception() is called after
     terminate() has been called by the implementation. */
  result = terminate_called;
  for (; result == FALSE && ehsep != NULL; ehsep = ehsep->next) {
    if (ehsep->kind == ehsek_throw_processing_marker) {
      /* We are processing a throw.  An exception cannot be thrown here
         without resulting in a call to terminate().  Note that this is
         TRUE even if a try block is nested inside the throw processing
         marker. */
      result = TRUE;
    }  /* if */
  }  /* for */
  return result;
}  /* uncaught_exception */

/*
If the runtime should be defined in the std namespace, close
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace std */
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */


EXTERN_C void __call_unexpected(void)
/*
Used by the EH runtime when unexpected() needs to be called.  When
unexpected() exits by throwing an exception the exception must not
violate the exception specification that caused unexpected() to be
called in the first place.  If it does violate that exception
specification, std::bad_exception is thrown provided it is permitted
by the violated exception specification.  If it is not permitted,
terminate() is called.

*/
{
#if ABI_CHANGES_FOR_RTTI
  try {
    STD_NAMESPACE::unexpected();
  }  /* try */
  catch (...) {
    a_type_info_impl_ptr	thrown_type;
    an_ETS_flag_set		thrown_flags;
    an_ETS_flag_set		*thrown_ptr_flags;
    __type_of_thrown_object(&thrown_type, &thrown_flags, &thrown_ptr_flags);
    if (__can_throw_type(thrown_type, thrown_flags, thrown_ptr_flags)) {
      /* If the thrown type is permitted, rethrow it so that it will be
         handled by an enclosing try block (if any). */
      throw;
    } else {
      a_type_info_impl_ptr	bad_exception_type;
      bad_exception_type =
                   (a_type_info_impl_ptr)&typeid(STD_NAMESPACE::bad_exception);
      if (__can_throw_type(bad_exception_type,
                           (an_ETS_flag_set)ETS_NO_FLAGS,
                           (an_ETS_flag_set*)NULL)) {
        /* The thrown type is not allowed, but bad_exception is.  Throw
           bad_exception. */
        throw STD_NAMESPACE::bad_exception();
      } else {
        /* Neither the originally thrown type not bad_exception is permitted.
           Call terminate. */
        __call_terminate();
      }  /* if */
    }  /* if */
  }  /* catch */
#else /* !ABI_CHANGES_FOR_RTTI */
 /* When RTTI is not used, the old semantics of unexpected() are used in
    which the type of an object thrown by unexpected is not checked against
    the violated exception specification. */
  STD_NAMESPACE::unexpected();
#endif /* ABI_CHANGES_FOR_RTTI */
  /* It should not be possible to get here. */
  abort();
}  /* __call_unexpected */


EXTERN_C void __call_terminate(void)
/*
Used by the EH runtime when terminate needs to be called.  Ensures
that terminate does not return.
*/
{
  terminate_called = TRUE;
  STD_NAMESPACE::terminate();
  /* It should not be possible to get here. */
  abort();
}  /* __call_terminate */


#endif /* EXCEPTION_HANDLING */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
epilog.asm/     1146129406  0     0     0       618       `
;******************************************************************************
;* EPILOG  v4.1.3                                                              *
;* Copyright (c) 2001-2006 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* EPILOG28.ASM
;****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "epilog28.inc"
        .endif
epilog28.inc/   1146129406  0     0     0       1547      `
;*****************************************************************************
;* EPILOG CODE FOR C28X v4.1.3                                                *
;* Copyright (c) 2001-2006 Texas Instruments Incorporated                    *
;*****************************************************************************

;*****************************************************************************
;* EPILOG CODE IF NO FRAME IS NEEDED                                         *
;* 1. POP SOE REGISTERS                                                      *
;* 2. RETURN                                                                 *
;*****************************************************************************
	.sect	".text"
	.global	_epilog_c28x_1

_epilog_c28x_1:	.asmfunc
	MOVL	XAR3,*--SP
	MOVL	XAR2,*--SP
	MOVL	XAR1,*--SP
	FFCRET	*XAR7
	.endasmfunc

;*****************************************************************************
;* EPILOG CODE IF FRAME IS NEEDED                                            *
;* 1. SUBTRACT FRAME FROM SP                                                 *
;* 2. POP SOE REGISTERS                                                      *
;* 3. RETURN                                                                 *
;*****************************************************************************
	.sect	".text"
	.global	_epilog_c28x_2

_epilog_c28x_2:	.asmfunc
	MOV	PL,SP
	SUBUL	P,XAR0
	MOV	SP,P
	MOVL	XAR3,*--SP
	MOVL	XAR2,*--SP
	MOVL	XAR1,*--SP
	FFCRET	*XAR7
	.endasmfunc

errno.c/        1146129406  0     0     0       375       `
/*****************************************************************************/
/*  errno    v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <errno.h>

_DATA_ACCESS int errno = 0;

errno.h/        1146129406  0     0     0       1225      `
/*****************************************************************************/
/*  ERRNO.H  v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _ERRNO
#define _ERRNO

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cerrno> IS RECOMMENDED OVER <errno.h>.  <errno.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std
{
#endif /* __cplusplus */

#include <linkage.h>

#define errno errno
extern _DATA_ACCESS int errno;

#define EDOM   1
#define ERANGE 2
#define ENOENT 3
#define EFPOS  5
#define EILSEQ 6

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::errno;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::errno;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif  /* _ERRNO */

error.cpp/      1146129406  0     0     0       3506      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

error.c - runtime error handling.

*/

#include "basics.h"
#include "runtime.h"
#pragma hdrstop

#if DISPLAY_ABORT_DESCRIPTION

static char *error_text(an_error_code	err_code)
/*
Return the string associated with the specified error code.
*/
{
  char	*s = NULL;

  switch (err_code) {
    case ec_abort_header:
      s = "C++ runtime abort";
      break;
    case ec_terminate_called:
      s = "terminate() called by the exception handling mechanism";
      break;
    case ec_terminate_returned:
      s = "returned from a user-defined terminate() routine";
      break;
    case ec_already_marked_for_destruction:
      s =
         "internal error: static object marked for destruction more than once";
      break;
    case ec_main_called_more_than_once:
      s = "main() called more than once";
      break;
    case ec_pure_virtual_called:
      s = "a pure virtual function was called";
      break;
    case ec_bad_cast:
      s = "invalid dynamic cast";
      break;
    case ec_bad_typeid:
      s = "invalid typeid operation";
      break;
    case ec_array_not_from_vec_new:
      s = "freeing array not allocated by an array new operation";
      break;
    default:
      unexpected_condition();
      break;
  }  /* switch */
  return s;
}  /* error_text */


static void display_abort_message(an_error_code	err_code)
/*
Display the reason that the runtime is aborting execution.
*/
{
  fprintf(stderr, "%s: %s\n", error_text(ec_abort_header),
          error_text(err_code));
}  /* display_abort_message */

#endif /* DISPLAY_ABORT_DESCRIPTION */

#if !DISPLAY_ABORT_DESCRIPTION
/*ARGSUSED*/ /* err_code is only used when displaying abort descriptions. */
#endif /* !DISPLAY_ABORT_DESCRIPTION */
EXTERN_C void __abort_execution(an_error_code	err_code)
/*
*/
{
#if DISPLAY_ABORT_DESCRIPTION
  /* Display the reason for the abort. */
  display_abort_message(err_code);
#endif /* DISPLAY_ABORT_DESCRIPTION */
  abort();
}  /* abort_execution */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
error.h/        1146129406  0     0     0       1966      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Declarations relating to error.c - runtime error handling.

*/

#ifndef ERROR_H
#define ERROR_H 1

typedef enum /* an_error_code */ {
  ec_none,
  ec_abort_header,
  ec_terminate_called,
  ec_terminate_returned,
  ec_already_marked_for_destruction,
  ec_main_called_more_than_once,
  ec_pure_virtual_called,
  ec_bad_cast,
  ec_bad_typeid,
  ec_array_not_from_vec_new,
  ec_last
} an_error_code;

EXTERN_C void __abort_execution(an_error_code err_code);

#endif /* ERROR_H */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
exception/      1146129406  0     0     0       2359      `
/*****************************************************************************/
/* exception  v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#if __EXCEPTIONS
#define THROW(throw_spec) throw(throw_spec)
#define THROW_NOTHING() throw()
#else /* !__EXCEPTIONS */
#define THROW(throw_spec) /* Nothing. */
#define THROW_NOTHING() /* Nothing. */
#endif /* __EXCEPTIONS */


#ifdef __EXCEPTIONS
#ifndef _EXCEPTION_STDH
#define _EXCEPTION_STDH

/* This lets users disable the EDG supplied exception classes. */
#ifndef __NO_EDG_EXCEPTION_CLASSES

#include <stdexcept.h>

#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace std {
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

  /*
  If bool is not supported, use a typedef for bool.
  */
  #ifdef _BOOL
  typedef bool __bool;
  #else /* ifndef _BOOL */
  typedef int __bool;
  #endif /* ifdef _BOOL */

  class bad_exception : public exception {
  public:
    bad_exception() throw() {};
    bad_exception(const bad_exception&) throw() {};
    bad_exception& operator=(const bad_exception& rhs) throw() { exception::operator=(rhs); return *this; } ;
    virtual ~bad_exception() throw() {};
    virtual const char* what() const throw() { return ""; };
  };

  typedef void (*terminate_handler)();
  extern terminate_handler set_terminate(terminate_handler) THROW_NOTHING();

  typedef void (*unexpected_handler)();
  extern unexpected_handler set_unexpected(unexpected_handler) THROW_NOTHING();

  /* unexpected and terminate are in the WP definition of exception.h.
     It is not clear why. */
  void terminate();
  void unexpected();

  extern __bool uncaught_exception();

#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace */

#ifdef __EDG_IMPLICIT_USING_STD
/* Implicitly include a using directive for the STD namespace when this
   preprocessing flag is TRUE. */
using namespace std;
#endif /* ifdef __EDG_IMPLICIT_USING_STD */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */

#endif /* _EXCEPTION_STDH */
#else  /* __EXCEPTIONS */
#ifndef _EXCEPTION
#define _EXCEPTION
#endif
#endif /* __EXCEPTIONS */


exception.h/    1146129406  0     0     0       1730      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*
The exception header should be included as "#include <exception>".
This file is provided for compatibility with older programs that
use "#include <exception.h>".
*/
#ifndef _EXCEPTION_H
#define _EXCEPTION_H

#include <exception>

#endif /* _EXCEPTION_H */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
exit.c/         1146129406  0     0     0       3389      `
/****************************************************************************/
/*  EXIT.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <_lock.h>

#define MAX_FUN   32

static int    at_exit_count = 0;
static void (*at_exit_fun[MAX_FUN])();
void        (*_cleanup_ptr)(void) = NULL;
void   _DATA_ACCESS      (*_dtors_ptr)(void)   = NULL;

/****************************************************************************/
/* EXIT() - NORMAL PROGRAM TERMINATION.                                     */
/****************************************************************************/
void exit(int status)        
{
   int i;

   /*-------------------------------------------------------------------*/
   /* MUST LOCK WHEN ACCESSING at_exit_count AND at_exit_fun.           */
   /*-------------------------------------------------------------------*/
   _lock();
   i = at_exit_count;

   /*-------------------------------------------------------------------*/
   /* HANDLE FUNCTIONS REGISTERED THROUGH atexit().                     */
   /*-------------------------------------------------------------------*/
   while (i) (*at_exit_fun[--i])(); 

   /*-------------------------------------------------------------------*/
   /* IF THERE ARE STATIC DESTRUCTORS, CALL THEM.                       */
   /*-------------------------------------------------------------------*/
   if (_dtors_ptr)  (*_dtors_ptr)();

   /*-------------------------------------------------------------------*/
   /* IF FILES ARE POSSIBLY OPEN, _CLEANUP_PTR() WILL BE SETUP TO CLOSE */
   /* THEM.                                                             */
   /*-------------------------------------------------------------------*/
   if (_cleanup_ptr)  (*_cleanup_ptr)();

   /*-------------------------------------------------------------------*/
   /* SET C$$EXIT LABEL SO THE DEBUGGER KNOWS WHEN THE C++ PROGRAM HAS  */
   /* COMPLETED.  THIS CAN BE REMOVED IF THE DEBUGGER IS NOT USED.      */
   /*-------------------------------------------------------------------*/
   __asm("        .global C$$EXIT");
   __asm("C$$EXIT: nop");

   for (;;);   /* CURRENTLY, THIS SPINS FOREVER */
}

/****************************************************************************/
/* ATEXIT - ATTEMPT TO REGISTER A FUNCTION FOR CALLING AT PROGRAM END       */
/****************************************************************************/
int atexit(void (*fun)())
{
   /*-------------------------------------------------------------------*/
   /* MUST LOCK WHEN ACCESSING at_exit_count AND at_exit_fun.           */
   /*-------------------------------------------------------------------*/
   _lock();
   if (at_exit_count >= MAX_FUN) {
      _unlock();
      return 1;
   }
   at_exit_fun[at_exit_count++] = fun;
   _unlock();
   return 0;
}

/****************************************************************************/
/* ABORT - ABNORMAL PROGRAM TERMINATION.  CURRENTLY JUST HALTS EXECUTION.   */
/****************************************************************************/
void abort(void)
{
   for (;;);   /* SPINS FOREVER */
}

exp.c/          1146129406  0     0     0       2724      `
/****************************************************************************/
/*  exp    v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  EXP() - e ^ x							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*									    */
/*  N = round(x / ln(2))						    */
/*  g = x - N * ln(2)							    */
/*  z = g * g								    */
/*									    */
/*  R = polynomial expansion						    */
/*									    */
/*  result = R * 2 ^ (N	+ 1)						    */
/****************************************************************************/
double exp(double x)
{
    double g, z, q, p;
    int n;

    /*************************************************************************/
    /* check if input would produce output out of the range of this function */
    /*************************************************************************/
    if (x > MAXX) { errno = ERANGE; return (HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);    /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /*************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                    */
    /*************************************************************************/
    g  = (x - n * C3) - n * C4;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    z  = g * g;

#if BITS <=29
    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
    p = (EXP1 * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

    /*************************************************************************/
    /* exp(x) = exp(g) * 2 ^ (n + 1)                                         */
    /*************************************************************************/
    return ldexp(0.5 + p / (q - p), n + 1); 
}
fabs.c/         1146129406  0     0     0       639       `
/*****************************************************************************/
/* fabs     v4.1.3                                                           */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <math.h>

/****************************************************************************/
/*  FABS() - Floating Point Absolute Value				    */
/****************************************************************************/
double fabs(double x) { return fabs(x); }   /* FABS() IS A BUILTIN FUNCTION */

far_cpy_tbl.c/  1146129406  0     0     0       1626      `
/*****************************************************************************/
/* far_cpy_tbl.c  v4.1.3                                                     */
/* Copyright (c) 2003 Texas Instruments Incorporated                         */
/*                                                                           */
/* General purpose copy routine.  Given the address of a linker-generated    */
/* COPY_TABLE data structure in "far" memory, effect the copy of all object  */
/* components that are designated for copy via the corresponding LCF table() */
/* operator.                                                                 */
/*****************************************************************************/
#include <cpy_tbl.h>

/*****************************************************************************/
/* FAR_COPY_IN()                                                             */
/*****************************************************************************/
void far_copy_in(far COPY_TABLE *tp)
{
   unsigned int i;
   for (i = 0; i < tp->num_recs; i++)
   {
      far COPY_RECORD *crp = &tp->recs[i];
      unsigned int cpy_type = 0;

      if (crp->src_pgid) cpy_type += 2;
      if (crp->dst_pgid) cpy_type += 1;

      switch (cpy_type)
      {
         case 3: ddcopy(crp->src_addr, crp->dst_addr, crp->size); break;
         case 2: dpcopy(crp->src_addr, crp->dst_addr, crp->size); break;
         case 1: pdcopy(crp->src_addr, crp->dst_addr, crp->size); break;
         case 0: ppcopy(crp->src_addr, crp->dst_addr, crp->size); break;
      }
   }            
}
faratoi.c/      1146129406  0     0     0       1253      `
/****************************************************************************/
/*  faratoi v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

int far_atoi(register const far char *st)
{
    register long result = 0;
    register char cp;
    register int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}

long far_atol(const far char *st)
{
    register const far char *fst    = st;
    register       long  result = 0;
    register       char  fc;
 
    while (_isspace(*fst++));                      /* SKIP WHITE SPACE */
 
    if ((fc = *--fst) == '-' || *fst == '+') ++fst;
 
    while (_isdigit(*fst))
    {
        result *= 10;
        result += *fst++ - '0';
    }
 
    return (fc == '-') ? -result : result;
}

farbsearch.c/   1146129406  0     0     0       1245      `
/****************************************************************************/
/*  farbsearch v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

far void *far_bsearch(const far void *key,   /* ITEM TO SEARCH FOR           */
                      const far void *base,  /* POINTER TO ARRAY OF ELEMENTS */
                      size_t nmemb,          /* NUMBER OF ELEMENTS TO SORT   */
                      size_t size,           /* SIZE IN BYTES OF EACH ITEM   */
		      /* COMPARE FUNCTION */
                      int (* compar)(const far void *,const far void *)) 

{
   int i       = 0;             /* left scan index  */
   int j       = nmemb - 1;     /* right scan index */

   while( i <= j )
   {
      int pivot = (j + i) / 2;            
      int result = (*compar) (key, (far char *)base + (pivot * size));
      if (result == 0) return((far char *)base + (pivot * size));
      if (result < 0) j = pivot - 1;
		 else i = pivot + 1;
   }

   return ((far void *)0);   /* IF WE GET TO HERE, WE FAILED */
}



farfrexp.c/     1146129406  0     0     0       1384      `
/****************************************************************************/
/*  farfrexp  v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>

double far_frexp(double value, far int *exp)
{
     int *ptr;
 
     ptr = (int *)&value;
 
     /***********************************************************************/
     /* IF THE VALUE IS ZERO, THE RESULTS ARE ZERO                          */ 
     /***********************************************************************/ 
     if (!ptr[0] && !ptr[1]) 
     {
       *exp = 0;
       return value;
     }
 
     /***********************************************************************/
     /* EXTRACT THE EXPONENT, SUBTRACT THE BIAS, THEN ADD 1                 */
     /***********************************************************************/
     *exp = ((ptr[1] >> 7) & 0xFF) - 127 + 1;
 
     /***********************************************************************/
     /* SET THE EXPONENT OF THE FRACTION TO -1                              */
     /***********************************************************************/
     ptr[1] = (ptr[1] & 0x807F) | ((-1 + 127) << 7);
 
     return (value);
}
farltoa.c/      1146129406  0     0     0       789       `
/****************************************************************************/
/*  farltoa  v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

#define BUFLEN 20

int far_ltoa(long val, far char *buffer)
{
    char  tempc[BUFLEN];
    char *bufptr;
    int   neg  = val < 0;
    long  uval = neg ? -val : val;

    *(bufptr = &tempc[BUFLEN - 1]) = 0;

    do {*--bufptr = (uval % 10) + '0';}  while(uval /= 10);
    if (neg) *--bufptr = '-';

    __memcpy_fn(buffer,bufptr, uval = (tempc + BUFLEN) - bufptr);
    return uval - 1;    /* DON'T COUNT NULL TERMINATION */
}


farmemchr.c/    1146129406  0     0     0       593       `
/****************************************************************************/
/*  farmemchr v4.1.3                                                         */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far void *far_memchr(const far void *s, int c, size_t n)
{
   const far unsigned char *st = (far unsigned char *)s;
   unsigned char        ch = c;

   while (n-- != 0) 
      if (*st++ == ch) { return (far void *)--st; }
   return NULL;
}

farmemcmp.c/    1146129406  0     0     0       601       `
/****************************************************************************/
/*  farmemcmp.c v4.1.3 							    */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

int far_memcmp(const far void *s1, const far void *s2, size_t n)
{
   far unsigned char *st1 = (far unsigned char *)s1;
   far unsigned char *st2 = (far unsigned char *)s2;
   size_t         diff;

   if (n == 0)  return 0;

   while (n-- && !(diff = *st1++ - *st2++)) ;
   return diff;
}

farmemmov.c/    1146129406  0     0     0       737       `
/****************************************************************************/
/*  farmemmov.c  v4.1.3                                                      */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far void *far_memmove(far void *s1, const far void *s2, size_t n)
{
   if (s2 > s1)
      return far_memcpy(s1, s2, n);
   else
   {
      unsigned far char *st1 = (unsigned far char *)s1;
      unsigned far char *st2 = (unsigned far char *)s2;
      size_t         ln;
 
      st1 += n;
      st2 += n;
      for (ln = 0; ln < n; ln++) *--st1 = *--st2;
   }

   return s1;
}

farmemory.c/    1146129406  0     0     0       25165     `
/****************************************************************************/
/*  farmemory.c v4.1.3                                                       */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/

/*****************************************************************************/
/*                                                                           */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines when the heap is located in far memory.  The         */
/*  algorithms used are based on the algorithms described in Knuth's "The    */
/*  Art Of Computer Programming, Vol 1" on pages 435-441.                    */
/*  Algorithm 2.5A has been modified to improve the resistance to            */
/*  fragmentation.                                                           */
/*                                                                           */
/*  Knuth gives two reasons for prefering "first fit" over "best fit".       */
/*   1) The algorithm is significantly faster, since the whole of the free   */
/*      store does not have to be seached for each allocation                */
/*      (or deallocation).                                                   */
/*   2) The first fit algorithm is more resistant to overflow during         */
/*      repeated allocation and deallocation than is the best fit algorithm  */
/*      (See problems 36-43 on page 456).                                    */
/*                                                                           */
/*  The following assumptions/rules apply:                                   */
/*                                                                           */
/*                                                                           */
/*   1) Packets are allocated a minimum of two words                         */
/*   2) The heap can be reset at any time by calling the function            */
/*      "far_minit"                                                          */
/*   3) There a separate far heap.  Malloc and related routines will only    */
/*      affect allocations from the near heap                 .              */
/*   4) The far heap size must be declared in the linker command file using  */
/*      the -farheap option.                                                 */
/*                                                                           */
/*  The following items are defined in this module :                         */
/*   far_minit()    : Function to initialize dynamic memory management       */
/*   far_malloc()   : Function to allocate memory from mem mgmt system.      */
/*   far_calloc()   : Allocate and clear memory from mem mgmt system.        */
/*   far_realloc()  : Reallocate a packet                                    */
/*   far_free()     : Function to free allocated memory.                     */
/*                                                                           */
/*   far_memlcpy()   : long copy memory from one area to another             */
/*   far_memlmove()  : long copy memory from one area to another allowing    */
/*                     for overlapping regions                               */
/*                                                                           */
/*    _far_sys_memory : Array to contain all memory allocate by system.      */
/*    far_sys_free   : Pointer to free list                                  */
/*                                                                           */
/*    far_free_memory() : Return total amount of available free memory.      */
/*    far_max_free() : Return largest single free memory block in heap.      */
/*                                                                           */
/*****************************************************************************/

/*****************************************************************************/
/*  DEBUG Support.                                                           */
/*  When the symbol DEBUG has been #defined, an extra DWORD is added to the  */
/*  allocation header, and is set to the value 0xBEEFDEAD (so that it shows  */
/*  in the debugger as "dead beef") in every allocated and free block of     */
/*  memory.  The integrety of the far memory hep can then be checked by      */
/*  calling the function "long  far_chkheap()".  This function returns zero  */
/*  if the all memory blocks have the correct signature.  Otherwise, it      */
/*  returns the offset to the first location of an invalid value in a block  */
/*  header.                                                                  */
/*****************************************************************************/

#undef _INLINE				/* DISABLE INLINE EXPANSION         */

#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <_lock.h>

#ifdef DEBUG
#define GUARDDWORD 0xBEEFDEAD
#endif

/*****************************************************************************/
/* Declare the memory pool as a .usect called .esysmem.  The size of the     */
/* section .esysmem is determined by the linker via the -farheap option      */
/*****************************************************************************/
__asm("__far_sys_memory   .usect  \".esysmem\",0");
extern far int _far_sys_memory[];

/*****************************************************************************/
/* "FPACKET" is the template for a far data packet.  Packet size contains    */
/* the number of words allocated for the user, excluding the size            */
/* required for management of the packet (32 bits).  Packets are always      */
/* allocated memory in words.  A negative size indicates a free packet.      */
/*****************************************************************************/
typedef struct fpack
{
	long packet_size;         /* in words */
#ifdef DEBUG
	long guard;
#endif
	far struct fpack  *size_ptr;
} FPACKET;


#define LIMIT	((far FPACKET *) -1)

#define OVERHEAD offsetof(FPACKET, size_ptr)
#define MINSIZE	2

/*****************************************************************************/
/* __FAR_SYSMEM_SIZE is the symbol that linker defines as the size of heap.  */
/* Access of that value from 'C' is done by taking the address of this symbol*/
/*****************************************************************************/
extern far int _FAR_SYSMEM_SIZE;
#define MEMORY_SIZE ((long)&_FAR_SYSMEM_SIZE)

/*****************************************************************************/
/* POINTER TO THE LIST OF FREE BLOCKS                                        */
/*****************************************************************************/
static far FPACKET * far_sys_free;

/*****************************************************************************/
/* POINTER TO THE START OF THE FAR HEAP                                      */
/*****************************************************************************/
static far FPACKET * far_sys_base;
static long memsize;
/*****************************************************************************/
/* FLAG TO TELL MALLOC IF THE MEMORY AREA HAS BEEN INITIALIZED 		     */
/*****************************************************************************/
static int first_call = 1; 

/*****************************************************************************/
/*                                                                           */
/*  FAR_MINIT - This function can be called by the user to completely reset  */
/*              the memory management system.                                */
/*                                                                           */
/*****************************************************************************/
void far_minit(void)
{
    _lock();
    memsize = MEMORY_SIZE;

    /************************************************************************/
    /* TO INITIALIZE THE MEMORY SYSTEM, DEALLOCATE ONE PACKET WHICH USES    */
    /* AVAILABLE MEMORY, INITIALIZE THE FREE LIST TO POINT TO IT.           */
    /* INSURE CORRECT ALIGNMENT BY MAKING SURE SYS_FREE IS ON AN EVEN       */
    /* BOUNDARY.  THIS GUARANTEES FIRST PACKET WILL BE ON AN EVEN BOUNDARY. */
    /************************************************************************/
    if ((long)_far_sys_memory & 1)
    {

	far_sys_free = (far FPACKET *) (_far_sys_memory + 1);
	-- memsize;
    }
    else
    {
	far_sys_free = (far FPACKET *) _far_sys_memory;
    }
    if(memsize & 1) --memsize;

    far_sys_free->packet_size = -(memsize - OVERHEAD);
    far_sys_free->size_ptr    = LIMIT;

#ifdef DEBUG
    far_sys_free->guard = GUARDDWORD;
#endif
    far_sys_base = far_sys_free;

    first_call = 0; 	/* Clear the flag */
    _unlock();
}

/*****************************************************************************/
/*                                                                           */
/*  FAR_MALLOC - Allocate a packet of a given size, and return pointer to    */
/*  it.  This function only allocates in multiple of ints.                   */
/*                                                                           */
/*****************************************************************************/
far void *far_malloc(unsigned long usersize)
{
    far FPACKET * current;
    far FPACKET * next;
    far FPACKET * last;

    if( usersize == 0 ) return 0;

    if(usersize & 1) ++usersize;   /* MAKE SURE THE SIZE IS EVEN */

    _lock();

    if(first_call) far_minit(); 

    current = far_sys_free;
    last = 0;

    if (current == LIMIT) { _unlock(); return 0; } /* NO MEMORY TO ALLOCATE */

    /*************************************************************************/
    /* LOOK FOR THE FIRST BLOCK LARGE ENOUGH TO HOLD THE REQUESTED ALLOCATION*/
    /*************************************************************************/
    while( -current->packet_size < usersize )
    {
    	last = current;
    	current = current->size_ptr;
    	if (current == LIMIT) 
	{
	    _unlock();
	    return 0; /* have tried all of free memory */
	}
    }

    if( -current->packet_size > usersize + OVERHEAD + MINSIZE )
    {
	/*********************************************************************/
	/* IF THE PACKET IS LARGER THAN NEEDED, SPLIT THE BLOCK AND ALLOCATE */
        /* THE BOTTOM PART.			    			     */
	/* tHIS IS THE MODIFICATION TO kNUTH'S ALGORITHM 2.5a. THE 	     */
	/* ALLOCATION OF THE LOW PART WAS CHOSEN IN PLACE OF SEARCHING FOR   */
	/* FUTURE ALLOCATIONS FROM SOME POINT WITHIN THE LIST (kNUTH'S 2.5a')*/
	/* AS A WAY TO ENSURE THAT FREED BLOCKS GET RECYCLED BEFORE          */
	/* ALLOCATIONS ARE MADE FROM THE LARGE ORIGINAL FREE BLOCK.          */
	/*********************************************************************/
	next = (far FPACKET *)((far char *)current + OVERHEAD + usersize);
	next->packet_size = current->packet_size + usersize + OVERHEAD;
#ifdef DEBUG
	next->guard = GUARDDWORD;
#endif
	current->packet_size = usersize;
	if(last)
	    last->size_ptr = next;
	else
	    far_sys_free = next;
	next->size_ptr = current->size_ptr;
    }
    else
    {
	/*********************************************************************/
	/* ALLOCATE THE WHOLE BLOCK AND REMOVE IT FROM THE FREE LIST.        */
	/*********************************************************************/
	if(last)
	    last->size_ptr = current->size_ptr;
	else
	    far_sys_free = current->size_ptr;

	current->packet_size = - current->packet_size;	/* FIX THE SIGN */
    }
    _unlock();
    return &(current->size_ptr);
}

/*****************************************************************************/
/*                                                                           */
/* FAR_FREE - Return a packet allocated by malloc to free memory pool.       */
/*                                                                           */
/*****************************************************************************/
void far_free(far void * userptr)
{
    far FPACKET * current;
    far FPACKET * next;
    far FPACKET * last;

    if( userptr == 0 ) return;		/* HANDLE NULL POINTER CORRECTLY */

    _lock();

    current = far_sys_free;
    last = 0;
    next = (far FPACKET *)((far char *) userptr - OVERHEAD);
#if 0
#ifdef DEBUG
    /*************************************************************************/
    /* IN THE DEBUG VERSION, WE CAN NOW CHECK IF THE PACKET TO BE FREED HAS  */
    /* THE CORRECT SIGNATURE. bUT WE MUST THEN DECIDE HOW TO REPORT THE      */
    /* PROBLEM TO THE CLIENT CODE. 					     */
    /*************************************************************************/
    if( next->guard != GUARDDWORD)
    {
    	/* CODE TO REPORT THE ERROR */
    }
#endif
#endif

    /*************************************************************************/
    /* SEARCH THE FREE LIST FOR THE FREE PACKETS IMMEDIATELY BEFORE AND AFTER*/
    /* THE PACKET TO BE FREED. 						     */
    /*************************************************************************/
    while (current < next)
    {
    	last = current;
    	current = current->size_ptr;
    }

    /*************************************************************************/
    /* COALLESCE WITH NEXT BLOCK IF POSSIBLE.                                */
    /*************************************************************************/
    if((long)next + next->packet_size + OVERHEAD == (long)current)
    {
    	next->size_ptr = current->size_ptr;
    	next->packet_size += -current->packet_size + OVERHEAD;
#ifdef DEBUG
    	current->guard = 0;
#endif
    }
    else
    {
    	next->size_ptr = current;	/* START TO PUT INTO LIST */
    }

    if(last)				/* ARE WE THE NEW HEAD OF THE LIST */
    {
        /*********************************************************************/
        /* WE ARE NOT THE HEAD OF THE LIST; TRY TO COALLESCE WITH LAST.      */
        /*********************************************************************/
    	if((long)last - last->packet_size + OVERHEAD == (long)next)
    	{
            last->size_ptr = next->size_ptr;
    	    last->packet_size += - next->packet_size - OVERHEAD;
#ifdef DEBUG
    	    next->guard = 0;
#endif
        }
        else
        {
            last->size_ptr = next;
    	    next->packet_size = - next->packet_size;
        }
    }
    else
    {
        far_sys_free = next;
    	next->packet_size = - next->packet_size;
    }
    _unlock();
}

/*****************************************************************************/
/*                                                                           */
/* FAR_REALLOC - Reallocate a packet to a new size.                          */
/*                                                                           */
/*****************************************************************************/
far void * far_realloc(far void * memblock, unsigned long newsize)
{
    far FPACKET * next;
    far FPACKET * userblock;
    far FPACKET * last;

    /****************************************************************/
    /* HANDLE SPECIAL CASES                                         */
    /****************************************************************/
    if( newsize == 0 )
    {
	far_free(memblock);
	return 0;
    }
    if( memblock == 0 )
	return far_malloc(newsize);

    /****************************************************************/
    /* ROUND SIZE UP TO EVEN BOUNDARY                               */
    /****************************************************************/
    if(newsize & 1)
	++newsize;

    _lock();

    userblock = (far FPACKET *)((far char *)memblock - OVERHEAD);
    next = (far FPACKET *)((far char *)memblock + userblock->packet_size);

    /****************************************************************/
    /* CHECK IF WE MUST MALLOC AND MOVE FOR THE FOLLOWING REASONS   */ 
    /* 1 IF THE USERBLOCK IS THE LAST BLOCK IN THE HEAP.            */
    /* 2 IF NEXT BLOCK IS NOT FREE.                                 */
    /* 3 IF NEXT BLOCK IS FREE BUT NOT BIG ENOUGH.                  */
    /*                                                              */
    /* NOTE ON CONDITION 1                                          */
    /*      IF THE USER BLOCK IS THE LAST BLOCK IN THE HEAP, THE    */
    /* NEXT BLOCK WILL BE JUST OUTSIDE THE HEAP.  SO THE FOLLOWING  */
    /* CONDITION IS USED:					    */
    /* ((far char*)next >= (far char*)far_sys_base + memsize)       */
    /*      THE COMPARISON IS REARRANGED FROM ITS NATURAL FORM TO   */
    /* AVOID THE COMPILER HANDLING ADDTION OF A VALUE > 64K TO A PTR*/
    /* ALSO, THE POINTERS ARE CASTED TO LONG TO AVOID A POINTER DIFF*/
    /* OF > 64K AS POINTER DIFFS ARE ALLOWD ONLY WITH IN ARRAY AND  */
    /* COMPILER LIMITS THE ARRAY SIZE TO BE 64K.                    */
    /****************************************************************/
    if( (newsize > userblock->packet_size) 
	   && ( ((long)next - (long)far_sys_base >= memsize) 
	   ||   (next->packet_size > 0) 
           ||   ((next->packet_size < 0) && 
          (newsize > userblock->packet_size - next->packet_size + OVERHEAD)) ) )
    {
	far void * ptr = far_malloc(newsize);
	if(ptr)
	{
	    far_memlcpy( memblock, ptr, userblock->packet_size );
	    far_free(memblock);
	}
	_unlock();
	return ptr;
    }

    /****************************************************************/
    /* IF WE ARE HERE, WE CAN REALLOC IN PLACE. WE MUST FIND NEXT   */
    /* AND LAST TO DO THE BOOKKEEPING				    */
    /****************************************************************/
    next = far_sys_free;
    last = 0;

    while (next < userblock)
    {
	last = next;
	next = next->size_ptr;
    }

    if((long)next == (long)memblock + userblock->packet_size)
    {
#ifdef DEBUG
	next->guard = 0;
#endif
	if( newsize >= userblock->packet_size - next->packet_size - MINSIZE )
	{
	    /****************************************************************/
	    /* COALLESCING WITH THE NEXT BLOCK - NEXT BLOCK IS COMPLETELY   */
	    /* ABSORBED.                                                    */
	    /****************************************************************/
	    last->size_ptr = next->size_ptr;
	    userblock->packet_size += -next->packet_size + OVERHEAD;
	}
	else
	{
	    /****************************************************************/
	    /* COALLESCING WITH THE NEXT BLOCK - WILL HAVE A CHUNK LEFTOVER */
	    /* ADD IT TO THE FREE LIST.                                     */
	    /****************************************************************/
	    long nsize = next->packet_size + newsize - userblock->packet_size;
	    far FPACKET* nextP = next->size_ptr;
	    next =	(far FPACKET*)((far char *)memblock + newsize);
	    next->packet_size = nsize;
	    next->size_ptr = nextP;
#ifdef DEBUG
	    next->guard = GUARDDWORD;
#endif
	    userblock->packet_size = newsize;
	    if(last)
		last->size_ptr = next;
	    else
		far_sys_free = next;
	}
    }
    else
    {
	/*********************************************************************/
	/* WE ARE SHRINKING IN PLACE IF THERE IS ENOUGH EXTRA TO MAKE A      */
	/* WORTHWHILE FREE BLOCK 					     */
	/*********************************************************************/
	if(userblock->packet_size - newsize >= OVERHEAD + MINSIZE)
	{
	    far FPACKET * nP = (far FPACKET*)((far char *)memblock + newsize);
	    nP->packet_size = - userblock->packet_size + newsize + OVERHEAD;
	    nP->size_ptr = next;
#ifdef DEBUG
	    nP->guard = GUARDDWORD;
#endif
	    if (last)
		last->size_ptr = nP;
	    else
 		far_sys_free = nP;
	    userblock->packet_size = newsize;
	}
    }
    _unlock();
    return memblock;
}

/*****************************************************************************/
/*                                                                           */
/* FAR_CALLOC - Allocate a packet of a given size, set the data in the       */
/*               packet to nulls, and return a pointer to it.                */
/*                                                                           */
/*****************************************************************************/
far void * far_calloc(unsigned long num, unsigned long size)
{
    register unsigned long i	    = size * num;
    register far void * ret = far_malloc(i);
    if(ret)
    {
	register far char * c = ret;
	while (i--) *c++ = 0;
    }
    return ret;
}


/*****************************************************************************/
/*                                                                           */
/*  FAR_CHKHEAP - Check the integrety of the far memory heap.  If the heap   */
/*                is corrupt, returns the address of the corrupt header, else*/
/*                returns 0.  Always returns 0 in release version.           */
/*                                                                           */
/*****************************************************************************/
long far_chkheap()
{
#ifdef DEBUG
    /* find the start of the heap */

    long pkt, top;

    pkt = (long)far_sys_base;
    top = (long) far_sys_base + memsize - sizeof(FPACKET);

    while( pkt < top)
    {
	if(((far FPACKET *)pkt)->guard != GUARDDWORD)
	{
	    _unlock();
	    return (long) &(((far FPACKET *)pkt)->guard);
	}

	if(((far FPACKET *)pkt)->packet_size > 0)
	    pkt += ((far FPACKET *)pkt)->packet_size + OVERHEAD;
	else
	    pkt += -((far FPACKET *)pkt)->packet_size + OVERHEAD;

    }
#endif
    _unlock();
    return 0;
}

/***************************************************************************/
/* FAR_MEMLMOVE - Version of memmove to move data in far memory 	   */
/* 		  (addresses >64K)  Can move more than 64K words.          */
/***************************************************************************/
far void *far_memlmove(far void *s1, far const void *s2, unsigned long n)
{
   if (s2 > s1)
      return far_memcpy(s1, s2, n);
   else
   {
      far unsigned char *st1 = (far unsigned char *)s1;
      far unsigned char *st2 = (far unsigned char *)s2;
      unsigned long      ln;

	  st1 = st1 + n;
	  st2 = st2 + n;
      for (ln = 0; ln < n; ln++) *--st1 = *--st2;
   }

   return s1;
}

/***************************************************************************/
/* FAR_MEMLCPY - Version of memcpy  to copy data in far memory )           */
/* 		 (addresses >64K). Can move more than 64K words.           */
/***************************************************************************/
void far *far_memlcpy(void far *to, const void far *from, unsigned long n)
{
     register char far *rto   = (char far *) to;
     register char far *rfrom = (char far *) from;
     register unsigned long rn;

     for (rn = 0; rn < n; rn++) *rto++ = *rfrom++;
     return (to);
}

/*****************************************************************************/
/*                                                                           */
/*  FAR_FREE_MEMORY - returns the total amount of free far memory available  */
/*                    for allocation.  The memory may be fragmented          */
/*                                                                           */
/*****************************************************************************/
long far_free_memory(void)
{
    far struct fpack *ptr;
    long memsz = 0;

    _lock();
    ptr = far_sys_free;

    if(!first_call)	/* IF MEMORY IS INITIALIZED */ 
    {
	while(ptr != LIMIT)
	{
	    memsz -= ptr->packet_size;
	    ptr = ptr->size_ptr;
	}
    }
    _unlock();
    return memsz;
}

/*****************************************************************************/
/*                                                                           */
/*  FAR_MAX_FREE - returns the size of the largest single block of far       */
/*                 memory available for allocation.                          */
/*                                                                           */
/*****************************************************************************/
long far_max_free(void)
{
    far struct fpack *ptr;
    long memsz = 0;

    _lock();
    ptr = far_sys_free;

    if(!first_call)	/* IF MEMORY IS INITIALIZED */
    {
	while(ptr != LIMIT)
	{
	    if(memsz > ptr->packet_size)
		memsz = ptr->packet_size;
	    ptr = ptr->size_ptr;
	}
    }
    _unlock();
    return -memsz;
}

farmemset.c/    1146129406  0     0     0       546       `
/****************************************************************************/
/*  farmemset v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#undef _INLINE
#include <string.h>

far void *far_memset(far void *s, int c, size_t n)
{
   unsigned far char *st = (unsigned far char *)s;
   unsigned char  ch = c;

   while (n-- > 0)  *st++ = ch;
   return s;
}
farmodf.c/      1146129406  0     0     0       2327      `
/****************************************************************************/
/*  farmodf   v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  FAR_MODF() - break into integer and fractional parts                    */
/*                                                                          */
/*  if x < -2 ^ 23 or x > 2 ^ 23, modf will return 0, and x -> memory       */
/*                                                                          */
/*  else result = x - int(x), int(x) -> memory location                     */
/*                                                                          */
/****************************************************************************/
 
 
double far_modf(double value, far double *iptr)
{
    double mid; /* the integral part of x */
 
    /**********************************************************************/
    /* for values >2^(bits in mantissa) or values <-2^(bits in mantissa)  */
    /**********************************************************************/
 
    if (value > TWO23 || value < - TWO23 || value == 0.0)
    {
        *iptr = value;
 
        /******************************************************************/
        /* fraction = 0                                                   */
        /******************************************************************/
 
        return 0.0;
    }
    else
    {
        mid = (int) value;     /* since (int) -1.5 = -1.0 */
 
        /******************************************************************/
        /* save the integer part of value where iptr points               */
        /******************************************************************/
 
        *iptr = mid;
 
        /******************************************************************/
        /* return the fractional part of value                            */
        /******************************************************************/
 
        return (value - mid);
    }
}

farqsort.c/     1146129406  0     0     0       1676      `
/****************************************************************************/
/*  qsort v4.1.3                                                            */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

static void far_swap_item(far char *src, far char *dest, size_t size);

void far_qsort(far void *base, size_t nmemb, size_t size, 
	   int (* compar)(const far void *, const far void *))

{
   far char  *basep  = (far char *)base;  /* POINTER TO ARRAY OF ELEMENTS */
   size_t i      = 0;             /* left scan index              */
   size_t j      = nmemb - 1;     /* right scan index             */
   size_t pivot  = (nmemb / 2);
   far char  *pivp   = basep + (pivot * size);

   if (nmemb <= 1)  return;

   while( i < j )
   {
      while( (*compar) (basep + (i * size), pivp) < 0 ) ++i;
      while( (*compar) (basep + (j * size), pivp) > 0 ) --j;
      if( i < j )
      {
	 far_swap_item(basep + (i * size), basep + (j * size), size);
	 if     ( pivot == i ) { pivot = j; pivp = basep + (pivot * size); }
	 else if( pivot == j ) { pivot = i; pivp = basep + (pivot * size); } 
	 ++i; --j;
      }
      else if ( i == j ) { ++i; --j;  break; }
   }

   if( j > 0)       far_qsort(basep, j + 1, size, compar);
   if( i < nmemb-1) far_qsort(basep + (i * size), nmemb - i, size, compar);
}


static void far_swap_item(far char *src, far char *dest, size_t size)
{
    while (size--)
    {
        int temp = *src;       
        *src++   = *dest;
        *dest++  = temp;
    }
}

farsetjmp.asm/  1146129406  0     0     0       765       `
****************************************************************************
* farsetjmp farlongjmp v4.1.3
* Copyright (c) 2000-2006      Texas Instruments Incorporated
****************************************************************************
*    C syntax:       int far_setjmp(far_jmp_buf env)
*
*    Description:    Save caller's current environment for a subsequent
*                    call to far_longjmp.  Return 0.
*    Return:         Always returns 0.                    
****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "farsetjmp27.inc"
        .elseif .TMS320C2800
                .include "farsetjmp28.inc"
        .endif

farsetjmp27.inc/1146129406  0     0     0       2586      `
****************************************************************************
* farsetjmp farlongjmp v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
****************************************************************************
*    C syntax:       int far_setjmp(far_jmp_buf env)
*
*    Description:    Save caller's current environment for a subsequent
*                    call to far_longjmp.  Return 0.
*    Return:         Always returns 0.                    
****************************************************************************
        .global  _far_setjmp, __far_setjmp, _far_longjmp

****************************************************************************
*  NOTE : "setjmp.h" declares "far_setjmp" as a macro. In our 
*         implementation, the far_setjmp macro calls a function "_far_setjmp".
*         However, since the user may not include "setjmp.h", we provide
*         two entry-points to this function.
****************************************************************************
__far_setjmp:	.asmfunc
_far_setjmp:
	MOV	AL,SP		; save SP, upon entry env is pointed at by AR4
	MOV	*XAR6++,AL	

	MOVL	ACC,*-SP[2]	; save return address
	MOV	*XAR6++,AL	; store 1 word at a time since alignment of
	MOV	*XAR6++,AH	; jmp_buf is unknown

	MOV	*XAR6++,AR1	; save registers compiler convention requires
	MOV	*XAR6++,AR2	; to be saved on function entry
	MOV	*XAR6,AR3

	MOVB	AL,#0		; set return value to 0	

	RET			; return
	.endasmfunc

        .page
****************************************************************************
*    C syntax:    void far_longjmp(far_jmp_buf env, int returnvalue)
*
*    Description: Restore the context contained in the jump buffer.
*                 This causes an apparent "2nd return" from the
*                 far_setjmp invocation which built the "env" buffer.
*
*    Return:      This return appears to return "returnvalue", which must 
*                 be non-zero.
*
****************************************************************************
_far_longjmp:	.asmfunc
	CMPB	AL,#0		; ensure that returnvalue will be non-zero
	B	L1,NEQ		; if (returnvalue == 0) return 1
	MOVB	AL,#1		; 
L1:
	MOV	AR1,*XAR6++	; set SP to value stored in env
	MOV	SP,AR1
	MOV	AR1,*XAR6++	; put new return address on stack
	MOV	*-SP[2],AR1     
	MOV	AR1,*XAR6++	
	MOV	*-SP[1],AR1

	MOV	AR1,*XAR6++	; restore registers that compiler conventions
	MOV	AR2,*XAR6++      ; require to be restored on function return
	MOV	AR3,*XAR6

	RET			; return
	.endasmfunc
farsetjmp28.inc/1146129406  0     0     0       2949      `
****************************************************************************
* farsetjmp farlongjmp v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
****************************************************************************
*    C syntax:       int far_setjmp(far_jmp_buf env)
*
*    Description:    Save caller's current environment for a subsequent
*                    call to far_longjmp.  Return 0.
*    Return:         Always returns 0.                    
****************************************************************************
        .global  _far_setjmp, __far_setjmp, _far_longjmp

****************************************************************************
*  NOTE : "setjmp.h" declares "far_setjmp" as a macro. In our 
*         implementation, the far_setjmp macro calls a function "_far_setjmp".
*         However, since the user may not include "setjmp.h", we provide
*         two entry-points to this function.
****************************************************************************
__far_setjmp:	.asmfunc
_far_setjmp:
	PUSH	RPC		; save return address
	MOVL	ACC,*--SP
	MOV	*XAR4++,AL	; store 1 word at a time since alignment of
	MOV	*XAR4++,AH	; jmp_buf is unknown

	MOV	AL,SP		; save SP, upon entry env is pointed at by AR4
	MOV	*XAR4++,AL	

	MOVL    ACC,XAR1        ; save registers compiler convention requires
	MOV     *XAR4++,AL      ; to be saved on functio entry
	MOV     *XAR4++,AH      ; store 1 word at a time
	MOVL    ACC,XAR2
	MOV     *XAR4++,AL
	MOV     *XAR4++,AH
	MOVL    ACC,XAR3
	MOV     *XAR4++,AL
	MOV     *XAR4,AH

	MOVB	AL,#0		; set return value to 0	

	LRETR			; return
	.endasmfunc

        .page
****************************************************************************
*    C syntax:    void far_longjmp(far_jmp_buf env, int returnvalue)
*
*    Description: Restore the context contained in the jump buffer.
*                 This causes an apparent "2nd return" from the
*                 far_setjmp invocation which built the "env" buffer.
*
*    Return:      This return appears to return "returnvalue", which must 
*                 be non-zero.
*
****************************************************************************
_far_longjmp:	.asmfunc
	CMPB	AL,#0		; ensure that returnvalue will be non-zero
	B	L1,NEQ		; if (returnvalue == 0) return 1
	MOVB	AL,#1		; 
L1:
	MOVZ	AR1,*XAR4++	; put new return address on stack
	MOV	*-SP[2],AR1     
	MOVZ	AR1,*XAR4++	
	MOV	*-SP[1],AR1
	POP	RPC             ; pop new return address

	MOVZ	AR1,*XAR4++	; set SP to value stored in env
	MOV	SP,AR1

	MOV     PL,*XAR4++      ; restore register that compiler conventions
	MOV     PH,*XAR4++      ; require to be restored on function return
	MOVL    XAR1,P
	MOV     PL,*XAR4++
	MOV     PH,*XAR4++
	MOVL    XAR2,P
	MOV     PL,*XAR4++
	MOV     PH,*XAR4
	MOVL    XAR3,P

	LRETR			; return
	.endasmfunc

farstrcat.c/    1146129406  0     0     0       619       `
/****************************************************************************/
/*  farstrcat v4.1.3                                                         */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strcat(far char *s1, const far char *s2)
{
   far char *result = s1;

   while (*s1++);			     /* FIND END OF STRING   */
   --s1;				     /* BACK UP OVER NULL    */
   while (*s1++ = *s2++);	             /* APPEND SECOND STRING */
   return result;
}

farstrchr.c/    1146129406  0     0     0       487       `
/****************************************************************************/
/*  farstrchr v4.1.3                                                         */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strchr(const far char *s, int c)
{
   do
      if (*s == c) return (far char *)s;
   while (*s++);
 
   return NULL;
}


farstrcmp.c/    1146129406  0     0     0       580       `
/****************************************************************************/
/*  farstrcmp v4.1.3                                                         */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

int far_strcmp(const far char *s1, const far char *s2)
{
   const far char *r1 = s1;
   const far char *r2 = s2;
 
   for(;;)
   {
      if (!*r1) return(0 - *r2);
      if (*r1++ != *r2++)
	 return(*--r1 - *--r2);
   }
}

farstrcoll.c/   1146129406  0     0     0       634       `
/****************************************************************************/
/*  farstrcoll v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

int far_strcoll(const far char *s1, const far char *s2)
{
   unsigned far char *st1 = (unsigned far char *)s1;
   unsigned far char *st2 = (unsigned far char *)s2;

   for(;;)
   {
      if (!*st1) return(0 - *st2);
      if (*st1++ != *st2++)
	 return(*--st1 - *--st2);
   }
}
farstrcpy.c/    1146129406  0     0     0       953       `
/****************************************************************************/
/*  strcpy v4.1.3                                                           */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

char far *strcpy_ff(char far *to, const char far *from)
{
     register       char far *rto   = to;
     register const char far *rfrom = from;
 
     while (*rto++ = *rfrom++);
     return (to);
}
 
 
char *strcpy_nf(char *to, const char far *from)
{
     register       char *rto   = to;
     register const char far *rfrom = from;
 
     while (*rto++ = *rfrom++);
     return (to);
}
 
 
char far *strcpy_fn(char far *to, const char *from)
{
     register       char far *rto   = to;
     register const char *rfrom = from;
 
     while (*rto++ = *rfrom++);
     return (to);
}

farstrcspn.c/   1146129406  0     0     0       1046      `
/****************************************************************************/
/*  farstrcspn v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

size_t far_strcspn(const far char *s1, const far char *s2)
{
   const far char *check;
   size_t      count = 0;
 
   /*---------------------------------------------------------------------*/
   /* FOR EACH CHAR IN s1                                                 */
   /*---------------------------------------------------------------------*/
   for (; *s1; s1++, count++)
   {
      for (check = s2; *check;)
	 /*---------------------------------------------------------------*/
	 /* QUIT WHEN FIND A CHAR IN s1 THAT'S EQUAL TO A CHAR IN s2      */
	 /*---------------------------------------------------------------*/
	 if (*s1 == *check++) return count;
   }
   return count;
}
farstrerror.c/  1146129406  0     0     0       722       `
/****************************************************************************/
/*  farstrerror  v4.1.3                                                      */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <errno.h>
#include <string.h>

far char *far_strerror(int errnum)
{
   switch(errnum)
   {
      case 0      :  return ("No error");
      case EDOM   :  return ("Domain error");
      case ERANGE :  return ("Range error");
      case ENOENT :  return ("No such file or directory");
      case EFPOS  :  return ("File positioning error");
   }

   return ("Unknown error");
}
farstrlen.c/    1146129406  0     0     0       457       `
/****************************************************************************/
/*  farstrlen v4.1.3                                                         */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

size_t far_strlen(const far char *s)
{
   const far char *r = s - 1;

   while (*++r);
   return r - s;
}

farstrncat.c/   1146129406  0     0     0       669       `
/****************************************************************************/
/*  farstrncat v4.1.3                                                        */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strncat(far char *s1, const far char *s2, size_t n)
{
   far char *result = s1;

   while (*s1++);			   /* FIND END OF STRING   */
   --s1;  				   /* BACK UP OVER NULL    */
   while (n-- != 0) 
      if (!(*s1++ = *s2++)) return result; /* APPEND SECOND STRING */
   *s1 = 0;
   return result;
}


farstrncmp.c/   1146129406  0     0     0       670       `
/****************************************************************************/
/*  farstrncmp v4.1.3                                                        */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

int far_strncmp(const far char *s1, const far char *s2, size_t n)
{
   unsigned far char *st1 = (unsigned far char *)s1;
   unsigned far char *st2 = (unsigned far char *)s2;
   unsigned int   ch1, diff;

   if (n == 0)  return 0;

   while (n-- && !(diff = (ch1 = *st1++) - *st2++) && ch1 != 0) ;
   return diff;
}
farstrncpy.c/   1146129406  0     0     0       672       `
/****************************************************************************/
/*  farstrncpy v4.1.3                                                        */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strncpy(far char *s1, const far char *s2, size_t n)
{
   far char *result = s1;

   if (n == 0) return result; 
   while ((*s1++ = *s2++) && --n != 0);  /* COPY STRING         */
   if (n > 1)
   {
      --n;
      do *s1++ = 0; while (--n);         /* TERMINATION PADDING */
   }
   return result;
}
farstrpbrk.c/   1146129406  0     0     0       582       `
/****************************************************************************/
/*  farstrpbrk v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strpbrk(const far char *s1, const far char *s2)
{
   for (; *s1; s1++)
   {
      const far char *check = s2;
 
      while (*check)
         if (*check++ == *s1) return (far char *)s1;
   }
   return NULL;
}


farstrrchr.c/   1146129406  0     0     0       523       `
/****************************************************************************/
/*  farstrrchr v4.1.3                                                        */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strrchr(const far char *s, int c)
{
   far char *result = NULL;
 
   do
      if (*s == c) result = (far char *)s;
   while (*s++);
 
   return(result);
}

farstrspn.c/    1146129406  0     0     0       1102      `
/****************************************************************************/
/*  farstrspn  v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

size_t far_strspn(const far char *s1, const far char *s2)
{
   const far char *check;
   size_t      count = 0;
 
   /*---------------------------------------------------------------------*/
   /* FOR EACH CHAR IN s1                                                 */
   /*---------------------------------------------------------------------*/
   for (; *s1; s1++, count++)
   {
      check = s2;
 
      /*-------------------------------------------------------------------*/
      /* QUIT WHEN FIND A CHAR IN s1 THAT IS NOT IN s2                     */
      /*-------------------------------------------------------------------*/
      do
         if (!*check) return count;
      while (*check++ != *s1);
   }
 
   return count;
}
farstrstr.c/    1146129406  0     0     0       1361      `
/****************************************************************************/
/*  farstrstr v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strstr(const far char *s1, const far char *s2)
{
   const far char *cmp;
   const far char *wpos;
 
   /*----------------------------------------------------------------------*/
   /* TRY EVERY POSITION IN THE CONTROL STRING                             */
   /*----------------------------------------------------------------------*/
   for (wpos = (far char *)s1; *s1; wpos = ++s1)
   {
      cmp = s2;
 
      do
      {
	 /*----------------------------------------------------------------*/
	 /* AT END OF COMPARISON STRING, MUST HAVE A MATCH OR EMPTY STRING */
	 /*----------------------------------------------------------------*/
	 if (!*cmp)  return (far char *)s1;
 
	 /*----------------------------------------------------------------*/
	 /* AT END OF CONTROL STRING, NO MATCH IS POSSIBLE                 */
	 /*----------------------------------------------------------------*/
	 if (!*wpos) return NULL;
 
      } while (*wpos++ == *cmp++);
   }
   return NULL;
}

farstrtod.c/    1146129406  0     0     0       3265      `
/****************************************************************************/
/*  farstrtod v4.1.3                                                         */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>

static const _DATA_ACCESS double far_powerof10[] = { 1.e1, 1.e2, 1.e4, 1.e8, 
								1.e16, 1.e32 };
static const _DATA_ACCESS double far_digits[]    = { 0, 1, 2, 3, 4, 
								5, 6, 7, 8, 9 };

double far_strtod(const far char *st, far char **endptr)
{
    double          result = 0;
    const far char *fst    = st;
    int             exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int             value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = (*fst == '-')) || *fst == '+') { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    while (_isdigit(*fst))
    {
       result = result * 10 + far_digits[*fst++ - '0']; 
       value  = 1;
    }

    if (*fst == '.')
    {
       ++fst;
       while (_isdigit(*fst)) 
       {
          result = result * 10 + far_digits[*fst++ - '0']; 
          value  = 1;
	  --exp;
       }
    }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       int i; /* DON'T LET EXPONENT OVERFLOW */

       if ((sign = (*++fst == '-')) || *fst == '+') ++fst;

       for (i = count = 0; _isdigit(*fst) && i < 3; i++)
	  { count *= 10; count += *fst++ - '0'; }

       while (_isdigit(*fst)) fst++;

       if (sign) exp -= count;
       else      exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > DBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }
       else if (exp < DBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }
       else if (exp < 0)
	  for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	     {  if (exp & 1) result /= far_powerof10[count]; }
       else
	  for (count = 0; exp; count++, exp >>= 1)
	     {  if (exp & 1) result *= far_powerof10[count]; }
    }

    if (endptr) *endptr = (far char *)(value ? fst : st);
    return result;
}

farstrtok.c/    1146129406  0     0     0       720       `
/****************************************************************************/
/*  farstrtok v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

far char *far_strtok(far char *s1, const far char *s2)
{
   static far char *last_end;
   far char        *start; 

   if (s1) last_end = s1;

   last_end += far_strspn(last_end, s2);
   if (*last_end == '\0') return (NULL);

   start = last_end;
   last_end += far_strcspn(last_end, s2);

   if (*last_end != '\0') *last_end++ = '\0'; 

   return start;
}

farstrtol.c/    1146129406  0     0     0       2854      `
/****************************************************************************/
/*  farstrtol v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

long far_strtol(const far char *st, far char **endptr, int base)
{
    register long            result = 0;
    register char        cp;
    register const far char *fst    = st;
    int                      digits = 0;
    int                  sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                         { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
                  break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(cp))
	             cp = *(fst += 2);
                  break;
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (far char *)st;       
	    return sign ? LONG_MIN : LONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (far char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }
        return -result;
    }
    return result;
}

farstrtold.c/   1146129406  0     0     0       3273      `
/****************************************************************************/
/*  farstrtod v4.1.3                                                         */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>

static const _DATA_ACCESS double far_powerof10[] = { 1.e1, 1.e2, 1.e4, 1.e8, 
								1.e16, 1.e32 };
static const _DATA_ACCESS double far_digits[]    = { 0, 1, 2, 3, 4, 
								5, 6, 7, 8, 9 };
long double far_strtold(const far char *st, far char **endptr)
{
    long double     result = 0;
    const far char *fst    = st;
    int             exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int             value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = (*fst == '-')) || *fst == '+') { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    while (_isdigit(*fst))
    {
       result = result * 10 + far_digits[*fst++ - '0']; 
       value  = 1;
    }

    if (*fst == '.')
    {
       ++fst;
       while (_isdigit(*fst)) 
       {
          result = result * 10 + far_digits[*fst++ - '0']; 
          value  = 1;
	  --exp;
       }
    }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       int i; /* DON'T LET EXPONENT OVERFLOW */

       if ((sign = (*++fst == '-')) || *fst == '+') ++fst;

       for (i = count = 0; _isdigit(*fst) && i < 3; i++)
	  { count *= 10; count += *fst++ - '0'; }

       while (_isdigit(*fst)) fst++;

       if (sign) exp -= count;
       else      exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > LDBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VALL : HUGE_VALL; }
       else if (exp < LDBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }
       else if (exp < 0)
	  for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	     {  if (exp & 1) result /= far_powerof10[count]; }
       else
	  for (count = 0; exp; count++, exp >>= 1)
	     {  if (exp & 1) result *= far_powerof10[count]; }
    }

    if (endptr) *endptr = (far char *)(value ? fst : st);
    return result;
}

farstrtoll.c/   1146129406  0     0     0       2871      `
/****************************************************************************/
/*  farstrtoll v4.1.3                                                       */
/*  Copyright (c) 2003-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>
#include <access.h>

_CODE_ACCESS 
long long far_strtoll(const far char *st, far char **endptr, int base)
{
    register long long       result = 0;
    register char            cp;
    register const far char *fst    = st;
    int                      digits = 0;
    int                      sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  } 
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(cp))
	             cp = *(fst += 2);
     }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (far char *)st; 
	    return sign ? LLONG_MIN : LLONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (far char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LLONG_MAX) { errno = ERANGE; return (LLONG_MIN); }
        return -result;
    }
    return result;
}


farstrtoul.c/   1146129406  0     0     0       2695      `
/****************************************************************************/
/*  farstrtoul v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

unsigned long far_strtoul(const far char *st, far char **endptr, int base)
{
    register unsigned long  result = 0;
    register char          cp;
    register const far char   *fst = st;
    int                     digits = 0;
    int                     minus  = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;
    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                         { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
	          break;
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (far char *)st;        
	    return ULONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (far char *)(digits ? fst : st);

    return minus ? -result : result;
}


farstrtoull.c/  1146129406  0     0     0       2712      `
/****************************************************************************/
/*  farstrtoull v4.1.3                                                      */
/*  Copyright (c) 2003-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

_CODE_ACCESS 
unsigned long long far_strtoull(const far char *st, far char **endptr,int base)
{
    register unsigned long long result = 0;
    register char               cp;
    register const far char    *fst = st;
    int                         digits = 0;
    int                         minus = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;
    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (far char *)st;        
	    return ULLONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (far char *)(digits ? fst : st);

    return minus ? -result : result;
}
farstrxfrm.c/   1146129406  0     0     0       709       `
/****************************************************************************/
/*  farstrxfrm v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stddef.h>
#include <string.h>

size_t far_strxfrm(far char *s1, const far char *s2, size_t n)
{
   const far char *sf    = s2;
   size_t          count = 0;     
 
   while (*sf++) count++;                    /* GET LENGTH OF STRING */
   if (n > count) n = count + 1;
 
   while (n-- != 0) *s1++ = *s2++;           /* COPY STRING         */
 
   return count;
}

fclose.c/       1146129406  0     0     0       3774      `
/*****************************************************************************/
/*  FCLOSE.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    Functions:                                                             */
/*       FCLOSE   -  Close a stream                                          */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>
#include <stdlib.h>

extern int _doflush(FILE *_fp);


/*****************************************************************************/
/* FCLOSE   -  Close a stream                                                */
/*                                                                           */
/*    This function flushes the current stream, deallocates any buffers      */
/*    associated with the stream, and closes it.  This function returns a 0  */
/*    if the close was successful, or an EOF if an error occured.            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fclose(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int fd = _fp->fd;
   int errchk;
   int remove_flag = _STCHK(_fp, _TMPFILE);

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Flush the buffer.                                                      */
   /*------------------------------------------------------------------------*/
   if(_doflush(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Free the buffer if there was one, and it was malloc'd by SETVBUF.      */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _BUFFALOC))
   {
      free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
   }

   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointers in the stream.                               */
   /*------------------------------------------------------------------------*/
   _fp->buf = NULL;
   _fp->pos = NULL;
   _fp->bufend = NULL;

   /*------------------------------------------------------------------------*/
   /* Close the file, and give the FILE structure an invalid file descriptor */
   /* so it cannot be used until it is assigned to another stream.           */
   /*------------------------------------------------------------------------*/
   errchk = close(_fp->fd);
   _fp->fd = -1;

   /*------------------------------------------------------------------------*/
   /* If the FILE pointer was associated with a temporary file, look up that */
   /* temporary file's filename, and remove it.                              */
   /*------------------------------------------------------------------------*/
   if(remove_flag) remove(_tmpnams[fd]);  

   return (errchk);
}

fcvt.c/         1146129406  0     0     0       3277      `
/****************************************************************************/
/*  fcvt v4.1.3                                                             */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <math.h>

#define MANTISSA_WORD 0
#define EXPONENT_WORD 1

/****************************************************************************/
/* THIS FUNCTION IS NON-STANDARD AND IS PROVIDED ONLY AS A BUILDING BLOCK   */
/* FOR PRINTF.                                                              */
/****************************************************************************/
char *fcvt(long double value, register int ndigit, int *decpt, int *sign)
{
    static char out[400]; 

    int   digits = 0;                  /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VALL OF PROPER SIGN     */
    /*--------------------------------------------------------------------*/
    {
       long *ptr = (long *)&value;

       if (((ptr[EXPONENT_WORD] >> 20) & 0x7ff) == 0x7ff)
          value = (ptr[EXPONENT_WORD] & 0x80000000) ? -HUGE_VALL : HUGE_VALL;
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos   += temp    = ltoa((long)value, pos);
    *decpt = digits + temp; 

    /* if (digits < 0) */ ndigit += digits;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (ndigit > 0) do
    {
         value -= (long)value;
         *pos++ = (int)(value *= 10.0) + '0';
    }
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) 
	{
	   if (pos > out) *pos   = 0;
	   else		  out[1] = 0;

           *decpt += 1;
	   return out;
	}
    }
	
    *pos = 0;
    return out + 1;
}


fd_add.asm/     1146129406  0     0     0       622       `
*;*****************************************************************************
*;                                                                            *
*;  FD_ADD v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$ADD - Add two IEEE 754 format double precision floating point numbers *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_add28.inc"
        .endif
fd_add28.inc/   1146129406  0     0     0       19756     `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_ADD v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$ADD - Add two IEEE 754 format double precision floating point numbers *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o INPUT OP2 IS IN *XAR5                  
;*   o RESULT IS RETURNED IN *XAR6
;*   o INPUT OP1 AND OP2 ARE PRESERVED                                 
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY
;*       (0x7ff00000:00000000) or (0xfff00000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF OPERATION INVOLVES INFINITY AS AN INPUT, THE FOLLOWING SUMMARIZES
;*     THE RESULT:
;*                   +----------+----------+----------+
;*         ADDITION  + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+
;*        + OP1 !INF +    -     |   -INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*               HI MEMORY                                                    *
;*                                                                            *
;*                 stack                            register file             *
;*           +----------------+                   +-------------------+       *
;*      SP-->|                |             XAR0  | OP1 hign mantissa |       *
;*           +----------------+                   +-------------------+       *
;*        -1 |    OP1_EXP     |             XAR1  | OP1 low mantissa  |       *
;*           +----------------+                   +-------------------+       *
;*        -2 |    OP2_EXP     |             XAR2  | OP2 high mantissa |       *
;*           +----------------+                   +-------------------+       *
;*     -3 -4 |     XAR3       |             XAR3  | OP2 low mantissa  |       *
;*           +----------------+                   +-------------------+       *
;*     -5 -6 |     XAR2       |             XAR4  |    PTR to OP1     |       *
;*           +----------------+                   +-------------------+       *
;*     -7 -8 |     XAR1       |             XAR5  |    PTR to OP2     |       *
;*           +----------------+                   +-------------------+       *
;*     -9 -10| Retrun addr    |             XAR6  |  PTR to RET VALUE |       *
;*           +----------------+                   +-------------------+       *
;*                                           AR7  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*               LO MEMORY                                                    *
;*                                                                            *
;*    NOTE: The ordering of the locals are placed to take advantage           *
;*          of long word loads and stores which require the hi and lo         *
;*          words to be at certain addresses. Any future modifications        *
;*          which involve the stack must take this quirk into account         *
;*                                                                            *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$ADD
        .sect     ".text"

FD$$ADD:	.asmfunc
	.asg	  XAR0,	   OP1_HM
	.asg	  XAR1,	   OP1_LM
	.asg	  XAR2,	   OP2_HM
	.asg	  XAR3,	   OP2_LM
        .asg       AR4,    RES_EXP 
        .asg       AR7,    RES_SIGN
	.asg	  XAR3,	   TMP32 
	.asg	   AR3,	   TMP16 
        .asg   *-SP[1],    OP1_EXP 
        .asg   *-SP[2],    OP2_EXP 

	.asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW
	.asg   *+XAR5[3],  OP2_SIGN
        .asg   *+XAR5[2],  OP2_MSW
        .asg   *+XAR5[0],  OP2_LSW
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of XAR0 - XAR3, and allocate stack space for locals    *
*;*****************************************************************************
*
        PUSH    XAR1
        PUSH    XAR2
        PUSH    XAR3
        ADDB    SP, #2            ; Allocate space for locals
*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
	MOVL	ACC, XAR6	  ;
	B	RETURN, EQ	  ; Return if return pointer is null
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 60 to 9                          *
*;  3. Add the implied one at bit 61                                          *
*;  4. Negate the value if sign bit is set                                    *
*;  5. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        MOV     RES_SIGN, OP1_SIGN    ; Save the sign
        UNPACK64   XAR4, OP1_EXP ; Unpack OP1 into OP1_EXP and ACC:P
        LSR64   ACC:P, 2        ; Allow room for sign and overflow 
        CMP     RES_SIGN, #0    ; Check if OP1 is negative  
        B       SAVE_MN1, GEQ   ;
        NEG64   ACC:P           ; Negate OP1 mantissa if OP1 is negative
SAVE_MN1:
	MOVL	OP1_HM, ACC	; Save OP1 hign mantissa 
	MOVL	OP1_LM, P	; Save OP1 low mantissa

*
*;*****************************************************************************
*;  Check OP1 for the following special cases.                                *
*;   - If exp is zero and mantissa is zero, OP1 is zero - return OP2          *
*;   - If exp is zero and mantissa is nonzero, OP1 is denormal - Underflow    *
*;   - If exp is 0x7FF OP1 is infinite or NaN - Overflow                      *
*;*****************************************************************************
*
	CMP	OP1_EXP, #0	; Check if OP1 exponent is zero
	B	EXP1_NZ, NEQ	; if OP1 exponent is not zero check for overflow
	LSL64	ACC:P, 3	; Check if mantissa is zero
	B	OP1_ZERO, EQ	; exp == 0 && mantissa == 0 so OP1 is zero;
				; return OP2.
	B	UNDERFLOW, UNC	; mantissa != 0 && exp == 0; Underflow for
				; Denormals.

EXP1_NZ:
	CMP	OP1_EXP, #0x7FF	; Check for infinity and NaN
	B	OVERFLOW, EQ    ; return overflow.
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP2_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 60 to 9                          *
*;  3. Add the implied one at bit 61                                          *
*;  4. Negate the value if sign bit is set                                    *
*;  5. Store mantissa in OP2_HM:OP2_LM                                        *
*;*****************************************************************************
*
        MOV     RES_SIGN, OP2_SIGN     ; Save the sign
        UNPACK64   XAR5, OP2_EXP ; Unpack OP1 into OP2_EXP and ACC:P
        LSR64   ACC:P, 2        ; Allow room for sign and overflow 
        CMP     RES_SIGN, #0    ; Check if OP1 is negative  
        B       SAVE_MN2, GEQ   ;
        NEG64   ACC:P           ; Negate OP1 mantissa if OP1 sign is negative
SAVE_MN2:
	MOVL	OP2_HM, ACC	; Save OP2 hign mantissa 
	MOVL	OP2_LM, P	; Save OP2 low mantissa
*
*;*****************************************************************************
*;  Check OP2 for the following special cases.                                *
*;   - If exp is zero and mantissa is zero, OP2 is zero - return OP2          *
*;   - If exp is zero and mantissa is nonzero, OP2 is denormal - Underflow    *
*;   - If exp is 0x7FF OP2 is infinite or NaN - Overflow                      *
*;*****************************************************************************
*
        CMP	OP2_EXP, #0 	; Check if OP2_EXP is zero
	B	EXP2_NZ, NEQ	; if OP2 exponent is not zero check for overflow
	LSL64	ACC:P, 3	; Check if mantissa is zero
	B	OP2_ZERO, EQ	; exp == 0 && mantissa == 0 so OP2 is zero; 
				; return OP1
      	B	UNDERFLOW, UNC	; mantissa != 0 && exp == 0; Underflow for
				; Denormals
EXP2_NZ:
	CMP	OP2_EXP, #0x7FF	; Check for infinity and NaN
	B	OVERFLOW, EQ    ; return overflow.
*
*;*****************************************************************************
*;  Compare exponents of OP1 and OP2 by subtracting: exp OP1 - exp OP2        *
*;  Branch to PREP_ADD for further processing if exp OP1 is greater than or   *
*;  equal to exp OP2. Otherwise swap OP1 and OP2 so that OP1 has larger value.*
*;*****************************************************************************
*
        MOV     AH, OP1_EXP      ; load OP1 exponent
        SUB     AH, OP2_EXP      ; Find OP1 exp - OP2 exp                 
	B	PREP_ADD, GEQ	 ; If OP1 >= OP2 proceed to adjust OP2 mantissa

	MOVL	P, OP1_LM	 ; Otherwise swap OP1 and OP2 so that OP1 has
	MOVL	OP1_LM, OP2_LM   ; larger value.
	MOVL	OP2_LM, P        ; 
	MOVL	P, OP1_HM	 ;                   
	MOVL	OP1_HM, OP2_HM   ; 
	MOVL	OP2_HM, P        ; 
;	MOV	OP1_EXP, OP2_EXP ; Move the OP2 exp to OP1 exp.
	MOVZ	AR5, OP2_EXP	 ; Move the OP2 exp to OP1 exp.
	MOV	OP1_EXP, AR5	 ;
	NEG	AH		 ; Since we swapped the operands, negate the
	              		 ; difference in the exponent.
*
*;*****************************************************************************
*;  Process the following exponent special cases:                             *
*;  1. If the exponents of OP1 and OP2 are same (exp_diff == 0) no need to    *
*;     align the mantissa; go directly to add the operands.                   *
*;  2. If exp_diff is greater than 53 (52 bit mantissa + 1 for implied one),  *
*;     then OP2 is insignificant so we do not need to add.                    *
*;  3. If 0 < exp_diff < 54, adjust the OP2 mantissa to align the exponents   *
*;*****************************************************************************
*
PREP_ADD:
	MOV	T, AH		; Load the exp_diff from AH
	MOVL	ACC, OP1_HM	; Load OP1 mantissa into ACC:P          
	MOVL	P, OP1_LM	; 
	CMP	T, #54		; Check exp_diff is less than 54    
	B	NO_ADD, GEQ	; If not go to processing after ADD 
	CMP	T, #0		; Check if exp_diff is zero 
	B	ADD_OP, EQ	; If so go directly to Add the operands 

	MOVL	ACC, OP2_HM	; Load OP2 mantissa into ACC:P
	MOVL	P, OP2_LM	;
	ASR64 	ACC:P, T	; Shift right OP2 mantissa by T bits 
	MOVL	OP2_HM, ACC	; Save adjusted OP2 mantissa 
	MOVL	OP2_LM, P	; 
	MOVL    P, OP1_LM	; Load OP1 mantissa into ACC:P 
	MOVL    ACC, OP1_HM	;

ADD_OP: 
	ADDUL   P, OP2_LM	; Add OP2 mantissa to OP1 mantissa 
	ADDCL   ACC, OP2_HM	; 

NO_ADD:
	CMP64	ACC:P		; Clear V flag
	CMP64	ACC:P		; Check if the result mantissa is zero
        B       RETURN_VALUE,EQ ; If result is zero, return the value.
*
*;*****************************************************************************
*;  Call NORMALIZE64 macro to normalize the value. This macro updates the     *
*;  OP1_EXP based on the normalization and returns the value in RES_EXP.      *
*;  The normalization includes the following:                                 *
*;    - Take the absolute value of the mantissa                               *
*;    - Left shift the mantissa so that the 63rd bit in ACC:P is 1.           *
*;    - Adjust the exponent by subtracting it by number of bits shifted out.  *
*;*****************************************************************************
*
        MOV     RES_SIGN, AH    ; save signed mantissa
	CMP64   ACC:P		; Clear V flag
	CMP64	ACC:P		; Get the absolute mantissa
	B	NORMALIZE, GEQ	;
	NEG64	ACC:P		; Negate if mantissa is negative, get abs value

NORMALIZE:
	MOVZ	RES_EXP, OP1_EXP	; Load the result exponent
	NORMALIZE64	RES_EXP, TMP16  ; The normalized mantissa is in ACC:P
*
*;*****************************************************************************
*;  Round the result mantissa to the nearest value by using ROUND64 macro.    *
*;*****************************************************************************
*
	ROUND64	RES_EXP, TMP32	;
*
*;*****************************************************************************
*;  Then place the mantissa in bits 52 - 0 and remove the implied one         *
*;  52 - 0 for packing.                                                       *
*;*****************************************************************************
*
        LSR64   ACC:P, #10      ; Shift the mantissa with imp 1 to bits 53-0
	AND     AH, #0x000F     ; Removed the implied one
*
*;*****************************************************************************
*;  Adjust the exponent and test result for underflow and overflow.           *
*;*****************************************************************************
*
	INC	RES_EXP         ; Adjust the exponent - this is corresponding 
				; to the right shift by 2 to allow room for 
				; sign and overflow.                          
        B       UNDERFLOW, LEQ  ; process underflow if occurs
        CMP     RES_EXP, #0x7FF ; check for overflow
        B       OVERFLOW, GEQ   ; process overflow if occurs
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
	PACK64	RES_SIGN, RES_EXP
*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop XAR0 - XAR3                                                           *
*;*****************************************************************************
*
* ACC:P - final result
*
RETURN_VALUE:
	MOVL	RES_LSW, P     ;
	MOVL	RES_MSW, ACC   ; Load the return value in the return area.

RETURN:
        SUBB    SP, #2
        POP     XAR3
        POP     XAR2
        POP     XAR1
        LRETR

        .page
*;*****************************************************************************
*;       OP1 << OP2  or OP1 = 0                                               *
*;*****************************************************************************
*
OP1_ZERO:
        MOVL    ACC, OP2_MSW    ; put OP2 as result into ACC:P
        MOVL    P,   OP2_LSW    ; put OP2 as result into ACC:P
        B       RETURN_VALUE,UNC

*
*;*****************************************************************************
*;       OP1 << OP2  or  OP1 = 0                                              *
*;*****************************************************************************
*
OP2_ZERO:
        MOVL    ACC, OP1_MSW    ; put OP1 as result into ACC:P
        MOVL    P,   OP1_LSW    ; put OP1 as result into ACC:P
        B       RETURN_VALUE,UNC

         .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC:P to 0xFFF0000:000000000 if sign is negative; otherwise set it to *
*;  0x7FF00000:00000000                                                       *
*;*****************************************************************************
*
OVERFLOW:
	OVERFLOW64	RES_SIGN
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
UNDERFLOW:
        ZAPA                    ; For underflow result (ACC:P)= 0
        B       RETURN_VALUE,UNC
	.endasmfunc
fd_cmp.asm/     1146129407  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  FD_CMP v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$CMP - Compare two IEEE 754 format double precision floating point     *
*;            numbers                                                         *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_cmp28.inc"
        .endif

fd_cmp28.inc/   1146129407  0     0     0       9874      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_CMP v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$CMP - Compare two IEEE 754 format double precision floating point     *
;*            numbers                                                         *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o INPUT OP2 IS IN *XAR5                  
;*   o RESULT IS RETURNED IN AL    
;*   o INPUT OP1 AND OP2 ARE PRESERVED                                 
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o +0 == -0  (This is not implemented yet)
;*
;*   o IF COMPUTING THE RESULT INVOLVES INFINITIES, THE FOLLOWING TABLE
;*     SUMMARIZES THE EFFECTIVE RESULT
;*                   +----------+----------+----------+
;*                   + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+
;*        + OP1 -INF +   -INF   |    -0    +   -INF   +
;*        +----------+----------+----------+----------+
;*        + OP1 +INF +   +INF   |   +INF   +    +0    +
;*        +----------+----------+----------+----------+
;*
;*   o THE RESULT OF THE COMPARE IS COMPUTED USING INTEGER SUBTRACT IF THE
;*     SIGN OF THE INPUTS IS THE SAME.  THE TABLE SUMMARIZES THE
;*     IMPLEMENTATION.
;*                 +-----------+-----------+
;*                 +   OP2 +   |   OP2 -   +
;*        +--------+===========+===========+
;*        + OP1 +  + OP1 - OP2 |    OP1    +
;*        +--------+-----------+-----------+
;*        + OP1 -  +    OP1    | OP2 - OP1 +
;*        +--------+-----------+-----------+
;*   
;*   o RETURN VALUE IN AL 
;*     OP1 > OP2  : return 1
;*     OP1 < OP2  : return -1
;*     OP1 == OP2 : return 0
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*               HI MEMORY                                                    *
;*                                                                            *
;*                 stack                            register file             *
;*           +----------------+                   +-------------------+       *
;*      SP-->|                |             XAR4  |   PTR TO OP1      |       *
;*           +----------------+                   +-------------------+       *
;*        -1 | (return addr)  |             XAR5  |   PTR TP OP2      |       *
;*           +----------------+                   +-------------------+       *
;*        -2 | (return addr)  |              AR7  |     RESULT        |       *
;*           +----------------+                   +-------------------+       *
;*                                                                            *
;*               LO MEMORY                                                    *
;*                                                                            *
;*    NOTE: The ordering of the locals are placed to take advantage           *
;*          of long word loads and stores which require the hi and lo         *
;*          words to be at certain addresses. Any future modifications        *
;*          which involve the stack must take this quirk into account         *
;*                                                                            *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$CMP
        .sect     ".text"

FD$$CMP:	.asmfunc
	.asg	   AR7,	   RESULT 

        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW
        .asg   *+XAR5[3],  OP2_SIGN
        .asg   *+XAR5[2],  OP2_MSW
        .asg   *+XAR5[0],  OP2_LSW
*
*;*****************************************************************************
*;      COMPARE THE OPERANDS AND SET THE RESULT                               *
*;  The 64 bit compare is done in two parts                                   *
*;    1. Compare most significant 32 bits of the operands (OP1_MS32, OP2_MS32)*
*;     - If OP1_MS32 > OP2_MS32, RESULT is 1                                  *
*;     - If OP1_MS32 < OP2_MS32, RESULT is -1                                 *
*;    2. If they are same do unsigned compare on the least significant 32 bits*
*;     - If OP1_LS32 > OP2_MS32, RESULT is 1                                  *
*;     - If OP1_LS32 < OP2_MS32, RESULT is -1                                 *
*;     - If the low 32 bits are also same, RESULT is 0                        *
*;                                                                            *
*; NOTE: The COND MOVB instruction cannot be used to load -1 to RESULT so the *
*;       following code loads 0, 1 or 2 for LT, EQ or GT respectively. The    *
*;       result will be decremented later by 1.                               *
*;*****************************************************************************
*
        MOVL    ACC, OP1_MSW    ; LOAD OP1 (MSW)

	MOV 	RESULT, #1     	; Set result to 0; change this if ops are diff 
	CMPL	ACC, OP2_MSW	;
	MOVB	RESULT, #2, GT  ; Set result to 1 if OP1 > OP2
	MOVB	RESULT, #0, LT  ; Set result to -1 if OP1 < OP2
	B	CHECK_INF, NEQ  ;
	MOVL	ACC, OP1_LSW	;
	CMPL	ACC, OP2_LSW	;
	MOVB	RESULT, #2, HI  ; Set result to 1 if OP1 > OP2
	MOVB	RESULT, #0, LO  ; Set result to -1 if OP1 < OP2
	B  	OP_EQUAL, EQ 	; Operands are same; return zero
*
*;*****************************************************************************
*;      HANDLE THE SPECIAL CASE OF INFINITY.                                  *
*;   If both the operands are infinity the signs determine the result.        *
*;*****************************************************************************
*
CHECK_INF:
	MOVL	ACC, OP1_MSW	; Restore OP1 MSW
	LSL	AH, 1		; Shift out the sign
	CMP	AH, #0xFFE0	;
	B	RETURN, LO 	; If OP1 is not infinite, the compare we did 
				; initially is valid. So return that value.

        ; OP1 is infinite, now check OP2
	MOVL	ACC, OP2_MSW	; Load OP2 MSW
	LSL	AH, 1		; Shift out sign
	CMP	AH, #0xFFE0	; 
	B	RETURN, LO	; If OP2 is not infinite, return the cmp result

	; Both ops are infinite check the sign 
	MOVL	ACC, OP1_MSW	;
	LSR	AH, 15		; Shift the sign bit to bit 0
	MOV	AL, OP2_SIGN	;
	LSR	AL, 15		; Shift the sign bit to bit 0
	SUB	AL, AH		; OP2 sign - OP1 sign is the result 
	LRETR			; Return
*
*;*****************************************************************************
*;      SET THE RESULT IN AL AND RETURN                                       *
*;  IF both inputs are negative negate the RESULT before returning.           *
*;*****************************************************************************
*
RETURN:
	DEC	RESULT		; Transform [0 1 2] tp [-1 0 1]
	SETC	SXM		; Set SXM mode correctly for the MOV
	MOV 	ACC, OP1_SIGN   ;
	MOV 	AL, RESULT	; Load the result into AL                
	AND	AH, OP2_SIGN	; Test if both the operands are negative
	B	NO_NEG, GEQ	; 
	NEG	AL 		; If both ops are negative, negate the result 
NO_NEG:
	LRETR

OP_EQUAL:
	MOVB	AL, #0		; Return 0 in AL
	LRETR
	.endasmfunc
fd_div.asm/     1146129407  0     0     0       622       `
*;*****************************************************************************
*;                                                                            *
*;  FD_DIV v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$DIV - IEEE 754 format double precision number division                *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_div28.inc"
        .endif
fd_div28.inc/   1146129407  0     0     0       17896     `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_DIV v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$DIV - IEEE 754 format double precision number division                *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o NUMERATOR IS IN *XAR4
;*   o DENOMINATOR IS IN *XAR5                   
;*   o QUOTIENT IS RETURNED IN *XAR6
;*   o INPUT NUMERATOR AND DENOMINATOR ARE PRESERVED                    
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY
;*       (0x7ff00000:00000000) or (0xfff00000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*   o IF NUMERATOR IS ZERO RETURN ZERO
;*   o IF NUMERATOR IS INFINITY RETURN INFINITY
;*   o DIVIDE BY ZERO OVERFLOWS
;*   o DIVIDE BY INFINITY UNDERFLOWS
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*               HI MEMORY                                                    *
;*                                                                            *
;*                 stack                            register file             *
;*           +----------------+                   +-------------------+       *
;*      SP-->|                |             XAR0  | NUM hign mantissa |       *
;*           +----------------+                   +-------------------+       *
;*        -1 |    NUM EXP     |             XAR1  | NUM low mantissa  |       *
;*           +----------------+                   +-------------------+       *
;*        -2 |    DEN EXP     |             XAR2  | DEN high mantissa |       *
;*           +----------------+                   +-------------------+       *
;*     -3 -4 |     XAR3       |             XAR3  | DEN low mantissa  |       *
;*           +----------------+                   +-------------------+       *
;*     -5 -6 |     XAR2       |             XAR4  |    PTR TO NUM     |       *
;*           +----------------+                   +-------------------+       *
;*     -7 -8 |     XAR1       |             XAR5  |    PTR TO DEN     |       *
;*           +----------------+                   +-------------------+       *
;*     -9 -10|  Return addr   |             XAR6  |  PTR TO QUOTIENT  |       *
;*           +----------------+                   +-------------------+       *
;*                                           AR7  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*               LO MEMORY                                                    *
;*                                                                            *
;*    NOTE: The ordering of the locals are placed to take advantage           *
;*          of long word loads and stores which require the hi and lo         *
;*          words to be at certain addresses. Any future modifications        *
;*          which involve the stack must take this quirk into account         *
;*                                                                            *
;*                                                                            *
;******************************************************************************
        .page
        .include  "fd_util28.inc"
        .global   FD$$DIV
        .sect     ".text"

FD$$DIV:	.asmfunc
        .asg      XAR0,    NUM_HM
        .asg      XAR1,    NUM_LM
        .asg      XAR2,    DEN_HM
        .asg      XAR3,    DEN_LM
        .asg      XAR3,    TMP32  
        .asg       AR4,    RES_EXP
        .asg       AR5,    CNT     
        .asg       AR7,    RES_SIGN
        .asg   *-SP[1],    TMP16  
	.asg   *-SP[1],    NUM_EXP
	.asg   *-SP[2],    DEN_EXP

	.asg   *+XAR4[3],  NUM_SIGN
        .asg   *+XAR4[2],  NUM_MSW
        .asg   *+XAR4[0],  NUM_LSW
	.asg   *+XAR5[3],  DEN_SIGN
        .asg   *+XAR5[2],  DEN_MSW
        .asg   *+XAR5[0],  DEN_LSW
	.asg   *+XAR6[2],  RES_HQ  
	.asg   *+XAR6[0],  RES_LQ  

*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of XAR1 - XAR3, and allocate stack space for locals    *
*;*****************************************************************************
*
        PUSH    XAR1
        PUSH    XAR2
        PUSH    XAR3
        ADDB    SP, #2            ; Allocate space for locals

*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
        MOVL    ACC, XAR6         ;
        B       RETURN, EQ        ; Return if return pointer is null
*
*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of NUM and DEN to determine sign of result.        *
*;*****************************************************************************
*
	MOV	RES_SIGN, DEN_SIGN
	MOV	AH, NUM_SIGN
	XOR	RES_SIGN, AH
*
*;*****************************************************************************
*;      UNPACK NUM INTO EXPONENT AND MANTISSA                                 *
*;  1. Extract the exponent in NUM_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 60 to 9                          *
*;  3. Add the implied one at bit 61                                          *
*;  4. Store mantissa in NUM_HM:NUM_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, NUM_EXP ; Unpack NUM
	LSR64	ACC:P, #10	; Move mantissa with implied one to bits 61-9
	MOVL	NUM_HM, ACC	; Store NUM mantissa
	MOVL	NUM_LM, P	;
*
*;*****************************************************************************
*;  Check NUM for the following special cases.                                *
*;   - If exp is zero NUM is zero or denormal - Underflow                     *
*;   - If exp is 0x7FF NUM is infinite or NaN - Overflow                      *
*;*****************************************************************************
*
	CMP	NUM_EXP, #0	;
	B	UNDERFLOW, EQ	; Underflow if NUM exponent is zero 

	CMP	NUM_EXP, #0x7FF	; 
	B	OVERFLOW, EQ	; Overflow if infinity or NaN; ie exp == 0x7FF
*
*;*****************************************************************************
*;      UNPACK NUM INTO EXPONENT AND MANTISSA                                 *
*;  1. Extract the exponent in DEN_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 61 to 10                         *
*;  3. Add the implied one at bit 62                                          *
*;  4. Store mantissa in DEN_HM:DEN_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR5, DEN_EXP ; Unpack DEN
	LSR64	ACC:P, #10	; Move mantissa with implied one to bits 62-9
	MOVL	DEN_HM, ACC	; Store DEN mantissa
	MOVL	DEN_LM, P	;
*
*;*****************************************************************************
*;  Check DEN for the following special cases.                                *
*;   - If exp is zero DEN is zero or denormal - Underflow                     *
*;   - If exp is 0x7FF DEN is infinite or NaN - Overflow                      *
*;*****************************************************************************
*
        CMP     DEN_EXP, #0     ;
        B       OVERFLOW, EQ    ; Overflow if DEN exponent is zero 

        CMP     DEN_EXP, #0x7FF ; 
        B       UNDERFLOW, EQ   ; Underflow if infinity or NaN; ie exp == 0x7FF
*
*;*****************************************************************************
*;  Subtract DEN_EXP from NUM_EXP and store in RES_EXP for later processing   *
*;*****************************************************************************
*
	MOV	AH, NUM_EXP	; Load Numerator exponent
	SUB	AH, DEN_EXP	; Subtract denominator exponent from it
	MOV	RES_EXP, AH	; Store the result in RES_EXP
*
*;*****************************************************************************
*;       DIVISION                                                             *
*;  Division is implemented by recursive subtraction. The following algorithm *
*;  is used.                                                                  *
*;  1. Zero out the Result Quotient (RES_QH:RES_QL or RES_Q)                  *
*;  2. Load 53 to CNT, the loop counter.                                      *
*;  3. If numerator mantissa (NUM_HM:NUM_LM or NUM_M) is less than            *
*;     denaminator mantissa (DEN_HM:DEN_LM or DEN_M) goto step 6.             *
*;  4. Set NUM_M to NUM_M - DEN_M.                                            *
*;  5. Left shift RES_Q by 1 and add 1. Then goto step 7.                     *
*;  6. Left shift RES_Q by 1.                                                 *
*;  7. Left shift NUM_M by 1.                                                 *
*;  8. If NUM_M is zero goto step 10.                                         *
*;  9. If CNT-- is zero goto step 3.                                          *
*; 10. If CNT is -1 left shift RES_Q by 10                                    *
*;     else left shift RES_Q by CNT + 10                                      *
*;                                                                            *
*;     The result quotient is in bits 63 - 11.                                *
*;                                                                            *
*;*****************************************************************************
*
	MOVB	ACC, #0		;
	MOVL	RES_HQ, ACC	; Zero out the Quotient RES_HQ:RES_LQ
	MOVL	RES_LQ, ACC	;
	MOV 	CNT, #53	; Load the loop count         
	MOVL	ACC, NUM_HM	; Load the NUM_M     
	MOVL	P, NUM_LM	;
DIV_START:   
	MOV	TMP16, #0	; Assume NUM_M < DEN_M and set TMP16 to 0
	CMPL	ACC, DEN_HM	; Test if NUM_M < DEN_M  
	B	$1, NEQ		;
	MOVL	ACC, P
	CMPL	ACC, DEN_LM	;
$1:	B	$2, LO		; If NUM_M < DEN_M go to $2 
	MOVL	ACC, NUM_LM	; Subtract DEN_M from NUM_M                 
	SUBUL	ACC, DEN_LM	;
	MOVL	NUM_LM, ACC	; and store the result back in NUM_M
	MOVL	ACC, NUM_HM	;
	SUBBL	ACC, DEN_HM	;
	MOVL	NUM_HM, ACC	;  
	MOV 	TMP16, #1	; Set TMP16 to 1 to indicate NUM_M > DEN_M
$2:
	MOVL	ACC, RES_HQ	; Left shift the quotient in RES_HQ:RES_LQ by 1
	MOVL	P,   RES_LQ	;
	LSL64	ACC:P, #1	;
	MOVL	RES_HQ, ACC	; 
	MOVL	ACC, P		;
	ADD     AL, TMP16	; and add TMP16 to it
	MOVL	RES_LQ, ACC  	; Store the quotient back in RES_HQ:RES_LQ
	
        MOVL    ACC, NUM_HM     ; Load NUM_M into ACC:P
	MOVL    P, NUM_LM       ;
	LSL64	ACC:P, #1	; Left shift NUM_M by 1
	MOVL	NUM_HM, ACC	; Store NUM_M            
	MOVL	NUM_LM, P	; 
	B	DIV_END, EQ	; If NUM_M become zero, exit the loop.
	BANZ	DIV_START, CNT--; Continue the loop till --CNT becomes zero.
*
*;*****************************************************************************
*;  Move the quotient to bits 63 - 11 and normalize.                          *
*;*****************************************************************************
*
DIV_END:
	INC	CNT		; If ++CNT 
	B       NORMALIZE, NEQ	; is not zero add 9 to CNT
	INC	CNT		; else (++CNT is zero), add 10 to CNT
NORMALIZE:
	ADD 	CNT, #9		; 
	MOV	T, CNT		; 
	MOVL	ACC, RES_HQ	; Load the result quotient to ACC:P            
	MOVL	P,   RES_LQ	;
	LSL64	ACC:P, T	; Shift RES_Q by required number of bits 
	B	ROUND, LT 	; If the MSB of RES_Q is 0 
	LSL64	ACC:P, 1	; shift left RES_Q by 1 and 
	DEC	RES_EXP		; adjust the exponent.
*
*;*****************************************************************************
*;  Round the result mantissa to the nearest value by using ROUND64 macro.    *
*;*****************************************************************************
*
ROUND:
	LSR64	ACC:P, 1	; Move the results to 62 - 10 for rounding.
        ROUND64 RES_EXP, TMP32  ; Round the result
*
*;*****************************************************************************
*;  Then place the mantissa in bits 52 - 0 and remove the implied one         *
*;  for packing.                                                              *
*;*****************************************************************************
*
        LSR64   ACC:P, #10      ; Shift the mantissa with imp 1 to bits 53-0
        AND     AH, #0x000F     ; Removed the implied one
*
*;*****************************************************************************
*;  Adjust the bias by adding 1023 to the exponent and check for underflow    *
*;  and overflow.                                                             *
*;*****************************************************************************
*
	ADD	RES_EXP, #0x3FF
	B	UNDERFLOW, LEQ
	CMP	RES_EXP, #0x7FF
	B	OVERFLOW, GEQ
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
	PACK64	RES_SIGN, RES_EXP

*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop XAR1 - XAR3                                                           *
*;*****************************************************************************
*
* ACC:P - final result
*
RETURN_VALUE:
        MOVL    RES_LQ, P     ;
        MOVL    RES_HQ, ACC   ; Load the return value in the return area.
RETURN:
        SUBB    SP, #2
        POP     XAR3
	POP	XAR2
	POP	XAR1
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC:P to 0xFFF0000:000000000 if sign is negative; otherwise set it to *
*;  0x7FF00000:00000000                                                       *
*;*****************************************************************************
*
OVERFLOW:
        OVERFLOW64      RES_SIGN
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
UNDERFLOW:
        ZAPA                    ; For underflow result (ACC:P)= 0
        B       RETURN_VALUE,UNC
	.endasmfunc
fd_mpy.asm/     1146129407  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  FD_MPY v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$MPY - Multiply two IEEE 754 format double precision floating point    *
*;            numbers                                                         *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_mpy28.inc"
        .endif

fd_mpy28.inc/   1146129407  0     0     0       17946     `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_MPY v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$MPY - Multiply two IEEE 754 format double precision floating point    *
;*            numbers                                                         *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o INPUT OP2 IS IN *XAR5
;*   o RESULT IS RETURNED IN *XAR6
;*   o INPUT OP1 AND OP2 ARE PRESERVED
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY
;*       (0x7ff00000:00000000) or (0xfff00000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF THE OPERATION INVOLVES INFINITY OR ZERO AS INPUT, FIRST OPERAND     
;*     DETERMINES THE RESULT AS FOLLOWS:                                    
;*        INFINITY * ANYTHING = INF   (SIGN DETERMINED AS USUAL)
;*        0        * ANYTHING = UNDERFLOW - RETURN ZERO
;*        DENORMAL * ANYTHING = UNDERFLOW - RETURN ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*               HI MEMORY                                                    *
;*                                                                            *
;*                 stack                            register file             *
;*           +----------------+                   +-------------------+       *
;*      SP-->|                |             XAR0  | OP1 hign mantissa |       *
;*           +----------------+                   +-------------------+       *
;*        -1 |    OP1_EXP     |             XAR1  | OP1 low mantissa  |       *
;*           +----------------+                   +-------------------+       *
;*        -2 |    OP2_EXP     |             XAR2  | OP2 high mantissa |       *
;*           +----------------+                   +-------------------+       *
;*     -3 -4 |     XAR3       |             XAR3  | OP2 low mantissa  |       *
;*           +----------------+                   +-------------------+       *
;*     -5 -6 |     XAR2       |             XAR4  |    PTR TO OP1     |       *
;*           +----------------+                   +-------------------+       *
;*     -7 -8 |     XAR1       |             XAR5  |    PTR TO OP2     |       *
;*           +----------------+                   +-------------------+       *
;*     -9 -10|  Retrun addr   |             XAR6  |   PTR TO RESULT   |       *
;*           +----------------+                   +-------------------+       *
;*                                           AR7  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*               LO MEMORY                                                    *
;*                                                                            *
;*    NOTE: The ordering of the locals are placed to take advantage           *
;*          of long word loads and stores which require the hi and lo         *
;*          words to be at certain addresses. Any future modifications        *
;*          which involve the stack must take this quirk into account         *
;*                                                                            *
;*                                                                            *
;******************************************************************************
        .page
        .include  "fd_util28.inc"
        .global   FD$$MPY
        .sect     ".text"

FD$$MPY:	.asmfunc
        .asg      XAR0,    OP1_HM
        .asg      XAR1,    OP1_LM
        .asg      XAR2,    OP2_HM
        .asg      XAR3,    OP2_LM
        .asg      XAR3,    TMP32  
        .asg       AR4,    RES_EXP
        .asg       AR7,    RES_SIGN
        .asg   *-SP[1],    OP1_EXP
        .asg   *-SP[2],    OP2_EXP

        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW
        .asg   *+XAR5[3],  OP2_SIGN
        .asg   *+XAR5[2],  OP2_MSW
        .asg   *+XAR5[0],  OP2_LSW
        .asg   *+XAR6[2],  RES_H
        .asg   *+XAR6[0],  RES_L

*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of XAR1 - XAR3, and allocate stack space for locals    *
*;*****************************************************************************
*
        PUSH    XAR1
        PUSH    XAR2
        PUSH    XAR3
        ADDB    SP, #2            ; Allocate space for locals

*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
        MOVL    ACC, XAR6         ;
        B       RETURN, EQ        ; Return if return pointer is null
*
*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of OP1 and OP2 to determine sign of result.        *
*;*****************************************************************************
*
	MOV	RES_SIGN, OP2_SIGN
        MOV     AH, OP1_SIGN
	XOR	RES_SIGN, AH
*
*;*****************************************************************************
*;      UNPACK OP1 INTO EXPONENT AND MANTISSA                                 *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  4. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, OP1_EXP ; Unpack OP1
	MOVL	OP1_HM, ACC	; Save OP1 high mantissa 
	MOVL	OP1_LM, P	; Save OP1 low mantissa 
*
*;*****************************************************************************
*;  Check OP1 for the following special cases.                                *
*;   - If exp is zero OP1 is zero or denormal - Underflow                     *
*;   - If exp is 0x7FF OP1 is infinite or NaN - Overflow                      *
*;*****************************************************************************
*
	CMP	OP1_EXP, #0	;
	B	UNDERFLOW, EQ	; Underflow if OP1 exponent is zero 

	CMP	OP1_EXP, #0x7FF	; 
	B	OVERFLOW, EQ	; Overflow if infinity or NaN; ie exp == 0x7FF
*
*;*****************************************************************************
*;      UNPACK OP1 INTO EXPONENT AND MANTISSA                                 *
*;  1. Extract the exponent in OP2_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  4. Store mantissa in OP2_HM:OP2_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR5, OP2_EXP ; Unpack OP2
	MOVL	OP2_HM, ACC	; Save OP2 high mantissa 
	MOVL	OP2_LM, P	; Save OP2 low mantissa 
*
*;*****************************************************************************
*;  Check OP2 for the following special cases.                                *
*;   - If exp is zero OP2 is zero or denormal - Underflow                     *
*;   - If exp is 0x7FF OP2 is infinite or NaN - Overflow                      *
*;*****************************************************************************
*
        CMP     OP2_EXP, #0     ;
        B       UNDERFLOW, EQ   ; Underflow if OP2 exponent is zero 

        CMP     OP2_EXP, #0x7FF ; 
        B       OVERFLOW, EQ    ; Overflow if infinity or NaN; ie exp == 0x7FF
*
*;*****************************************************************************
*;  Add the exponents and store in RES_EXP for later processing               *
*;*****************************************************************************
*
	MOV	AH, OP1_EXP	  ; Load OP1 exponent
	ADD	AH, OP2_EXP	  ; Add OP2 exponent to it
	MOV	RES_EXP, AH	  ; Store the result
*
*;*****************************************************************************
*;       MULTIPLICATION                                                       *
*;  Multiplication is implemented by parts.  Mantissa for OP1 is in 64 bits   *
*;  represented by two 32 bit registers say A and B. And mantissa for OP2 is  *
*;  in two 32 bit registers say C and D. Then                                 *
*;                                                                            *
*;                          A    B      (mantissa of OP1)                     *
*;                   x      C    D      (mantissa of OP2)                     *
*;                     ===========                                            *
*;                             B*D      <-- Use only upper 32 bits of result  *
*;                           A*D                                              *
*;                           B*C                                              *
*;                         A*C                                                *
*;                     ===========                                            *
*;                        result        <-- result is always the upper 64 bits*
*;                                          of the possible 128 bits          *
*;  We need only the upper 64 bits of the possible 128 bit multiplication     *
*;  result. The upper 64 bits are calculated as follows.                      *
*;                                                                            *
*;  H64(A:B*C:D) = H32(A*D) + H32(B*C) + A64(A*C) + C                         *
*;  C = H32( H32(B*D) + L32(A*D) + L32(B*C) )                                 *
*;  Where H32 means High 32 bits of the 64 bit value                          *
*;        L32 means Low 32 bits of the 64 bit value                           *
*;        L32 means Low 32 bits of the 64 bit value                           *
*;        A64 means All 64 bits of the 64 bit value                           *
*;  Note that C is the carry of doing 32 bit addition of three 32 bit values  *
*;                                                                            *
*;*****************************************************************************
*
	ZAPA			; Zero out ACC, P and OVC
	MOVL	XT, OP2_LM	;      
	QMPYUL	P, XT, OP1_LM	; P = H32(B*D)
	MOVL	ACC, P		; ACC = H32(B*D)
	IMPYL	P, XT, OP1_HM	; P = L32(A*D)
	ADDUL	ACC, P		; ACC = L32(H32(B*D)+L32(A*D)); OVC has H32
	MOVL	XT, OP1_LM
	IMPYL	P, XT, OP2_HM	; P = L32(B*C)
	ADDUL	ACC, P		; OVC = H32(H32(B*D) + L32(A*D) + L32(B*C))
	MOVU	AL, OVC		; Move C to ACC
	MOVB	AH, #0

	ZAP	OVC		; Zero out OVC
	MOVL	XT, OP1_LM	; 
	QMPYUL	P, XT, OP2_HM	; P = H32(B*C)
	ADDUL	ACC, P		; ACC = H32(B*C) + C
	MOVL	XT, OP1_HM	; 
	QMPYUL	P, XT, OP2_LM	; P = H32(A*D)
	ADDUL	ACC, P		; ACC = H32(A*D) + H32(B*C) + C
	IMPYL	P, XT, OP2_HM	; P = L32(A*C)
	ADDUL	ACC, P		; ACC = L32(L32(A*C) + H32(A*D) + H32(B*C) + C)
	MOVL	RES_L, ACC	; Store L32(result)
	MOVU	AL, OVC		; ACC = H32(L32(A*C) + H32(A*D) + H32(B*C) + C)
	MOVB	AH, #0		;
	QMPYUL	P, XT, OP2_HM	; P = H32(A*C)
	ADDUL	ACC, P		; ACC = H32(result)
	MOVL	RES_H, ACC	; Store H32(result)
*
*;*****************************************************************************
*;  Adjust the mantissa if MSB in bit 63 for further processing.              *
*;*****************************************************************************
*
	MOVL	P, RES_L	; Restore result in ACC:P for rounding
	B	ROUND, GEQ	; Round the value if MSB is not in bit 63 
	LSR64	ACC:P, #1	; Adjust the mantissa 
	INC	RES_EXP		; Adjust the exponent
*
*;*****************************************************************************
*;  Round the result mantissa to the nearest value by using ROUND64 macro.    *
*;*****************************************************************************
*
ROUND:
        ROUND64 RES_EXP, TMP32  ;
*
*;*****************************************************************************
*;  Then place the mantissa in bits 52 - 0 and remove the implied one         *
*;  52 - 0 for packing.                                                       *
*;*****************************************************************************
*
        LSR64   ACC:P, #10      ; Shift the mantissa with imp 1 to bits 53-0
        AND     AH, #0x000F     ; Removed the implied one
*
*;*****************************************************************************
*;  Adjust the bias by subtracting 1023 from the exponent and check for       *
*;  underflow and overflow.                                                   *
*;*****************************************************************************
*
	SUB	RES_EXP, #0x3FF
	B	UNDERFLOW, LEQ
	CMP	RES_EXP, #0x7FF
	B	OVERFLOW, GEQ
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
	PACK64	RES_SIGN, RES_EXP

*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop XAR1 - XAR3                                                           *
*;*****************************************************************************
*
RETURN_VALUE:
        MOVL    RES_L, P     ;
        MOVL    RES_H, ACC   ; Load the return value in the return area.
RETURN:
        SUBB    SP, #2
        POP     XAR3
	POP	XAR2
	POP	XAR1
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC:P to 0xFFF0000:000000000 if sign is negative; otherwise set it to *
*;  0x7FF00000:00000000                                                       *
*;*****************************************************************************
*
OVERFLOW:
        OVERFLOW64      RES_SIGN
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
UNDERFLOW:
        ZAPA                    ; For underflow result (ACC:P)= 0
        B       RETURN_VALUE,UNC
	.endasmfunc

fd_neg.asm/     1146129407  0     0     0       622       `
*;*****************************************************************************
*;                                                                            *
*;  FD_NEG v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$NEG - Negate an IEEE 754 format double precision floating point number*
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_neg28.inc"
        .endif
fd_neg28.inc/   1146129407  0     0     0       3880      `

        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_NEG v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$NEG - Negate an IEEE 754 format double precision floating point number*
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN *XAR6
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
        .page
        .global   FD$$NEG
        .sect     ".text"

FD$$NEG:	.asmfunc
        .asg   *+XAR4[3],  OP_SIGN
        .asg   *+XAR4[2],  OP_MSW
        .asg   *+XAR4[0],  OP_LSW
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*; Handle the special case of zero                                            *
*;*****************************************************************************
*
	MOVL	ACC, OP_MSW		; Load the operand into ACC:P
	MOVL	P  , OP_LSW		;
	CMP64	ACC:P			; Check for zero
	B	RETURN, EQ		; Do not negate if zero; 
*
*;*****************************************************************************
*; Negate the operand and return                                              *
*;*****************************************************************************
*
	XOR	AH, #0x8000 		; Negate the operand
RETURN:
	MOVL	RES_MSW, ACC		; Load the return value
	MOVL	RES_LSW, P  		;
	LRETR                                            
	.endasmfunc
fd_sub.asm/     1146129407  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  FD_SUB v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$SUB - Subtract an IEEE 754 format double precision floating point     *
*;            number from another                                             *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_sub28.inc"
        .endif

fd_sub28.inc/   1146129407  0     0     0       6716      `

        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_SUB v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$SUB - Subtract an IEEE 754 format double precision floating point     *
;*            number from another                                             *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o INPUT OP2 IS IN *XAR5
;*   o RESULT IS RETURNED IN *XAR6
;*
;*   o SUBTRACTION, OP1 - OP2, IS IMPLEMENTED WITH ADDITION, OP1 + (-OP2)
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY
;*       (0x7ff00000:00000000) or (0xfff00000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF OPERATION INVOLVES INFINITY AS AN INPUT, THE FOLLOWING SUMMARIZES
;*     THE RESULT:
;*
;*                   +----------+----------+----------+
;*       SUBTRACTION + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*               HI MEMORY                                                    *
;*                                                                            *
;*                 stack                                                      *
;*           +----------------+                                               *
;*      SP-->|                |                                               *
;*           +----------------+                                               *
;*     -1 -2 |  -VE OP2 MSW   |                                               *
;*           +----------------+                                               *
;*     -3 -4 |  -VE OP2 LSW   |                                               *
;*           +----------------+                                               *
;*     -5 -6 |  Return addr   |                                               *
;*           +----------------+                                               *
;*                                                                            *
;*               LO MEMORY                                                    *
;*                                                                            *
;*    NOTE: The ordering of the locals are placed to take advantage           *
;*          of long word loads and stores which require the hi and lo         *
;*          words to be at certain addresses. Any future modifications        *
;*          which involve the stack must take this quirk into account         *
;*                                                                            *
;*                                                                            *
;******************************************************************************
        .page
        .global   FD$$SUB
        .global   FD$$ADD
        .sect     ".text"

FD$$SUB:	.asmfunc
	.asg   *-SP[1],    OP2_SIGN
        .asg   *-SP[2],    OP2_MSW
        .asg   *-SP[4],    OP2_LSW
        .asg   *+XAR5[2],  IN2_MSW
        .asg   *+XAR5[0],  IN2_LSW


	ADDB	SP, #4

	MOVL	ACC, IN2_MSW 	  ; Load OP2 (*XAR5) to the stack
	MOVL	OP2_MSW, ACC
	MOVL	ACC, IN2_LSW
	MOVL	OP2_LSW, ACC
*
*;*****************************************************************************
*; Negate the second operand and call ADD                                     *
*;*****************************************************************************
*
	XOR	OP2_SIGN, #0x8000 ; Negate second operand
	MOVZ	AR5, SP		  ;
	SUBB	XAR5, #4	  ;
	MOVZ	AR5, AR5 	  ; Load the address of OP2 (-ve input 2)
	LCR     FD$$ADD           ; Call ADD routine

	SUBB	SP, #4
	LRETR			  ; Return
	.endasmfunc
fd_tofs.asm/    1146129407  0     0     0       705       `
*;*****************************************************************************
*;                                                                            *
*;  FD_TOFS v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$TOFS - Convert an IEEE 754 format double precision floating point     *
*;             number to 754 format single precision floating point number    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_tofs28.inc"
        .endif

fd_tofs28.inc/  1146129407  0     0     0       8863      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_TOFS v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$TOFS  - Convert an IEEE 754 format double precision floating point    *
;*              number to 754 format single precision floating point number   *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN ACC  
;*   o P IS DESTROYED                 
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7F800000/FF800000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |   32-bit representation                                      |
;* |   31 30    23 22                    0                        |
;* |   +-+--------+-----------------------+                       |
;* |   |S|    E   |           M           +                       |
;* |   +-+--------+-----------------------+                       |
;* |                                                              |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE             |
;* |                               1 - NEGATIVE VALUE             |
;* |                                                              |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0            |
;* |                         01...FE - EXPONENT VALUE (127 BIAS)  |
;* |                              FF - INFINITY                   |
;* |                                                              |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                          XAR4  |    PTR TO OP1     |       *
;*                                                +-------------------+       *
;*                                           AR4  |     RES_EXP       |       *
;*                                                +-------------------+       *
;*                                           AR6  |     RES_SIGN      |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$TOFS
        .sect     ".text"

FD$$TOFS:	.asmfunc
        .asg       AR4,    RES_EXP
        .asg       AR6,    RES_SIGN
        .asg   *+XAR4[3],  OP_SIGN
        .asg   *+XAR4[2],  OP_MSW
        .asg   *+XAR4[0],  OP_LSW

*
*;*****************************************************************************
*;      SAVE SIGN OF INPUT                                                    *
*;*****************************************************************************
*
        MOV     RES_SIGN, OP_SIGN ; Save the sign
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in RES_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the rounding constant to mantissa and adjust the exponent if needed*
*;*****************************************************************************
*
	MOVL	ACC, OP_MSW	;
	MOVL	P, OP_LSW	; Load OP to ACC:P

	LSL64	ACC:P, 1	; Shift out the sign bit
	LSR64	ACC:P, 5	; Shift so that AH has exp and AL:P has mantissa

	MOV	RES_EXP, AH	; Store the result exponent

	LSL64	ACC:P, 16	; Move SP mantissa to bits 31 to 9 of ACC
	LSR64	ACC:P, #1	; Clear the MSB to capture the overflow.
	ADDB 	ACC, #0x80	; Add 1/2 for rounding   

	B	EXP_EVAL, GEQ	; If rounding generates carry,
	AND	AH, #0x7FFF	; Clear the carry bit.
	INC	RES_EXP		; and increment the exponent 

*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent for underflow and overflow.                             *
*;*****************************************************************************
*
EXP_EVAL:
	LSR64	ACC:P, 15 	; Move the Mantiss to AL:P so that AH is free 

	MOV	AH, RES_EXP	; Restore exponent
	SUB	AH, #0x380	; Adjust the bias
	B	UNDERFLOW, LT	; If single precision biased exp is < 0
				; underflow
	CMP	AH, #0xFF	; If single precision biased exp is > 0xFF,
	B	OVERFLOW, GT	; overflow

	LSL64	ACC:P, 7	; Shift the exponent and mantissa into ACC 
	AND	RES_SIGN, #0x8000 ; Mask the sign bit
	OR	AH, RES_SIGN	; Set the sign bit

RETURN_VALUE:
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC to 0x8000:0000 if sign is negative; otherwise to 0x7fff:ffff      *
*;*****************************************************************************
*
OVERFLOW:
	AND	AH, RES_SIGN, #0x8000 ;
	OR	AH, #0x7F80	;
	MOVB	AL, #0		;
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC to 0x0000:0000                                                    *
*;*****************************************************************************
*
UNDERFLOW:
        MOVB	ACC, #0           ; For underflow result in ACC = 0
        B       RETURN_VALUE,UNC
	.endasmfunc

fd_toi.asm/     1146129407  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  FD_TOI v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$TOI - Convert an IEEE 754 format double precision floating point      *
*;            number into a signed 16 bit integer                             *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_toi28.inc"
        .endif

fd_toi28.inc/   1146129407  0     0     0       7705      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_TOI v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$TOI  - Convert an IEEE 754 format double precision floating point     *
;*             number into a signed 16 bit integer			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN AL   
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS SATURATED VALUES (0x7fff or 0x8000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x0000)
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                          XAR4  |   PTR TO OP1      |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | OP1 EXP  |       *
;*                                                +-------------------+       *
;*                                           AR6  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$TOI
        .sect     ".text"

FD$$TOI:	.asmfunc
	.asg	   AR5,	   OP1_EXP
        .asg       AR6,    RES_SIGN
        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW

*
*;*****************************************************************************
*;      SAVE SIGN OF OP                                                       *
*;*****************************************************************************
*
        MOV     RES_SIGN, OP1_SIGN ; Save the sign
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  5. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, OP1_EXP ; Unpack OP1 into OP1_EXP and ACC:P

*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 03FFh; 03FFh is the exponent for integer value 1.  *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 040Dh; 040Dh is the exponent for integer values    *
*;             in the absolute range from 1073741824 to 2147483648.           *
*;             Result returned is 7FFFh or 8000h                              *
*;    Case 3:  exponents in the range of 03FFh to 040Dh inclusive will result *
*;             in 16-bit signed integer values from -32767 to +32767          *
*;*****************************************************************************
*

	SUB	OP1_EXP, #0x3FF	; if exponent is < 0x3FF, underflow
	B	UNDERFLOW, LT	;

	MOVB	AL, #15		; Subtract exponent from 15 to find shift value
				; for denormalization. 
	SUB	AL, OP1_EXP	; If unbiased exponent is >= 15, overflow. That
	B	OVERFLOW, LEQ	; is, overflow if shift value in AH is negative 
				; or zero
	MOV	T, AL  		; Move the shift value to T for denormalization
	LSR 	AH, T		; Denormalize 
	MOV	AL, AH		; Get ready to return the value

	CMP	RES_SIGN, #0	; If input is negative,     
	B	RETURN_VALUE, GEQ	
	NEG	AL 		;
  
RETURN_VALUE:
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set AL to 0x8000 if sign is negative; otherwise to 0x7fff                 *
*;*****************************************************************************
*
OVERFLOW:
	MOV	AL, #0x7fff	; Load AL with positive saturation value
	MOV	AH, RES_SIGN	;
	B	RETURN_VALUE, GEQ
	MOV 	AL, #0x8000 	; Load AL with negative saturation value 
	B	RETURN_VALUE, UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set AL to 0x0000                                                          *
*;*****************************************************************************
*
UNDERFLOW:
        MOVB	AL, #0           ; For underflow result in AL = 0
        B       RETURN_VALUE,UNC
	.endasmfunc


fd_tol.asm/     1146129407  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  FD_TOL v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$TOL - Convert an IEEE 754 format double precision floating point      *
*;            number into a signed 32 bit integer                             *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_tol28.inc"
        .endif

fd_tol28.inc/   1146129407  0     0     0       8207      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_TOL v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$TOL  - Convert an IEEE 754 format double precision floating point     *
;*             number into a signed 32 bit integer			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN ACC  
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS SATURATED VALUES (0x7fffffff or 0x80000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                          XAR4  | POINTER TO INPUT  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | OP1 EXP  |       *
;*                                                +-------------------+       *
;*                                           AR6  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$TOL
        .sect     ".text"

FD$$TOL:	.asmfunc
        .asg       AR5,    OP1_EXP
        .asg       AR6,    RES_SIGN
        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW

*
*;*****************************************************************************
*;      SAVE SIGN OF INPUT                                                    *
*;*****************************************************************************
*
        MOV     RES_SIGN, OP1_SIGN  ; Save the sign
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  5. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, OP1_EXP ; Unpack OP1 into OP1_EXP and ACC:P
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 03FFh; 03FFh is the exponent for integer value 1.  *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 041Dh; 041Dh is the exponent for integer values    *
*;             in the absolute range from 1073741824 to 2147483648.           *
*;             Result returned is 7FFFFFFFh or 80000000h                      *
*;    Case 3:  exponents in the range of 03FFh to 041Dh inclusive will result *
*;             in 32-bit signed integer values from -2MB to +2MB              *
*;*****************************************************************************
*
	SUB	OP1_EXP, #0x3FF	; if exponent is < 0x3FF, underflow
	B	UNDERFLOW, LT	;

	MOV 	PH, AH 		; Save Mantissa Hi16 
	MOVB	AH, #31		; Subtract exponent from 31 to find shift value
				; for denormalization. 
	SUB	AH, OP1_EXP	; If unbiased exponent is >= 31, overflow. That
	B	OVERFLOW, LEQ	; is overflow, if shift value in AH is negative 
				; or zero.
	MOV	T, AH  		; Move the shift value to T for denormalization
	MOV	AH, PH		; Restore Mantissa Hi16
	LSRL	ACC, T		; Denormalize 

	CMP	RES_SIGN, #0	; If input is negative,     
	B	RETURN_VALUE, GEQ	
	NEG	ACC		; NEG will not overflow due to the LSRL
  
RETURN_VALUE:
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC to 0x8000:0000 if sign is negative; otherwise to 0x7fff:ffff      *
*;*****************************************************************************
*
OVERFLOW:
	MOV	OVC, RES_SIGN	; Load OVC with bits 15-10 of RES_SIGN, which
				; is sign bit and 5 MSB of exponent 
	SAT	ACC		; If OVC > 0 ACC = 0x7fff:ffff
				; else if OVC < 0, ACC = 0x8000:0000 
				; When OVC = 0, ACC is not modified. For this 
				; case to happen, 5 MSBs of exp should be zero
				; which means the exponent is less than 0x3FF 
				; and should have been underflowed.           
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC to 0x0000:0000                                                    *
*;*****************************************************************************
*
UNDERFLOW:
        MOVB	ACC, #0           ; For underflow result in ACC = 0
        B       RETURN_VALUE,UNC
	.endasmfunc


fd_toll.asm/    1146129407  0     0     0       363       `
******************************************************************************
* fd_toll.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_toll28.inc"
        .endif

fd_toll28.inc/  1146129407  0     0     0       8520      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_TOLL v4.1.3 
;*  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
;*  FD$$TOLL  - Convert an IEEE 754 format double precision floating point    *
;*              number into a signed 64 bit long long integer                 *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN ACC:P
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS SATURATED VALUES (0x7fffffff:ffffffff or 
;*                                        0x80000000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                          XAR4  | POINTER TO INPUT  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | OP1 EXP  |       *
;*                                                +-------------------+       *
;*                                          XAR6  |        | RES_MSW  |       *
;*                                                +-------------------+       *
;*                                           AR7  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$TOLL
        .sect     ".text"

FD$$TOLL:	.asmfunc
        .asg       AR5,    OP1_EXP
        .asg       AR6,    RES_MSW 
        .asg       AR7,    RES_SIGN
        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW

*
*;*****************************************************************************
*;      SAVE SIGN OF INPUT                                                    *
*;*****************************************************************************
*
        MOV     RES_SIGN, OP1_SIGN  ; Save the sign
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  5. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, OP1_EXP ; Unpack OP1 into OP1_EXP and ACC:P
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 03FFh; 03FFh is the exponent for integer value 1.  *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 043Fh; Result returned is 7FFFFFFF:FFFFFFFFh or    *
*              80000000:00000000h    *
*;    Case 3:  exponents in the range of 03FFh to 043Fh inclusive will result *
*;             in 64-bit signed integer values from -(2^63-1) to +(2^63-1)    *
*;*****************************************************************************
*
	SUB	OP1_EXP, #0x3FF	; if exponent is < 0x3FF, underflow
	B	UNDERFLOW, LT	;

	MOV 	RES_MSW, AH     ; Save Mantissa Hi16 
	MOVB	AH, #63		; Subtract exponent from 63 to find shift value
				; for denormalization. 
	SUB	AH, OP1_EXP	; If unbiased exponent is >= 63, overflow. That
	B	OVERFLOW, LEQ	; is overflow, if shift value in AH is negative 
				; or zero.
	MOV	T, AH  		; Move the shift value to T for denormalization
	MOV 	AH, RES_MSW     ; Restore Mantissa Hi16
	LSR64	ACC:P, T	; Denormalize 

	CMP	RES_SIGN, #0	; If input is negative,     
	B	RETURN_VALUE, GEQ	
	NEG64	ACC:P		; Don't worry about overflow as ACC:P can
				; never be 0x8000:0:0:0 due to the LSR64 above.
  
RETURN_VALUE:
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC to 0x80000000:00000000 if sign is negative; otherwise             *
*;          to 0x7fffffff:ffffffff                                            *
*;*****************************************************************************
*
OVERFLOW:
	MOV	OVC, RES_SIGN	; Load OVC with bits 15-10 of RES_SIGN, which
				; is sign bit and 5 MSB of exponent 
	SAT64	ACC:P		; If OVC > 0 ACC:P = 0x7fffffff:ffffffff
				; else if OVC < 0, ACC:P = 0x80000000:00000000
				; When OVC = 0, ACC is not modified. For this 
				; case to happen, 5 MSBs of exp should be zero
				; which means the exponent is less than 0x3FF 
				; and should have been underflowed.           
        LRETR
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
UNDERFLOW:
        ZAPA	                  ; For underflow result in ACC:P = 0
        LRETR
	.endasmfunc
fd_tou.asm/     1146129407  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  FD_TOU v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$TOU - Convert an IEEE 754 format double precision floating point      *
*;            number into an unsigned 16 bit integer                          *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_tou28.inc"
        .endif

fd_tou28.inc/   1146129407  0     0     0       7457      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_TOU v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$TOU  - Convert an IEEE 754 format double precision floating point     *
;*             number into an unsigned 16 bit integer			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN AL   
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS SATURATED VALUES 0xffff
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x0000)
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                             						      *
;*                              		    register file	      *
;*                                                +-------------------+       *
;*                                          XAR4  | POINTER TO INPUT  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | OP1 EXP  |       *
;*                                                +-------------------+       *
;*                                           AR6  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$TOU
        .sect     ".text"

FD$$TOU:	.asmfunc
        .asg       AR5,    OP1_EXP
        .asg       AR6,    RES_SIGN
        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW

*
*;*****************************************************************************
*;      Test OP for negative and return zero if negative.                     *
*;*****************************************************************************
*
	MOVL 	ACC, OP1_MSW	;
	B	UNDERFLOW, LT	; return zero if negative 
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  5. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, OP1_EXP ; Unpack OP1 into OP1_EXP and ACC:P
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 03FFh; 03FFh is the exponent for integer value 1.  *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 040Dh; 040Dh is the exponent for integer values    *
*;             in the absolute range from 1073741824 to 2147483648.           *
*;             Result returned is 7FFFh or 8000h                              *
*;    Case 3:  exponents in the range of 03FFh to 040Dh inclusive will result *
*;             in 16-bit signed integer values from -32767 to +32767          *
*;*****************************************************************************
*
	SUB	OP1_EXP, #0x3FF	; if exponent is < 0x3FF, underflow
	B	UNDERFLOW, LT	;

	MOVB	AL, #15		; Subtract exponent from 15 to find shift value
				; for denormalization. 
	SUB	AL, OP1_EXP	; If unbiased exponent is >  15, overflow. That
	B	OVERFLOW, LT 	; is, overflow if shift value in AH is negative 

	MOV	T, AL  		; Move the shift value to T for denormalization
	LSR 	AH, T		; Denormalize 
	MOV	AL, AH		; Get ready to return the value

RETURN_VALUE:
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set AL to 0x8000 if sign is negative; otherwise to 0x7fff                 *
*;*****************************************************************************
*
OVERFLOW:
	MOV	AL, #0xffff	; Load AL with positive saturation value
	B	RETURN_VALUE, UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set AL to 0x0000                                                          *
*;*****************************************************************************
*
UNDERFLOW:
        MOVB	AL, #0           ; For underflow result in AL = 0
        B       RETURN_VALUE,UNC
	.endasmfunc


fd_toul.asm/    1146129407  0     0     0       705       `
*;*****************************************************************************
*;                                                                            *
*;  FD_TOUL v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FD$$TOUL - Convert an IEEE 754 format double precision floating point     *
*;             number into an unsigned 32 bit integer                         *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_toul28.inc"
        .endif

fd_toul28.inc/  1146129407  0     0     0       7572      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_TOUL v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FD$$TOUL  - Convert an IEEE 754 format double precision floating point    *
;*              number into an unsigned 32 bit integer			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN ACC  
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFF:FFFF                                  
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                             						      *
;*                              		    register file	      *
;*                                                +-------------------+       *
;*                                          XAR4  | POINTER TO INPUT  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | OP1 EXP  |       *
;*                                                +-------------------+       *
;*                                           AR6  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$TOUL
        .sect     ".text"

FD$$TOUL:	.asmfunc
        .asg       AR5,    OP1_EXP
        .asg       AR6,    RES_SIGN
        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW

*
*;*****************************************************************************
*;      Test OP for negative and return zero if negative.                     *
*;*****************************************************************************
*
        MOVL    ACC, OP1_MSW    ; Load the upper half of the operand 
        B       UNDERFLOW, LT   ; return zero if negative
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  5. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, OP1_EXP ; Unpack OP1 into OP1_EXP and ACC:P
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 03FFh; 03FFh is the exponent for integer value 1.  *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 041Eh;                                             *
*;             in the absolute range from 1073741824 to 2147483648.           *
*;             Result returned is FFFFFFFFh                                   *
*;    Case 3:  exponents in the range of 03FFh to 041Eh inclusive will result *
*;             in 32-bit unsigned integer values from 0 to 4MB                *
*;*****************************************************************************
*
	SUB	OP1_EXP, #0x3FF	; if exponent is < 0x3FF, underflow
	B	UNDERFLOW, LT	;

	MOV 	PH, AH 		; Save Mantissa Hi16 
	MOVB	AH, #31		; Subtract exponent from 31 to find shift value
				; for denormalization. 
	SUB	AH, OP1_EXP	; If unbiased exponent is > 31, overflow. That
	B	OVERFLOW, LT 	; is overflow, if shift value in AH is negative 

	MOV	T, AH  		; Move the shift value to T for denormalization
	MOV	AH, PH		; Restore Mantissa Hi16
	LSRL	ACC, T		; Denormalize 

RETURN_VALUE:
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC to 0xFFFF:FFFF 						      *
*;*****************************************************************************
*
OVERFLOW:
	MOVB	ACC, #0		; 
	SUBB	ACC, #1		; Load ACC with unsigned saturation value
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC to 0x0000:0000                                                    *
*;*****************************************************************************
*
UNDERFLOW:
        MOVB	ACC, #0           ; For underflow result in ACC = 0
        B       RETURN_VALUE,UNC
	.endasmfunc

fd_toull.asm/   1146129407  0     0     0       365       `
******************************************************************************
* fd_toull.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fd_toull28.inc"
        .endif

fd_toull28.inc/ 1146129407  0     0     0       7700      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FD_TOULL v4.1.3 
;*  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
;*  FD$$TOULL  - Convert an IEEE 754 format double precision floating point   *
;*               number into an unsigned 64 bit long long integer	      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;*
;*   o INPUT OP1 IS IN *XAR4
;*   o RESULT IS RETURNED IN ACC:P
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF:FFFFFFFF                         
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                             						      *
;*                              		    register file	      *
;*                                                +-------------------+       *
;*                                          XAR4  | POINTER TO INPUT  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | OP1 EXP  |       *
;*                                                +-------------------+       *
;*                                           AR6  |        | TMP16    |       *
;*                                                +-------------------+       *
;*                                           AR7  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FD$$TOULL
        .sect     ".text"

FD$$TOULL:	.asmfunc
        .asg       AR5,    OP1_EXP
        .asg       AR6,    TMP16
        .asg       AR7,    RES_SIGN
        .asg   *+XAR4[3],  OP1_SIGN
        .asg   *+XAR4[2],  OP1_MSW
        .asg   *+XAR4[0],  OP1_LSW

*
*;*****************************************************************************
*;      Test OP for negative and return zero if negative.                     *
*;*****************************************************************************
*
        MOVL    ACC, OP1_MSW    ; Load the upper half of the operand 
        B       UNDERFLOW, LT   ; return zero if negative
*
*;*****************************************************************************
*;      UNPACK AND SIGN ADJUST MANTISSA                                       *
*;  1. Extract the exponent in OP1_EXP                                        *
*;  2. Extract the mantissa in ACC:P in bits 62 to 11                         *
*;  3. Add the implied one at bit 63                                          *
*;  5. Store mantissa in OP1_HM:OP1_LM                                        *
*;*****************************************************************************
*
        UNPACK64  XAR4, OP1_EXP ; Unpack OP1 into OP1_EXP and ACC:P
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 03FFh; 03FFh is the exponent for integer value 1.  *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 043Eh;                                             *
*;             Result returned is FFFFFFFFh                                   *
*;    Case 3:  exponents in the range of 03FFh to 043Eh inclusive will result *
*;             in 64-bit unsigned integer values from 0 to 4MB                *
*;*****************************************************************************
*
	SUB	OP1_EXP, #0x3FF	; if exponent is < 0x3FF, underflow
	B	UNDERFLOW, LT	;

	MOV 	TMP16, AH 	; Save Mantissa Hi16 
	MOVB	AH, #63		; Subtract exponent from 63 to find shift value
				; for denormalization. 
	SUB	AH, OP1_EXP	; If unbiased exponent is > 63, overflow. That
	B	OVERFLOW, LT 	; is overflow, if shift value in AH is negative 

	MOV	T, AH  		; Move the shift value to T for denormalization
	MOV	AH, TMP16	; Restore Mantissa Hi16
	LSR64	ACC:P, T	; Denormalize 

        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC:P to 0xFFFFFFFF:FFFFFFFF      				      *
*;*****************************************************************************
*
OVERFLOW:
	MOVB	ACC, #0		; 
	SUBB	ACC, #1		; Load ACC with unsigned saturation value
	MOVL    P, ACC      	;
        LRETR
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
UNDERFLOW:
        ZAPA	                  ; For underflow result in ACC:P = 0
        LRETR
	.endasmfunc

fd_util28.inc/  1146129407  0     0     0       10603     `
*;*****************************************************************************
*;                                                                            *
*;  fd_util28.inc v4.1.3   
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  fd_util28 - Macros to manipulate IEEE 754 format double precision         *
*;              floating point number.                                        *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*; This file contains macros to help the implementation of 64 bit double rts  *
*; routines. All the 64 bit double math functions have common operations like *
*; unpacking, normalizing etc. These operations are implemented as the        *
*; following macros:                                                          *
*;                                                                            *
*; UNPACK64    - Unpack the 64 bit double representation into mantissa and    *
*;               exponent.                                                    *
*; OVERFLOW64  - Fill the ACC:P with the 64 bit overflow double value.        *
*; NORMALIZE64 - Normalize the mantissa for the 64 bit double representation. *
*; ROUND64     - Round the mantissa to the nearest value.                     *
*; PACK64      - Pack 64 bit double value.                                    *
*;                                                                            *
*; +------------------------------------------------------------------+
*; | DOUBLE PRECISION FLOATING POINT FORMAT                           |
*; |   64-bit representation                                          |
*; |   31 30      20 19                  0                            |
*; |   +-+----------+---------------------+                           |
*; |   |S|     E    |        M1           |    High Mantissa          |
*; |   +-+----------+---------------------+                           |
*; |                                                                  |
*; |   31                                0                            |
*; |   +----------------------------------+                           |
*; |   |             M2                   |    Low Mantissa           |
*; |   +----------------------------------+                           |
*; |                                                                  |
*; |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
*; |                                 1 - NEGATIVE VALUE               |
*; |                                                                  |
*; |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
*; |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
*; |                        1111111111 - INFINITY                     |
*; |                                                                  |
*; |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
*; +------------------------------------------------------------------+

*;*****************************************************************************
*; OVERFLOW64 - Generate the double overflow value. If sign is set then ACC:P *
*;              gets 0xFFF0000:000000000; otherwise 0x7FF00000:00000000       *
*;                                                                            *
*;              INPUT :                                                       *
*;                      SIGN - the sign of the overflow.                      *
*;              OUTPUT:                                                       *
*;                      the overflow value in ACC:P                           *
*;*****************************************************************************
*
OVERFLOW64	.macro   SIGN
	ZAPA				; Zero out ACC:P
	AND	AH, SIGN, #0x8000	; Pack the sign bit
	OR 	AH, #0x7FF0		; Pack 0x7FF for exponent 
	.endm
*
*;*****************************************************************************
*; UNPACK64   - Unpack the double float number into mantissa high, mantissa   *
*;              low and exponent. The implied 1 is added to the mantissa.     *
*;              The unpacked values are updated in the respective macro       *
*;              parameters.                                                   *
*;              1. Extract the exponent in OP1_EXP                            *
*;              2. Extract the mantissa in ACC:P in bits 62 to 11             *
*;              3. Add the implied one at bit 63                              *
*;                                                                            *
*;              INPUT :                                                       *
*;                      INP   - pointer to double precision floating point    *
*;				number        				      *
*;                      TMP32 - 32 bit temporary register                     *
*;              OUTPUT:                                                       *
*;                      EXP - 11 bit Exponent                                 *
*;                      ACC:P - mantissa with implied one                     *
*;*****************************************************************************
*
UNPACK64	.macro	INP, EXP
	MOVL	P, *+INP[0]	; Load input into ACC:P
	MOVL    ACC, *+INP[2]   ;
        LSL     AH, 1           ; remove sign
        LSR     AH, 5           ; remove high mantissa 
        MOV     EXP, AH         ; store exponent 
	MOVL	ACC, *+INP[2]   ; restore upper half of OP
	LSL64	ACC:P, 11	; Shift sign and 10 bits of exponent 
        OR      AH, #0x8000     ; add implied 1 to mantissa
	.endm
*
*;*****************************************************************************
*; NORMALIZE64 - Normalize the mantissa for the 64 bit double representation. *
*;                                                                            *
*;              INPUT :                                                       *
*;                      ACC:P - mantissa to be normalized.                    *
*;                      EXP   - 11 bit Exponent                               *
*;              OUTPUT:                                                       *
*;                      ACC:P - Normalized Mantissa                           *
*;                      EXP   - Exponent adjusted for normalization.          *
*; NOTE: EXP and TMP16 should be loc16                                        *
*;*****************************************************************************
*
NORMALIZE64	.macro  EXP, TMP16
        CSB     ACC             ; Find the number of sign bits in ACC (sn)
        LSL64   ACC:P, T        ; Shift (sn-1) bits out.
        MOV     TMP16, T	; Save the shift value in RES_EXP for now.
        CSB     ACC             ; Find the number of sign bits in ACC (sn)
        LSL64   ACC:P, T        ; Shift (sn-1) bits out.
	PUSH    AH              ; Save result high mantissa.
        MOV     AH, EXP         ; Adjust the exponent.
        SUB     AH, T		;                
        SUB     AH, TMP16       ;
	MOV     EXP, AH         ; save result exponent
	POP	AH 
	.endm

*;*****************************************************************************
*; ROUND64 - Round the mantissa to the nearest value.                         *
*;                                                                            *
*;              INPUT :                                                       *
*;                      ACC:P - Mantissa                                      *
*;                      RES_EXP - 11 bit Exponent                             *
*;                      TMP32   - 32 bit Temporary register                   *
*;              OUTPUT:                                                       *
*;                      ACC:P - Rounded mantissa                              *
*;                      RES_EXP - Rounding Adjusted exponent.                 *
*; NOTE: RES_EXP should be from loc16                                         *
*;       TMP32 should be from loc32                                           *
*;*****************************************************************************
*
ROUND64	.macro	RES_EXP, TMP32
        MOVL    TMP32, #0x200   ;
        ADDUL   P, TMP32        ;Round to the nearest
        MOVL    TMP32, #0       ;
        ADDCL   ACC, TMP32      ;

        B       RND64_SET_MANT?, GEQ  ;
        AND     AH, #0x7FFF     ; Clear the carry bit.                         
        INC     RES_EXP         ; Adjust exponent if rounding generated a carry
RND64_SET_MANT?
	.endm

*;*****************************************************************************
*; PACK64 - Pack 64 bit double precision IEEE 754 format number               *
*;                                                                            *
*;              INPUT :                                                       *
*;                      ACC:P - Mantissa in bits 51 - 0                       *
*;                      SIGN  - Sign of the double value.                     *
*;                      EXP   - 11 bit Exponent                               *
*;              OUTPUT:                                                       *
*;                      ACC:P - Packed IEEE 754 foramt double precision       *
*;                              floating point value.                         *
*; NOTE: EXP and SIGN should be from loc16                                    *
*;*****************************************************************************
*
PACK64	.macro	SIGN, EXP          ;            
	AND	SIGN, #0x8000	   ; ACC:P 0000 0000 0000 MMMM : M47 - M0     
	OR 	SIGN, AH	   ; SIGN = S000 0000 0000 MMMM
	MOV	AH, EXP		   ; AH = 0000 0EEE EEEE EEEE
	LSL	AH, #4		   ; AH = 0EEE EEEE EEEE 0000
	OR	AH, SIGN	   ; ACC:P = SEEE EEEE EEEE MMMM : M47 - M0
	.endm


feof.c/         1146129407  0     0     0       829       `
/*****************************************************************************/
/*  FEOF.C v4.1.3                                                            */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FEOF, which returns a 1 if an EOF      */
/*    has occured on that stream.  The function merely calls a macro         */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

_CODE_ACCESS int feof(FILE *_fp) { return (((_fp)->flags & _STATEOF)); }


ferror.c/       1146129407  0     0     0       827       `
/*****************************************************************************/
/*  FERROR.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FERROR, which returns a 1 if an I/O    */
/*    error has occured on that stream.  The function merely calls a macro   */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

_CODE_ACCESS int ferror(FILE *_fp) { return (_STCHK(_fp, _STATERR)); }


fflush.c/       1146129407  0     0     0       5188      `
/*****************************************************************************/
/*  FFLUSH.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    fflush   -  Call _doflush for all streams that require flushing        */
/*    _doflush -  Flush one stream                                           */
/*****************************************************************************/
#include <stdio.h>
#include <_lock.h>
#include "file.h"

extern _DATA_ACCESS int _ft_end;

int _doflush(FILE *_fp);






/*****************************************************************************/
/* FFLUSH   -  Call _doflush for all streams that require flushing           */
/*                                                                           */
/*    This function returns a 0 upon success, and an EOF upon failure.       */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fflush(register FILE *_fp)
{
   int result = 0;
 
   /*------------------------------------------------------------------------*/
   /* If _fp is not a NULL pointer, call _DOFLUSH for that stream.           */
   /* Otherwise, call _DOFLUSH for all file streams in the table that are    */
   /* active.                                                                */
   /*------------------------------------------------------------------------*/
   if (_fp) result = _doflush(_fp);
   else
   {
      int index;

      /*---------------------------------------------------------------------*/
      /* This is a critical section because it depends on the global	     */
      /* variable _ft_end.						     */
      /*---------------------------------------------------------------------*/
      _lock();
      for(index = 0; index < _ft_end; index++)
         if(_ftable[index].fd != -1) result |= _doflush(&_ftable[index]);
      _unlock();
   }
 
   return (result);
}






/*****************************************************************************/
/* _DOFLUSH -  Flush one stream                                              */
/*                                                                           */
/*    This function flushes the stream pointed to by _fp.  If the function   */
/*    is successful, it returns a 0.  If unsuccessful, it returns an EOF     */
/*                                                                           */
/*****************************************************************************/
int _doflush(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*                                                                        */
   /*    num_write   -  The number of bytes to be written to the file        */
   /*    errchk      -  An indicator to see if WRITE was successful          */
   /*------------------------------------------------------------------------*/
   unsigned num_write = _fp->pos - _fp->buf;
   int errchk = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is writable, and it has a buffer, call WRITE, and store  */
   /* its return value in errchk                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) errchk = write(_fp->fd, (char *)_fp->buf, num_write);
 
   /*------------------------------------------------------------------------*/
   /* If WRITE fails, set the error flag in the stream pointer, and return   */
   /* an EOF                                                                 */
   /*------------------------------------------------------------------------*/
   if(errchk < 0)
   {
      _SET(_fp, _STATERR);
      return (EOF);
   }
 
   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointer, make files opened with the "+" flag          */
   /* available for wither reading or writing, and return a 0, indicating    */
   /* a success                                                              */
   /*------------------------------------------------------------------------*/
   _fp->pos          =  _fp->buf;
   _fp->buff_stop    =  NULL;
   if (_STCHK(_fp, _MODERW)) _UNSET(_fp, (_MODER | _MODEW));
   return 0;
 
}
 
fgetc.c/        1146129407  0     0     0       4142      `
/*****************************************************************************/
/*  FGETC.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    GETC     -  Get a character from a stream                              */
/*    GETCHAR  -  Get a character from stdin                                 */
/*    FGETC    -  Get a character from a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern void _buff_read(FILE *_fp);
extern int  _rd_ok    (FILE *_fp);

extern _CODE_ACCESS int fgetc(register FILE *_fp);






/*****************************************************************************/
/* GETC  -  Get a character from a stream                                    */
/*                                                                           */
/*    This function is equivalent to FGETC.                                  */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int getc(FILE *_fp) { return (fgetc(_fp)); }






/*****************************************************************************/
/* GETCHAR  -  Get a character from stdin                                    */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which calls FGETC with */
/*    stdin as its argument.                                                 */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int getchar(void) { return(_getchar()); }






/*****************************************************************************/
/* FGETC -  Get a character from a stream                                    */
/*****************************************************************************/
_CODE_ACCESS int fgetc(register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that it is OK to read from this stream.                      */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp)) return (EOF);
   
   /*------------------------------------------------------------------------*/
   /* For non-buffered streams, call the lowlevel READ function.             */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int   errchk;
      char  result;

      errchk = read(_fp->fd, &result, 1);
      if(errchk <= 0)
      {
         _SET(_fp, (errchk == 0) ? _STATEOF : _STATERR);
         return (EOF);
      }

      return ((int)result);
   }

   /*------------------------------------------------------------------------*/
   /* If the buffer has been entirely read, or is empty, call _BUFF_READ to  */
   /* fill the buffer.                                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
 
   /*------------------------------------------------------------------------*/
   /* If the buffer read was unsuccessful, return an EOF.  Otherwise, clear  */
   /* the _UNGETC flag in the stream, and return the next character.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, (_STATERR | _STATEOF))) return (EOF);
   _UNSET(_fp, _UNGETC);

   return ((int)*(_fp->pos++)); 
   
}

fgetpos.c/      1146129407  0     0     0       1018      `
/*****************************************************************************/
/*  FGETPOS.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This function contains the function FGETPOS, which stores the current  */
/*    position in the file into the variable pointed to by _POS.  A 0 is     */
/*    returned upon success, and upon failure, ERRNO is set to 5, and a -1L  */
/*    is returned.                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>
#include "file.h"

_CODE_ACCESS int fgetpos(FILE *_fp, fpos_t *_pos)
{
   if((*_pos = ftell(_fp)) != -1L) return (0);
   else { errno = 5; return (-1);  }
}

fgets.c/        1146129407  0     0     0       7794      `
/*****************************************************************************/
/*  FGETS.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FGETS    -  Get a string from a stream                                 */
/*    GETS     -  Get a string from stdin                                    */
/*    _DOFGETS -  Perform the main FGETS routine                             */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);

static char *_dofgets(char *_ptr, register int _size, register FILE *_fp,
                      int _gets_flag);






/*****************************************************************************/
/* FGETS -  Get a string from a stream                                       */
/*                                                                           */
/*    This function calls _DOFGETS, with a 0 for the _GETS_FLAG argument.    */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS char *fgets(char *_ptr, register int _size, register FILE *_fp)
{
   return(_dofgets(_ptr, _size, _fp, 0));
}






/*****************************************************************************/
/* GETS  -  Get a string from stdin                                          */
/*                                                                           */
/*    This function calls FGETS with stdin as the stream argument.           */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS char *gets(char *_ptr) { return (_dofgets(_ptr, 1, stdin, 1)); }






/*****************************************************************************/
/* _DOFGETS -  Perform the main FGETS routine                                */
/*                                                                           */
/*    This function gets a string from the stream _FP.  It returns a pointer */
/*    to the string upon success, or NULL upon failure.                      */
/*                                                                           */
/*****************************************************************************/
static char *_dofgets(char *_ptr, register int _size, register FILE *_fp, 
                      int _gets_flag)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned    char     *next_nl    = NULL;
               char     *fpos       = _ptr;
               size_t   num_left    = _size -1,
                        num_to_read;
               int      skipped_nl  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is readable.                                 */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _STCHK(_fp, _STATEOF) || (_size -1) < 0) return (NULL);

   /*------------------------------------------------------------------------*/
   /* If the stream is non buffered, read the string in one character at a   */
   /* time, using the lowlevel READ function.                                */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int errchk;
 
      while((errchk = read(_fp->fd, fpos, 1) > 0) && (*(fpos++) != '\n'));
 
      switch(errchk)
      {
         case  0 :
         case -1 : return (NULL);
      }
 
      *fpos = '\0';
 
      return (_ptr);
   }
 
   while((num_left > 0 || _gets_flag) && ! next_nl)
   {
      /*---------------------------------------------------------------------*/
      /* If the buffer is empty or completely read, fill it up.              */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);

      if (_STCHK(_fp, (_STATERR | _STATEOF)))
      {
          /*-----------------------------------------------------------------*/
          /* If we've read any characters, fall out of for loop, returning   */
          /* what we've read in.                                             */
          /*-----------------------------------------------------------------*/
          if (fpos != _ptr) break;
          /*-----------------------------------------------------------------*/
          /* Otherwise we have not read anything (some kind of error).       */
          /*-----------------------------------------------------------------*/
          return (NULL);
      }

      /*---------------------------------------------------------------------*/
      /* Determine the location of the next newline character (NEXT_NL).     */
      /*---------------------------------------------------------------------*/
      next_nl = (unsigned char *)memchr(_fp->pos, '\n', (_fp->buff_stop - 
                                        _fp->pos));

      /*---------------------------------------------------------------------*/
      /* Determine how many characters to read from the buffer.  If this     */
      /* function was called from GETS (_GETS_FLAG == 1), read until a       */
      /* newline character, EOF character, or the end of the buffer is       */
      /* encountered.  Do the same otherwise, but do not read any more       */
      /* characters than specified by NUM_LEFT.                              */
      /*---------------------------------------------------------------------*/
      num_to_read =  _fp->buff_stop - _fp->pos;
      num_to_read =  (next_nl) ? (next_nl - _fp->pos + 1) : num_to_read;
      num_to_read =  (_gets_flag) ? num_to_read :
                     (num_left < num_to_read) ? num_left : num_to_read;

      /*---------------------------------------------------------------------*/
      /* If this function was called from GETS (_GETS_FLAG == 1), do not     */
      /* retain a newline character if one is present                        */
      /*---------------------------------------------------------------------*/
      if(next_nl && _gets_flag)
      {
         num_to_read--;
         skipped_nl = 1;
      }

      /*---------------------------------------------------------------------*/
      /* Copy the characters, and update pointers and counters.              */
      /*---------------------------------------------------------------------*/
      memcpy(fpos, _fp->pos, num_to_read);
      _fp->pos += (skipped_nl + num_to_read);
      num_left -= num_to_read;
      fpos += num_to_read;
   }

   /*------------------------------------------------------------------------*/
   /* Tack on the NULL terminator, clear the _UNGETC flag and the _GETS_FLAG.*/
   /*------------------------------------------------------------------------*/
   *fpos = '\0';
   _UNSET(_fp, _UNGETC);
   _gets_flag = 0; 

   return(_ptr);
}

file.h/         1146129407  0     0     0       3205      `
/*****************************************************************************/
/*  FILE.H v4.1.3                                                            */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Macros and declarations used in lowlevel I/O functions.                   */
/*****************************************************************************/
#ifndef _FILE
#define _FILE

#include <linkage.h>

/*---------------------------------------------------------------------------*/
/* constants for file manipulations                                          */
/*---------------------------------------------------------------------------*/
#define  O_RDONLY    (0x0000) /* open for reading      */
#define  O_WRONLY    (0x0001) /* open for writing      */
#define  O_RDWR      (0x0002) /* open for read & write */
#define  O_APPEND    (0x0008) /* append on each write  */
#define  O_CREAT     (0x0200) /* open with file create */
#define  O_TRUNC     (0x0400) /* open with truncation  */
#define  O_BINARY    (0x8000) /* open in binary mode   */

/*---------------------------------------------------------------------------*/
/* lowlevel I/O declarations                                                 */
/*---------------------------------------------------------------------------*/
#ifdef __cplusplus
#define _DECL extern "C"
#else /* ! __cplusplus */
#define _DECL extern
#endif

#ifndef _OFF_T
#define _OFF_T
typedef long off_t;
#endif /* _OFF_T */

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

_DECL _CODE_ACCESS int   open(const char *path, unsigned flags, int mode);
_DECL _CODE_ACCESS int   read(int fildes, char *bufptr, unsigned cnt);
_DECL _CODE_ACCESS int   write(int fildes, const char *bufptr, unsigned cnt);
_DECL _CODE_ACCESS off_t lseek(int fildes, off_t offset, int origin);
_DECL _CODE_ACCESS int   close(int fildes);
_DECL _CODE_ACCESS int   unlink(const char *path);
_DECL _CODE_ACCESS int   rename(const char *old_name, const char *new_name);

_DECL _CODE_ACCESS int add_device(
    char     *name,			           
    unsigned  flags,
    int      (*dopen)(const char *path, unsigned flags, int llv_fd),
    int      (*dclose)(int dev_fd),
    int      (*dread)(int dev_fd, char *buf, unsigned count),
    int      (*dwrite)(int dev_fd, const char *buf, unsigned count),
    off_t    (*dlseek)(int dev_fd, off_t offset, int origin),
    int      (*dunlink)(const char *path),
    int      (*drename)(const char *old_name, const char *new_name));

#define _NSTREAM        20                   /* Size of stream table        */
#define _NDEVICE        3                    /* Size of device table        */

#define _SSA      (0x0000)             /* Single Stream allowed       */
#define _BUSY     (0x0001)             /* Device busy                 */
#define _MSA      (0x0002)             /* Multiple Streams Allowed    */

#undef _DECL

#endif /* _FILE */


float.h/        1146129407  0     0     0       3851      `
/*****************************************************************************/
/* float.h    v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

/********************************************************************/
/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */
/*          DBL_     - APPLIES TO TYPE DOUBLE                       */
/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */
/********************************************************************/
#ifndef _FLOAT
#define _FLOAT

#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */
#define FLT_ROUNDS                        0   /* ROUND TOWARD ZERO         */
 
#define FLT_DIG                           6   /* DECIMAL PRECISION         */
#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */
#define FLT_MIN_EXP                    -125   /* SMALLEST EXPONENT         */
#define FLT_MAX_EXP                     128   /* LARGEST EXPONENT          */
#define FLT_EPSILON        1.192092896E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define FLT_MIN            1.175494351E-38F   /* SMALLEST POSITIVE VALUE   */
#define FLT_MAX            3.402823466E+38F   /* LARGEST POSITIVE VALUE    */
#define FLT_MIN_10_EXP                  -37   /* MIN POWER OF 10           */
#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */
 
#define DBL_DIG                           6   /* DECIMAL PRECISION         */
#define DBL_MANT_DIG                     24   /* BITS IN MANTISSA          */
#define DBL_MIN_EXP                    -125   /* SMALLEST EXPONENT         */
#define DBL_MAX_EXP                     128   /* LARGEST EXPONENT          */
#define DBL_EPSILON        1.192092896E-07    /* SMALLEST X WHERE 1+X != 1 */
#define DBL_MIN            1.175494351E-38    /* SMALLEST POSITIVE VALUE   */
#define DBL_MAX            3.402823466E+38    /* LARGEST POSITIVE VALUE    */
#define DBL_MIN_10_EXP                  -37   /* MIN POWER OF 10           */
#define DBL_MAX_10_EXP                   38   /* MAX POWER OF 10           */
 
#if defined(__TMS320C27X__)

#define LDBL_DIG                          6   /* DECIMAL PRECISION         */
#define LDBL_MANT_DIG                    24   /* BITS IN MANTISSA          */
#define LDBL_MIN_EXP                   -125   /* SMALLEST EXPONENT         */
#define LDBL_MAX_EXP                    128   /* LARGEST EXPONENT          */
#define LDBL_EPSILON       1.192092896E-07    /* SMALLEST X WHERE 1+X != 1 */
#define LDBL_MIN           1.175494351E-38    /* SMALLEST POSITIVE VALUE   */
#define LDBL_MAX           3.402823466E+38    /* LARGEST POSITIVE VALUE    */
#define LDBL_MIN_10_EXP                 -37   /* MIN POWER OF 10           */
#define LDBL_MAX_10_EXP                  38   /* MAX POWER OF 10           */

#elif defined(__TMS320C28X__)

#define LDBL_DIG                         15   /* DECIMAL PRECISION         */
#define LDBL_MANT_DIG                    53   /* BITS IN MANTISSA          */
#define LDBL_MIN_EXP                  -1021   /* SMALLEST EXPONENT         */
#define LDBL_MAX_EXP                   1024   /* LARGEST EXPONENT          */
#define LDBL_EPSILON 2.2204460492503131E-16L  /* SMALLEST X WHERE 1+X != 1 */
#define LDBL_MIN    2.2250738585072014E-308L  /* SMALLEST POSITIVE VALUE   */
#define LDBL_MAX    1.7976931348623157E+308L  /* LARGEST POSITIVE VALUE    */
#define LDBL_MIN_10_EXP                -307   /* MIN POWER OF 10           */
#define LDBL_MAX_10_EXP                 308   /* MAX POWER OF 10           */

#endif /* __TMS320C28X__ */

#endif /* _FLOAT */

fmod.c/         1146129407  0     0     0       1434      `
/****************************************************************************/
/*  fmod   v4.1.3                                                           */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/

#ifndef _MATH
#undef _INLINE
#endif

#include <math.h>

/****************************************************************************/
/*  FMOD() - Floating point remainder                                       */
/*									    */
/*  Returns the remainder after dividing x by y an integral number of times.*/
/*                                                                          */
/****************************************************************************/
double fmod(double x, double y)
{
   double d = fabs(x); 

   /*************************************************************************/
   /* if y is too small, any remainder is negligible.                       */
   /*************************************************************************/
   if (d - fabs(y) == d) return (0.0);

   /*************************************************************************/
   /* otherwise, divide; result = dividend - (quotient * divisor)           */
   /*************************************************************************/
   modf(x/y, &d);
   return (x - d * y);
}
fopen.c/        1146129407  0     0     0       9894      `
/*****************************************************************************/
/*  FOPEN.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    FOPEN       -  Open a file and return a pointer to it                  */
/*    FREOPEN     -  Switch a FILE pointer to a different stream             */
/*    _OPENFILE   -  Set file flags, and call lowlevel OPEN                  */
/*    _SEARCH_FP  -  Find an open slot in the file table                     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <_lock.h>
#include "file.h"
 
extern _DATA_ACCESS int _ft_end;
extern _DATA_ACCESS void (*_cleanup_ptr)(void);

extern void   _cleanup(void);
 
static FILE *_search_fp(void);
static FILE *_openfile(const char *_fname, register FILE *_fp, const char
                       *_mode);


/*****************************************************************************/
/* FOPEN    -  Open a file and return a pointer to it                        */
/*                                                                           */
/*    This function calls _SEARCH_FP to locate an empty slot in the file     */
/*    table (_ftable), and calls _OPENFILE with it to open a stream to the   */
/*    file _FNAME.  It returns a pointer to the stream that was allocated,   */
/*    or NULL if it was not successful.                                      */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS FILE *fopen(const char *_fname, const char *_mode)
{
    FILE *f;

    /*-----------------------------------------------------------------------*/
    /* This is a critical section because search_fp looks for a new file     */
    /* slot in the global table _ftable.				     */
    /*-----------------------------------------------------------------------*/
    _lock();
    f = _openfile(_fname, _search_fp(), _mode);
    _unlock();
    return f;
}

 
/*****************************************************************************/
/* FREOPEN  -  Switch a FILE pointer to a different stream                   */
/*                                                                           */
/*    This function attempts to close any file associated with _FP, and then */
/*    reassigns _FP to the file _FNAME by calling _OPENFILE.  It returns a   */
/*    pointer to the stream if successful, or NULL if the function is not    */
/*    successful.                                                            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS FILE *freopen(const char *_fname, const char *_mode, register FILE *_fp)
{
    FILE *f;

    /*-----------------------------------------------------------------------*/
    /* This is a critical section because it expects the same slot in the    */
    /* global table _ftable to be available.				     */
    /*-----------------------------------------------------------------------*/
    _lock();
    fclose(_fp); 
    f = _openfile(_fname, _fp, _mode);
    _unlock();
    return f;
}


/*****************************************************************************/
/* _SEARCH_FP  -  Find an open slot in the file table                        */
/*                                                                           */
/*    This function looks through the array _ftable, searching for a null    */
/*    pointer which indicates an empty slot.  It mallocs a stream for that   */
/*    slot, and assigns a pointer to it there, initializing it and returning */
/*    it to the calling function.                                            */
/*                                                                           */
/*****************************************************************************/
static FILE *_search_fp(void)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int index;
	
   /*------------------------------------------------------------------------*/
   /* Search the file table for an empty slot.  Return a NULL is there       */
   /* aren't any available.                                                  */
   /*------------------------------------------------------------------------*/
   for(index = 0; (index < _ft_end) && _ftable[index].fd != -1; index++);
   if (index == _NFILE) return (NULL);
   if (index == _ft_end) _ft_end++;

   /*------------------------------------------------------------------------*/
   /* Initialize the new stream.                                             */
   /*------------------------------------------------------------------------*/
   memset(&_ftable[index], '\0', sizeof(FILE));

   return (&_ftable[index]);
}
 

/*****************************************************************************/
/* _OPENFILE   -  Set file flags, and call lowlevel OPEN                     */
/*                                                                           */
/*    This function sets FILE flags for reading or writing by the character  */
/*    string _MODE.  It then calls the lowlevel OPEN function to open the    */
/*    file, and assigns the file descriptor returned from that function into */
/*    the FD member of the stream.                                           */
/*                                                                           */
/*****************************************************************************/
static FILE *_openfile(const char *_fname, register FILE *_fp, const char 
                       *_mode)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int         wr, 
               bin = 0, 
               plus = 0;
   unsigned    lflags = 0;

   if (! _fp) return (NULL);
 
   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO THAT ALL OPENED FILES WILL BE CLOSED AT EXIT.    */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;
   
   /*------------------------------------------------------------------------*/
   /* Set the flags in the stream to reflect to I/O mode of the stream to be */
   /* opened.                                                                */
   /*------------------------------------------------------------------------*/
   wr    = _mode[0];
   if (_mode[1])
   {
      bin  = ((_mode[1] == 'b') || (_mode[2] == 'b'));
      plus = ((_mode[1] == '+') || (_mode[2] == '+'));
   }

   _fp->flags = 0;

   if(!plus)
      _SET(_fp, (wr == 'r') ? _MODER : 
                (wr == 'w' || wr == 'a') ? _MODEW : 0);

   _SET(_fp, (wr == 'a') ? _MODEA : 0);
   _SET(_fp, (bin)  ? _MODEBIN : 0);
   _SET(_fp, (plus) ? _MODERW  : 0);
 
   if(bin) lflags |= (O_BINARY);

   /*------------------------------------------------------------------------*/
   /* Set the flags in LFLAGS to reflect the flags that will be necessary to */
   /* call the lowlevel OPEN function properly for this stream.              */
   /*------------------------------------------------------------------------*/
   switch (wr)
   {
      case 'r' : lflags |= (plus) ? O_RDWR : O_RDONLY;
                 break;
 
      case 'a' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_APPEND | O_CREAT);
                 break;
 
      case 'w' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_TRUNC | O_CREAT);
                 break;
   }

   /*------------------------------------------------------------------------*/
   /* Call the lowlevel OPEN function, and store the returned file           */
   /* descriptor into the stream.  If the OPEN function fails, return NULL.  */
   /*------------------------------------------------------------------------*/
   if ((_fp->fd = open(_fname, lflags, 0666)) < 0) return (NULL);

   return (_fp);
}


/*****************************************************************************/
/* _CLEANUP   -  CLOSE ALL OPEN STREAMS.  THIS IS CALLED BY EXIT() IF A FILE */
/*               IS EVER OPENED OR A BUFFER IS EVER CREATED.                 */
/*****************************************************************************/
void _cleanup(void)
{
   int j;

   /*------------------------------------------------------------------------*/
   /* CLOSE ALL STREAMS THAT ARE CURRENTLY OPEN.                             */
   /*------------------------------------------------------------------------*/
   /* This is a critical section because it depends on the global variable   */
   /* _ft_end.								     */
   /*------------------------------------------------------------------------*/
   _lock();
   fclose(&_ftable[0]);
   for(j = 1; j < _ft_end; j++) 
       if (_ftable[j].fd > 0) fclose(&_ftable[j]); 
   _unlock();
}
format.h/       1146129407  0     0     0       2310      `
/*****************************************************************************/
/*  FORMAT.H v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Structures and macros used in printf and scanf                            */
/*****************************************************************************/
#ifndef __FORMAT_H
#define __FORMAT_H
#include <stdarg.h>

#define _ARSIZE 400

#ifdef __cplusplus
extern "C" namespace std {
#else 
extern
#endif

  int _scanfi(void *inp, const char *_format, va_list _ap,
	      int (*_chkmbc)(void **inp, char **_format, int *num_read),
	      int (*_inpchar)(void **inp),
	      void (*_uninpchar)(void **inp, int outchar));
 
  /**************************************************************************/
  /* _FIELD STRUCTURE AND MACROS USED FOR PRINTF AND SCANF                  */
  /**************************************************************************/
  typedef struct {
    unsigned int flags;         /* Format flags */
    int          fwidth;        /* Field width */
    int          precision;     /* Field precision */
    char         conv;          /* Conversion specifier */
  } _PFIELD;
  
  typedef struct {
    unsigned int flags;         /* Format flags */
    int          fwidth;        /* Field width */
    int          precision;     /* Field precision */
    char         scanset[96];   /* Scanset used for '[' conversion */
    char         conv;          /* Conversion specifier */
  } _SFIELD;

#ifdef __cplusplus
}
#endif /* __cplusplus */

/****************/
/* PRINTF FLAGS */
/****************/

#define _PFMINUS  0x01
#define _PFPLUS   0x02
#define _PFSPACE  0x04
#define _PFPOUND  0x08
#define _PFZERO   0x10
 
/***************/
/* SCANF FLAGS */
/***************/

#define _SFSTAR   0x01
#define _SFCIRC   0x02

/****************/
/* MUTUAL FLAGS */
/****************/

#define _MFH      0x20
#define _MFL      0x40
#define _MFLD     0x80
#define _MFLL     0x100
#define _MFHH     0x200

#endif
fprintf.c/      1146129407  0     0     0       2879      `
/*****************************************************************************/
/*  FPRINTF.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FPRINTF  -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);


/*****************************************************************************/
/* FPRINTF  -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fprintf(FILE *_fp, const char *_format, ...)
{
   va_list  _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_fp, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }


/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


fputc.c/        1146129407  0     0     0       4420      `
/*****************************************************************************/
/*  FPUTC.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTC     -  Write a character to a stream                              */
/*    PUTCHAR  -  Write a character to stdout                                */
/*    FPUTC    -  Write a character to a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTC  -  Write a character to a stream                                    */
/*                                                                           */
/*    This function is equivalent to FPUTC.                                  */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int putc(int _x, FILE *_fp) { return(fputc(_x, _fp)); }






/*****************************************************************************/
/* PUTCHAR  -  Write a character to stdout                                   */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which in turn calls    */
/*    FPUTC, with stdout as its stream argument.                             */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int putchar(int _x) { return(_putchar(_x)); }






/*****************************************************************************/
/* FPUTC -  Write a character to a stream                                    */
/*                                                                           */
/*    This function writes character _C into the stream specified by _FP.    */
/*    Upon success, it returns the character written.  Upon failure, it      */
/*    returns an EOF.                                                        */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fputc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      char cbuf = (char)_c;

      if((write(_fp->fd, &cbuf, 1)) == -1)
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }
      else return ((unsigned char)_c);
   }

   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer.                                       */
   /*------------------------------------------------------------------------*/
   *(_fp->pos++) = (unsigned char)_c;

   /*------------------------------------------------------------------------*/
   /* If the buffer is full, or a line-buffered stream reached a newline     */
   /* character, flush it.                                                   */
   /*------------------------------------------------------------------------*/
   if((_fp->pos == _fp->bufend) || (_STCHK(_fp, _IOLBF) && _c == '\n'))
      if(_doflush(_fp))
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }

   return((unsigned char)_c);
}

fputs.c/        1146129407  0     0     0       5194      `
/*****************************************************************************/
/*  FPUTS.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTS  -  Write a string to stdout                                      */
/*    FPUTS -  Write a string to a stream                                    */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTS  -  Write a string + newline to stdout.                              */
/*                                                                           */
/*    This function calls FPUTS, with stdout as the stream argument.         */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int puts(const char *_ptr) 
{ 
    int count = fputs(_ptr, stdout);
    count += fputs("\n", stdout); 
    return count;
}



/*****************************************************************************/
/* FPUTS -  Write a string to a stream                                       */
/*                                                                           */ 
/*    This function writes string _PTR to stream _FP, returning the number   */
/*    of characters written upon success, or an EOF upon failure.            */
/*                                                                           */ 
/*****************************************************************************/
_CODE_ACCESS int fputs(const char *_ptr, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   size_t   num_left, ptr_strlen;
   char     *fpos          = (char *)_ptr;
   int      room_left,
            flush_flag     = 0,
            num_to_write;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);
 
   room_left = (int)(_fp->bufend - _fp->pos);
   ptr_strlen = num_left = strlen(_ptr);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF) 
   {
       int num_written = 0;

       while (num_left > 0)
       {
	   int write_return = write(_fp->fd, _ptr + num_written, num_left);
	   if (write_return < 0) 
	   { 
	       _SET(_fp, _STATERR); 
	       return (EOF);
	   }
	   else
	   {
	       num_written += write_return;
	       num_left    -= write_return;
	   }
       }

       return ptr_strlen;
   }
 
   /*------------------------------------------------------------------------*/
   /* Write the string into the buffer, flushing it when full.               */
   /*------------------------------------------------------------------------*/
   while(num_left > 0)
   {
      num_to_write = (num_left > room_left) ? room_left : num_left;
      if((_BUFFMODE(_fp) == _IOLBF) && memchr(fpos, '\n', num_to_write))
      { 
         num_to_write = (char *)memchr(fpos, '\n', num_to_write) - fpos + 1;
         flush_flag = 1;
      }
      memcpy(_fp->pos, fpos, num_to_write);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      _fp->pos  += num_to_write;
      fpos      += num_to_write;
      num_left  -= num_to_write;
      room_left -= num_to_write;

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, flush it.  Any I/O errors cause this         */
      /* function to exit, returning an EOF.                                 */
      /*---------------------------------------------------------------------*/
      if(room_left == 0 || flush_flag)
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR);
            return (EOF);
         }
         room_left = (int)(_fp->bufend - _fp->pos);
         _SET(_fp, _MODEW);
         flush_flag = 0;
      }
   }
   return ptr_strlen;
}

fread.c/        1146129407  0     0     0       4825      `
/*****************************************************************************/
/*  FREAD.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FREAD       -  Read a block of bytes from a stream                     */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);





/*****************************************************************************/
/* FREAD -  Read a block of bytes from a stream                              */
/*                                                                           */
/*    This function reads _COUNT blocks of _SIZE size from stream _FP, and   */
/*    stores them in string _PTR.  The function returns the number of        */
/*    blocks read.                                                           */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS size_t fread(void *_ptr, size_t _size, size_t _count, FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char     *fpos       = (unsigned char *)_ptr;
            size_t   num_left    = _size * _count,
                     num_read    = 0,
                     num_to_read = 0;
 
   /*------------------------------------------------------------------------*/
   /* Make sure that the file is readable.                                   */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel READ function.	     */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
       int num_read = 0;

       while (num_left > 0)
       {
	   int read_return = (size_t)(read(_fp->fd, 
					   (char *)fpos + num_read, num_left));
	   if (read_return < 0)
	   {
	       _SET(_fp, _STATERR);
	       return (num_read / _size);
	   }
	   else if (read_return == 0) 
	   {
	       _SET(_fp, _STATEOF);
	       return (num_read / _size);
	   }
	   else 
	   {
	       num_read += read_return;
	       num_left -= read_return;
	   }
       }

       return (num_read / _size);
   }
   
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* If the buffer has been completely read, fill it up.  Exit the loop  */
      /* if an I/O error occurs, or the end of the file is reached.          */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop)  _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) break;

      /*---------------------------------------------------------------------*/
      /* Determine how many characters can fit in the buffer, and read them  */
      /* in.                                                                 */
      /*---------------------------------------------------------------------*/
      num_to_read = (num_left < (_fp->buff_stop - _fp->pos)) ?
                    num_left : (_fp->buff_stop - _fp->pos);
      memcpy(fpos, _fp->pos, num_to_read);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      fpos += num_to_read;
      _fp->pos += num_to_read;
      num_read += num_to_read;
      num_left -= num_to_read; 
   }

   /*------------------------------------------------------------------------*/
   /* Clear the _UNGETC flag in the stream, and return the number of blocks  */
   /* read.                                                                  */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, _UNGETC);
 
   return (num_read / _size);
 
}
 

frexp.c/        1146129407  0     0     0       1375      `
/****************************************************************************/
/*  frexp  v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>

double frexp(double value, int *exp)
{
     int *ptr;
 
     ptr = (int *)&value;
 
     /***********************************************************************/
     /* IF THE VALUE IS ZERO, THE RESULTS ARE ZERO                          */ 
     /***********************************************************************/ 
     if (!ptr[0] && !ptr[1]) 
     {
       *exp = 0;
       return value;
     }
 
     /***********************************************************************/
     /* EXTRACT THE EXPONENT, SUBTRACT THE BIAS, THEN ADD 1                 */
     /***********************************************************************/
     *exp = ((ptr[1] >> 7) & 0xFF) - 127 + 1;
 
     /***********************************************************************/
     /* SET THE EXPONENT OF THE FRACTION TO -1                              */
     /***********************************************************************/
     ptr[1] = (ptr[1] & 0x807F) | ((-1 + 127) << 7);
 
     return (value);
}

fs_add.asm/     1146129407  0     0     0       694       `
*;*****************************************************************************
*;                                                                            *
*;  FS_ADD v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$ADD - add two floating point numbers                                   *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_add27.inc"
        .elseif .TMS320C2800
                .include "fs_add28.inc"
        .endif
fs_add27.inc/   1146129407  0     0     0       26070     `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_ADD v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$ADD/FS$$SUB - add/sub two floating point numbers                      *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$ADD/FS$$SUB                                        HI MEMORY     *
*;                                                                            *
*;                                                               stack        *
*;                                                         +----------------+ *
*;       This routine adds or subs two floating point SP-->|                | *
*;       numbers.  Upon entry one operand (OP1) is         +----------------+ *
*;       in ACC and the other (OP2) is on the           -1 |  OP1 high mant | *
*;       stack as shown.  SP is moved to accomodate        +----------------+ *
*;       locals.  When add is finished the SP is        -2 |  OP1 low mant  | *
*;       returned to point at the return address.          +----------------+ *
*;                                                      -3 |      AR3       | *
*;       inputs:  OP1 - in ACC, OP2 - on stack             +----------------+ *
*;                                                      -4 |      AR2       | *
*;       implementation:  OP1 and OP2 are each unpacked    +----------------+ *
*;            into sign, exponent, and two words of     -5 |      AR1       | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated.     -6 |      AR0       | *
*;            In the general case, the exponents are       +----------------+ *
*;            compared and the mantissa of the lower    -7 | (return addr)  | *
*;            exponent is renormalized according to        +----------------+ *
*;            the number with the larger exponent.      -8 | (return addr)  | *
*;            The mantissas are also converted to          +----------------+ *
*;            a two's compliment format to perform      -9 |   MSW of OP2   | *
*;            the actual addition.  The result of          +----------------+ *
*;            the addition is then renormalized with   -10 |   LSW of OP2   | *
*;            corresponding adjustment in the exponent.    +----------------+ *
*;            The resulting mantissa is converted                             *
*;            back to its original sign-magnitude              LO MEMORY      *
*;            format and the result is repacked into                          *
*;            the floating point representation.                              *
*;            For cases in which the difference in           register file    *
*;            the exponents of the two input numbers,      +----------------+ *
*;            OP1 and OP2, is larger than 24 the       AR0 | OP2 low mant   | *
*;            result is the larger of the two numbers.     +----------------+ *
*;                                                     AR1 | OP2 high mant  | *
*;                                                         +----------------+ *
*;            Subtraction is implemented by negating   AR2 | res low mant   | *
*;            operand 2 and adding them.                   +----------------+ *
*;                                                     AR3 | res high mant  | *
*;                                                         +----------------+ *
*;                                                     AR4 | OP1 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR5 | OP2 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR6 | res sign       | *
*;                                                         +----------------+ *
*;                                                     AR7 | res exponent   | *
*;                                                         +----------------+ *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;    NOTE: The ordering of the locals are placed to take advantage           *
*;          of long word loads and stores which require the hi and lo         *
*;          words to be at certain addresses. Any future modifications        *
*;          which involve the stack must take this quirk into account         *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$SUB
        .global   FS$$ADD
        .sect     ".text"

        .asg      AR7,    RES_EXP
        .asg      AR3,    RES_HM
        .asg      AR2,    RES_LM
        .asg      AR6,    RES_SIGN
        .asg      AR4,    OP1_SE
        .asg      AR5,    OP2_SE
        .asg      AR1,    OP2_HM
        .asg      AR0,    OP2_LM
        .asg    *-SP[1],  OP1_HM
        .asg    *-SP[2],  OP1_LM

        .asg    *-SP[9],  OP2_MSW
        .asg    *-SP[10], OP2_LSW
        .asg    *-SP[3],  S_OP2_MSW
        .asg    *-SP[4],  S_OP2_LSW

FS$$SUB:	.asmfunc

*;*****************************************************************************
*;       SETUP                                                                *
*;       Test OP2 for zero, negate OP2 , branch to FS$$ADD                     *
*;*****************************************************************************
        MOV P,  ACC       ; save OP1
        MOV AH, S_OP2_MSW ; test if OP2 == 0
        B   CALL_ADD, EQ  ; zero is a special case, don't negate
        XOR AH, #8000h    ; xor sign bit of OP2 high mantissa
        MOV S_OP2_MSW, AH ; save OP2 back onto stack
CALL_ADD:
        MOV ACC, P        ; restore OP1
                          ; Fall through to perform add.

FS$$ADD:	
*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of AR0 - AR3, and allocate stack space for locals      *
*;*****************************************************************************
*
        PUSH    AR1:AR0
        PUSH    AR3:AR2
        ADDB    SP, #2            ; Allocate space for locals
*
*;*****************************************************************************
*;       CONFIGURE STATUS BITS                                                *
*;*****************************************************************************
*
        CLRC    SXM
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP1 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa with a long word store                            *
*;*****************************************************************************
*
        TEST    ACC
        B       OP1_ZERO, EQ      ; if OP1 is 0, jump to special case
        MOV     OP1_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
	LSL	ACC,#6		  ; Leave room for sign and overflow.
        MOV     OP1_HM, AH        ; store  high mantissa           
        MOV     AH, OP1_SE        ; restore high part containing sign & exp
        PUSH    ST0               ; remember N and Z for OP1
        LSR     AH, 7             ; remove high mantissa     
        AND     AH, #0FFh         ; remove sign
        MOV     OP1_SE, AH        ; store exponent
        POP     ST0               ; restore N and Z for OP1
        B       OP1_NONNEG, GEQ   ; if OP1 was non-negative, we're done
        MOV     AH, OP1_HM        ; restore high mantissa (AL still has LM)
        NEG     ACC               ; negate OP1 mantissa for negative values
        MOV     OP1_HM, AH        ; store high mantissa                    
OP1_NONNEG  
        MOV     OP1_LM, AL        ; store low mantissa
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP2 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa                                                   *
*;*****************************************************************************
*
        MOVL    ACC, OP2_LSW      ; load ACC with OP2
        B       OP2_ZERO, EQ      ; if OP2 is 0, jump to special case
        MOV     OP2_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
	LSL	ACC,#6		  ; Leave room for sign and overflow.
        MOV     OP2_HM, AH        ; store high mantissa
        MOV     AH, OP2_SE        ; restore high part containing sign & exp
        PUSH    ST0               ; remember N and Z for OP2
        LSR     AH, 7             ; remove high mantissa     
        AND     AH, #0FFh         ; remove sign
        MOV     OP2_SE, AH        ; store exponent
        POP     ST0               ; restore N and Z for OP2
        B       OP2_NONNEG, GEQ   ; if OP2 was non-negative, we're done
        MOV     AH, OP2_HM        ; restore high mantissa (AL still has LM)
        NEG     ACC               ; negate OP2 mantissa for negative values
        MOV     OP2_HM, AH        ; store negated high mantissa
OP2_NONNEG  
        MOV     OP2_LM, AL        ; store low mantissa
*
*;*****************************************************************************
*;       EXPONENT COMPARISON                                                  *
*;  Compare exponents of OP1 and OP2 by subtracting: exp OP2 - exp OP1        *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp OP1 is less than exp OP2                                   *
*;    Case 2:  exp OP1 is equal to exp OP2                                    *
*;    Case 3:  exp OP1 is greater than exp OP2                                *
*;*****************************************************************************
*
        SETC    SXM
        MOV     ACC, OP2_SE     ; load OP2 exponent
        SUB     ACC, OP1_SE     ; AH = exp OP2 - exp OP1
        B       OP1_GT_OP2, LT  ; process OP1 > OP2
        B       OP2_GT_OP1, GT  ; process OP1 > OP2
      ; fall through if OP1 == OP2
*
*;*****************************************************************************
*;       exp OP1 == exp OP2                                                   *
*;  Mantissas of OP1 and OP2 are normalized identically.                      *
*;  Add mantissas:  mant OP1 + mant OP2                                       *
*;  If result is zero, special case processing must be executed.              *
*;  Load exponent for possible adjustment during normalization of result      *
*;*****************************************************************************
*
        MOVL    ACC, OP1_LM     ; load OP1 mantissa
        ADDU    ACC, OP2_LM
        ADD     AH,  OP2_HM     ; add OP2 mantissa
        TEST    ACC
        B       RES_ZERO, EQ    ; If result is zero, process special case
*
*;*****************************************************************************
*;       NORMALIZE THE RESULT                                                 *
*;  Take the absolute value of the result.                                    *
*;  Set up to normalize the result.                                           *
*;    The MSB may be in any of bits 24 through 0.                             *
*;    Left shift by six bits; bit 24 moves to bit 30, etc.                    *
*;  Normalize resulting mantissa with exponent adjustment.                    *
*;*****************************************************************************
*
NORMALIZE
        MOV     RES_SIGN, AH    ; save signed mantissa
        ABS     ACC             ; create magnitude value of mantissa
        INC     OP1_SE          ; increment exp to account for implied carry
	RPT	#31
     || NORM    ACC, OP1_SE--   ; normalize result and adjust exponent
      
        MOV     RES_EXP, OP1_SE ; save result exponent
	ADD	ACC,#0x40	; Add rounding bit.

	B	NO_CARRY, GEQ	; 
	SFR     ACC,#1		; Adjust mantissa if rounding generated a carry
	INC	RES_EXP		; Adjust exponent if rounding generated a carry
NO_CARRY:
*
*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Test result for underflow and overflow.                                   *
*;  Right shift mantissa by 7 bits.                                           *
*;  Mask implied 1                                                            *
*;  Store mantissa on stack.                                                  *
*;*****************************************************************************
*
        MOV     RES_HM, AH      ; save result high mantissa
        MOV     AH, RES_EXP     ; test result exponent
        B       UNDERFLOW, LEQ  ; process underflow if occurs
        SUB     AH, #0FFh       ; adjust to check for overflow
        B       OVERFLOW, GEQ   ; process overflow if occurs
        MOV     AH, RES_HM      ; restore result high mantissa
        SFR     ACC, 7          ; shift right to place mantissa for splitting
        AND     AH, #07Fh       ; eliminate implied one
        MOV     RES_LM, AL      ; store low mantissa
        MOV     RES_HM, AH      ; store high mantissa
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
        MOV     ACC, RES_SIGN << 9 ; 0000 000S ???? ???? ???? ???0 0000 0000
        AND     AH, #100h          ; 0000 000S 0000 0000 ???? ???0 0000 0000
        MOV     AL, #0             ; 0000 000S 0000 0000 0000 0000 0000 0000
        ADD     AH, RES_EXP        ; 0000 000S EEEE EEEE 0000 0000 0000 0000
        LSL     AH, 7              ; SEEE EEEE E000 0000 0000 0000 0000 0000
        ADDU    ACC, RES_LM        ; SEEE EEEE E000 0000 MMMM MMMM MMMM MMMM
        ADD     AH, RES_HM         ; SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop AR0 - AR3                                                             *
*;*****************************************************************************
*
* entry: A - final result
*
RETURN_VALUE
OP_ZERO
        SUBB    SP, #2
        POP     AR3:AR2
        POP     AR1:AR0
        RET

        .page
*
*;*****************************************************************************
*;       exp OP1 > exp OP2                                                    *
*;  Test if the difference of the exponents is larger than 24 (precision of   *
*;  the mantissa).                                                            *
*;  Return OP1 as the result if OP2 is too small.                             *
*;  Mantissa of OP2 must be right shifted to match normalization of OP1.      *
*;  Add mantissas:  mant OP1 + mant op2                                       *
*;*****************************************************************************
*
OP1_GT_OP2
        ABS     ACC             ; if exp OP1 > exp OP2 + 24 then return OP1
        SUB     ACC, #24
        B       RETURN_OP1, GT
        ADD     ACC, #23        ; restore exponent difference value
        MOV     RES_SIGN, AL    ; store exponent difference to be used as RPC
        MOV     AH, OP2_HM      ; load OP2 high mantissa
        MOV     AL, OP2_LM      ; load OP2 low mantissa
        MOV     T, RES_SIGN
NORM12
        SFR     ACC, 1          ; normalize OP2 to match OP1
        DEC     T
        B       NORM12, GEQ

        ADDL    ACC, OP1_LM     ; add OP1 to OP2
        B       NORMALIZE, NEQ  ; branch to normalize result if ACC != 0
	B       RETURN_VALUE    ; ACC = 0, gone beyond precision
*
*;*****************************************************************************
*;       OP1 < OP2                                                            *
*;  Test if the difference of the exponents is larger than 24 (precision of   *
*;  the mantissa).                                                            *
*;  Return OP2 as the result if OP1 is too small.                             *
*;  Mantissa of OP1 must be right shifted to match normalization of OP2.      *
*;  Add mantissas:  mant OP1 + mant OP2                                       *
*;  If A = 0 then have gone beyond precision available                        *
*;*****************************************************************************
*
OP2_GT_OP1
        SUB     ACC, #24        ; if exp OP2 > exp OP1 + 24 then return OP2
        B       RETURN_OP2, GT
        ADD     ACC, #23        ; restore exponent difference value
        MOV     RES_SIGN, AL    ; store exponent difference to be used as RPC
        MOVL    ACC, OP1_LM     ; load OP1 mantissa
        MOV     T, RES_SIGN
NORM21
        SFR     ACC, 1          ; normalize OP1 to match OP2
        DEC     T
        B       NORM21, GEQ

        MOV     OP1_SE, OP2_SE  ; load exponent value to prep for normalization
        ADDU    ACC, OP2_LM
        ADD     AH, OP2_HM      ; add OP2 to OP1
        TEST    ACC
        B       NORMALIZE, NEQ  ; branch to normalize result if ACC != 0
        B       RETURN_VALUE    ; ACC = 0, gone beyond precision

*
*;*****************************************************************************
*;       OP1 << OP2  or OP1 = 0                                               *
*;*****************************************************************************
*
RETURN_OP2
OP1_ZERO
        MOVL    ACC, OP2_LSW    ; put OP2 as result into A
        B       RETURN_VALUE

*
*;*****************************************************************************
*;       OP1 << OP2  or  OP1 = 0                                              *
*;*****************************************************************************
*
OP2_ZERO
RETURN_OP1
        MOVL    ACC, OP1_LM       ; load signed mantissa of OP1
        B       OP1_POS, GT       ; if mantissa is negative . . .
        NEG     ACC               ; negate it to make it a positive value
        ADD     OP1_SE, #100h     ; place the sign value back into OP1_SE
OP1_POS
	SFR	ACC,#6		  ;
        SUB     AH, #80h          ; eliminate implied one from mantissa
        MOV     P, ACC            ; transfer result to P
        MOV     AH, OP1_SE
        LSL     AH, 7
        ADD     PH, AH            ; put OP1 back together in P as a result
        MOV     ACC, P            ; transfer result back to ACC
        B       RETURN_VALUE

         .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, RES_SIGN    ; pack sign of result
        AND     AH, #8000h      ; mask to get sign
        ADD     AH, #07F7Fh     ; result exponent = 0FEh
                                ; result high mant = 07Fh
        MOV     AL, #0FFFFh     ; result low mantissa = 0FFFFh
        B       RETURN_VALUE
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
UNDERFLOW
RES_ZERO
        MOV     ACC, #0         ; For underflow result = 0
        B       RETURN_VALUE
	.endasmfunc

fs_add28.inc/   1146129407  0     0     0       23322     `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_ADD v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$ADD/FS$$SUB - add/sub two floating point numbers                      *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$ADD/FS$$SUB                                        HI MEMORY      *
*;                                                                            *
*;                                                               stack        *
*;                                                         +----------------+ *
*;       This routine adds/subs two floating          SP-->|                | *
*;       poing numbers.  Upon entry one operand (OP1) is   +----------------+ *
*;       in ACC and the other (OP2) is on the        -1 -2 |     XAR1       | *
*;       stack as shown.  SP is moved to accomodate        +----------------+ *
*;       locals.  When add is finished the SP is     -3 -4 |     XAR2       | *
*;       returned to point at the return address.          +----------------+ *
*;                                                   -5 -6 | (return addr)  | *
*;       inputs:  OP1 - in ACC, OP2 - on stack             +----------------+ *
*;                                                      -7 |   MSW of OP2   | *
*;       implementation:  OP1 and OP2 are each unpacked    +----------------+ *
*;            into sign, exponent, and two words of     -8 |   LSW of OP2   | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated.                           *
*;            In the general case, the exponents are           LO MEMORY      *
*;            compared and the mantissa of the lower                          *
*;            exponent is renormalized according to                           *
*;            the number with the larger exponent.           register file    *
*;            The mantissas are also converted to          +----------------+ *
*;            a two's compliment format to perform    XAR0 | OP2 mantissa   | *
*;            the actual addition.  The result of          +----------------+ *
*;            the addition is then renormalized with  XAR1 | OP1 mantissa   | *
*;            corresponding adjustment in the exponent.    +----------------+ *
*;            The resulting mantissa is converted     XAR2 | Result mantissa| *
*;            back to its original sign-magnitude          +----------------+ *
*;            format and the result is repacked into   AR4 | OP1 sign & exp | *
*;            the floating point representation.           +----------------+ *
*;            For cases in which the difference in     AR5 | OP2 sign & exp | *
*;            the exponents of the two input numbers,      +----------------+ *
*;            OP1 and OP2, is larger than 24 the       AR6 | res sign       | *
*;            result is the larger of the two numbers.     +----------------+ *
*;                                                     AR7 | res exponent   | *
*;                                                         +----------------+ *
*;            Subtraction is implemented by negting the second operand        *
*;            and adding the operands.                                        *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;    NOTE: The ordering of the locals are placed to take advantage           *
*;          of long word loads and stores which require the hi and lo         *
*;          words to be at certain addresses. Any future modifications        *
*;          which involve the stack must take this quirk into account         *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$SUB
        .global   FS$$ADD

        .sect     ".text"

        .asg     XAR0,    OP2_M
        .asg     XAR1,    OP1_M 
        .asg     XAR2,    RES_M
        .asg      AR4,    OP1_SE
        .asg     XAR4,    XOP1_SE
        .asg      AR5,    OP2_SE
        .asg      AR6,    RES_SIGN
        .asg      AR7,    RES_EXP

        .asg    *-SP[7], OP2_MSW
        .asg    *-SP[8], OP2_LSW
        .asg    *-SP[3], S_OP2_MSW
        .asg    *-SP[4], S_OP2_LSW

FS$$SUB:	.asmfunc

*;*****************************************************************************
*;       SETUP                                                                *
*;       Test OP2 for zero, negate OP2 , branch to FS$$ADD                     *
*;*****************************************************************************
	CMP S_OP2_MSW, #0     ; test if OP2 == 0
        B   FS$$ADD, EQ       ; zero is a special case, don't negate
        XOR S_OP2_MSW, #8000h ; negate OP2                        
			      ; fall through to perform add 

FS$$ADD:
*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of XAR1 and XAR2                                       *
*;*****************************************************************************
*
        PUSH    XAR1
        PUSH    XAR2

*
*;*****************************************************************************
*;       CONFIGURE STATUS BITS                                                *
*;*****************************************************************************
*
        CLRC    SXM
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP1 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa with a long word store                            *
*;*****************************************************************************
*
        TEST    ACC
        B       OP1_ZERO, EQ      ; if OP1 is 0, jump to special case
	MOVL	RES_M, ACC	  ; Save OP1 in case OP2 is zero.
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
	LSL	ACC,#6		  ; Leave room for sign and overflow.
	MOVL	OP1_M, ACC	  ;
        MOVL    ACC, RES_M        ; restore high part containing sign&exp to AH
        PUSH    ST0               ; remember N and Z for OP1
        LSR     AH, 7             ; remove high mantissa     
        AND     AH, #0FFh         ; remove sign
        MOVZ    OP1_SE, AH        ; store exponent
        POP     ST0               ; restore N and Z for OP1
        B       OP1_NONNEG, GEQ   ; if OP1 was non-negative, we're done
	MOVL	ACC, OP1_M
        NEG     ACC               ; negate OP1 mantissa for negative values
	MOVL	OP1_M, ACC	  ;
OP1_NONNEG  
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP2 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa                                                   *
*;*****************************************************************************
*
        MOVL    ACC, OP2_LSW      ; load ACC with OP2
        B       OP2_ZERO, EQ      ; if OP2 is 0, jump to special case
        MOVZ    OP2_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
	LSL	ACC,#6		  ; Leave room for sign and overflow.
	MOVL	OP2_M, ACC	  ; Store mantissa
        MOV     AH, OP2_SE        ; restore high part containing sign & exp
        PUSH    ST0               ; remember N and Z for OP2
        LSR     AH, 7             ; remove high mantissa     
        AND     AH, #0FFh         ; remove sign
        MOVZ    OP2_SE, AH        ; store exponent
        POP     ST0               ; restore N and Z for OP2
        B       OP2_NONNEG, GEQ   ; if OP2 was non-negative, we're done
	MOVL	ACC,OP2_M	  ; restore mantissa.
        NEG     ACC               ; negate OP2 mantissa for negative values
	MOVL	OP2_M, ACC	  ; store negated mantissa.
OP2_NONNEG  
*
*;*****************************************************************************
*;       EXPONENT COMPARISON                                                  *
*;  Compare exponents of OP1 and OP2 by subtracting: exp OP2 - exp OP1        *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp OP1 is less than exp OP2                                   *
*;    Case 2:  exp OP1 is equal to exp OP2                                    *
*;    Case 3:  exp OP1 is greater than exp OP2                                *
*;*****************************************************************************
*
        SETC    SXM
        MOV     ACC, OP2_SE     ; load OP2 exponent
        SUB     ACC, OP1_SE     ; AH = exp OP2 - exp OP1
        B       OP1_GT_OP2, LT  ; process OP1 > OP2
        B       OP2_GT_OP1, GT  ; process OP1 > OP2
      ; fall through if OP1 == OP2
*
*;*****************************************************************************
*;       exp OP1 == exp OP2                                                   *
*;  Mantissas of OP1 and OP2 are normalized identically.                      *
*;  Add mantissas:  mant OP1 + mant OP2                                       *
*;  If result is zero, special case processing must be executed.              *
*;  Load exponent for possible adjustment during normalization of result      *
*;*****************************************************************************
*
	MOVL	ACC, OP1_M	; load OP1 mantissa.
	ADDL	ACC, OP2_M	; add OP2 mantissa.
        B       RES_ZERO, EQ    ; If result is zero, process special case
*
*;*****************************************************************************
*;       NORMALIZE THE RESULT                                                 *
*;  Take the absolute value of the result.                                    *
*;  Set up to normalize the result.                                           *
*;    The MSB may be in any of bits 24 through 0.                             *
*;    Left shift by six bits; bit 24 moves to bit 30, etc.                    *
*;  Normalize resulting mantissa with exponent adjustment.                    *
*;*****************************************************************************
*
NORMALIZE
        MOV     RES_SIGN, AH    ; save signed mantissa
        ABS     ACC             ; create magnitude value of mantissa
        INC     OP1_SE          ; increment exp to account for implied carry

	RPT	#31
     || NORM	ACC, XOP1_SE--  ; normalize result and adjust exponent

	MOV	RES_EXP, OP1_SE	; save result exponent
	ADD	ACC,#0x40	; Add rounding bit.

	B	NO_CARRY, GEQ	; 
	SFR     ACC,#1		; Adjust mantissa if rounding generated a carry
	INC	RES_EXP		; Adjust exponent if rounding generated a carry
NO_CARRY:

*
*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Test result for underflow and overflow.                                   *
*;  Right shift mantissa by 7 bits.                                           *
*;  Mask implied 1                                                            *
*;  Store mantissa on stack.                                                  *
*;*****************************************************************************
*
	MOVL	RES_M,ACC	; save result mantissa
        MOV     AH, RES_EXP     ; test result exponent
        B       UNDERFLOW, LEQ  ; process underflow if occurs
        SUB     AH, #0FFh       ; adjust to check for overflow
        B       OVERFLOW, GEQ   ; process overflow if occurs
	MOVL	ACC, RES_M	; Restore result mantissa
        SFR     ACC, 7          ; shift right to place mantissa for splitting
        AND     AH, #07Fh       ; eliminate implied one
	MOVL	RES_M, ACC	; Store result mantissa.
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
        MOV     ACC, RES_SIGN << 9 ; 0000 000S ???? ???? ???? ???0 0000 0000
        AND     AH, #100h          ; 0000 000S 0000 0000 ???? ???0 0000 0000
        MOV     AL, #0             ; 0000 000S 0000 0000 0000 0000 0000 0000
        ADD     AH, RES_EXP        ; 0000 000S EEEE EEEE 0000 0000 0000 0000
        LSL     AH, 7              ; SEEE EEEE E000 0000 0000 0000 0000 0000
        ADDL    ACC, RES_M         ; SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop XAR1 and XAR2                                                         *
*;*****************************************************************************
*
* entry: A - final result
*
RETURN_VALUE
        POP     XAR2
        POP     XAR1
        LRETR

        .page
*
*;*****************************************************************************
*;       exp OP1 > exp OP2                                                    *
*;  Test if the difference of the exponents is larger than 24 (precision of   *
*;  the mantissa).                                                            *
*;  Return OP1 as the result if OP2 is too small.                             *
*;  Mantissa of OP2 must be right shifted to match normalization of OP1.      *
*;  Add mantissas:  mant OP1 + mant op2                                       *
*;*****************************************************************************
*
OP1_GT_OP2
        ABS     ACC             ; if exp OP1 > exp OP2 + 24 then return OP1
        SUB     ACC, #24
        B       RETURN_OP1, GT
        ADD     ACC, #24        ; restore exponent difference value
        MOV     RES_SIGN, AL    ; store exponent difference to be used as RPC
	MOVL	ACC, OP2_M	;
        MOV     T, RES_SIGN
	ASRL	ACC,T		;

	ADDL	ACC, OP1_M	; add OP1 to OP2
        B       NORMALIZE,NEQ   ; branch to normalize result if ACC != 0
	B       RETURN_VALUE,UNC ; ACC = 0, gone beyond precision
*
*;*****************************************************************************
*;       OP1 < OP2                                                            *
*;  Test if the difference of the exponents is larger than 24 (precision of   *
*;  the mantissa).                                                            *
*;  Return OP2 as the result if OP1 is too small.                             *
*;  Mantissa of OP1 must be right shifted to match normalization of OP2.      *
*;  Add mantissas:  mant OP1 + mant OP2                                       *
*;  If A = 0 then have gone beyond precision available                        *
*;*****************************************************************************
*
OP2_GT_OP1
        SUB     ACC, #24        ; if exp OP2 > exp OP1 + 24 then return OP2
        B       RETURN_OP2, GT
        ADD     ACC, #24        ; restore exponent difference value
        MOV     RES_SIGN, AL    ; store exponent difference to be used as RPC
        MOVL    ACC, OP1_M      ; load OP1 mantissa
        MOV     T, RES_SIGN
	ASRL	ACC,T		;

        MOVZ    OP1_SE, OP2_SE  ; load exponent value to prep for normalization
	ADDL	ACC, OP2_M	; add OP2 to OP1
        B       NORMALIZE, NEQ  ; branch to normalize result if ACC != 0
        B       RETURN_VALUE,UNC ; ACC = 0, gone beyond precision

*
*;*****************************************************************************
*;       OP1 << OP2  or OP1 = 0                                               *
*;*****************************************************************************
*
RETURN_OP2
OP1_ZERO
        MOVL    ACC, OP2_LSW    ; put OP2 as result into A
        B       RETURN_VALUE,UNC

*
*;*****************************************************************************
*;       OP1 << OP2  or  OP1 = 0                                              *
*;*****************************************************************************
*
OP2_ZERO
RETURN_OP1
	MOVL	ACC, RES_M	  ; Restore OP1
        B       RETURN_VALUE,UNC

         .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, RES_SIGN    ; pack sign of result
        AND     AH, #8000h      ; mask to get sign
        ADD     AH, #07F7Fh     ; result exponent = 0FEh
                                ; result high mant = 07Fh
        MOV     AL, #0FFFFh     ; result low mantissa = 0FFFFh
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
UNDERFLOW
RES_ZERO
        MOV     ACC, #0         ; For underflow result = 0
        B       RETURN_VALUE,UNC
	.endasmfunc

fs_cmp.asm/     1146129407  0     0     0       694       `
*;*****************************************************************************
*;                                                                            *
*;  FS_CMP v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$CMP - compare two floating point numbers                               *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_cmp27.inc"
        .elseif .TMS320C2800
                .include "fs_cmp28.inc"
        .endif
fs_cmp27.inc/   1146129407  0     0     0       8803      `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_CMP v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$CMP - compare two floating point numbers                               *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$CMP                                                HI MEMORY      *
*;                                                                            *
*;       This routine compares two floating point                stack        *
*;       numbers.  Upon entry, one number is on ACC        +----------------+ *
*;       (OP1) and the other is in the stack as       SP-->|                | *
*;       shown (OP2).  The routine returns a               +----------------+ *
*;       positive 1 if OP1 is greater than OP2, a       -1 | (return addr)  | *
*;       negative 1 if OP1 is less than OP2, and           +----------------+ *
*;       returns 0 if OP1 is equal to OP2.              -2 | (return addr)  | *
*;       It is up to the calling program to interpret      +----------------+ *
*;       the results.                                   -3 |   MSW of OP2   | *
*;                                                         +----------------+ *
*;       inputs:  OP1 and OP2 (floating point numbers)  -4 |   LSW of OP2   | *
*;                                                         +----------------+ *
*;       implementation:  Uses the MAX and MIN                                *
*;            instructions to determine which operand          LO MEMORY      *
*;            is larger.                                                      *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                OP1 >  OP2 :  return 1                                      *
*;                OP1 <  OP2 :  return -1                                     *
*;                OP1 == OP2 :  return 0                                      *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$CMP
        .sect     ".text"

FS$$CMP:	.asmfunc
        .asg    *-SP[3], OP2_MSW
        .asg    *-SP[4], OP2_LSW

*;*****************************************************************************
*;       COMPARISON OF OP1 and OP2                                            *
*;  There are three cases (directly reflecting the value in the accumulator). *
*;    Case 1:  OP1 is greater than OP2.                                       *
*;    Case 2:  OP1 is equal to OP2                                            *
*;    Case 3:  OP1 is less than OP2                                           *
*;*****************************************************************************
*
        CMPL   ACC, OP2_LSW         ; compare the two operands
        B      OPS_EQ, EQ           ; branch if OP1 == OP2
        B      OP1_GT_OP2, GT       ; branch if OP1 > OP2
        MOV    AR4, #-1             ; set AR4 to -1 if OP1 < OP2
        B      CHECK_SIGNS
OP1_GT_OP2
        MOV    AR4, #1              ; set AR4 to 1 if OP1 > OP2
        B      CHECK_SIGNS
OPS_EQ
        MOV    AR4, #0              ; set AR4 to 0 if OP1 == OP2
CHECK_SIGNS
        MOV    AR5, #2              ; initialize AR5 to 2                      
        TBIT   AH, #15              ; test to see if OP1 is negative        
        B      OP1_NONNEG, NTC      ; branch if OP1 is non-negative          
        DEC    AR5                  ; decrememt AR5 if OP1 is negative       
OP1_NONNEG
        TBIT   OP2_MSW, #15         ; test to see if OP2 is negative
        B      OP2_NONNEG, NTC      ; branch if OP2 is non-negative
        DEC    AR5                  ; decrement AR5 if OP2 is negative
OP2_NONNEG
        SETC   SXM                  ; sign extend the next move
        MOV    ACC, AR4             ; move the result from AR4 to ACC
        CMP    AR5, #0              ; test to see if both operands are
                                    ; negative (AR5 == 0)
        B      DONE, GT             ; branch if either operand is non-negative
        NEG    ACC                  ; if OP1 and OP2 are both negative,
                                    ; then reverse the result
DONE
        RET
	.endasmfunc

fs_cmp28.inc/   1146129407  0     0     0       8815      `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_CMP v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$CMP - compare two floating point numbers                               *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$CMP                                                HI MEMORY      *
*;                                                                            *
*;       This routine compares two floating point                stack        *
*;       numbers.  Upon entry, one number is on ACC        +----------------+ *
*;       (OP1) and the other is in the stack as       SP-->|                | *
*;       shown (OP2).  The routine returns a               +----------------+ *
*;       positive 1 if OP1 is greater than OP2, a       -1 | (return addr)  | *
*;       negative 1 if OP1 is less than OP2, and           +----------------+ *
*;       returns 0 if OP1 is equal to OP2.              -2 | (return addr)  | *
*;       It is up to the calling program to interpret      +----------------+ *
*;       the results.                                   -3 |   MSW of OP2   | *
*;                                                         +----------------+ *
*;       inputs:  OP1 and OP2 (floating point numbers)  -4 |   LSW of OP2   | *
*;                                                         +----------------+ *
*;       implementation:  Uses the MAX and MIN                                *
*;            instructions to determine which operand          LO MEMORY      *
*;            is larger.                                                      *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                OP1 >  OP2 :  return 1                                      *
*;                OP1 <  OP2 :  return -1                                     *
*;                OP1 == OP2 :  return 0                                      *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$CMP
        .sect     ".text"

FS$$CMP:	.asmfunc
        .asg    *-SP[3], OP2_MSW
        .asg    *-SP[4], OP2_LSW

*;*****************************************************************************
*;       COMPARISON OF OP1 and OP2                                            *
*;  There are three cases (directly reflecting the value in the accumulator). *
*;    Case 1:  OP1 is greater than OP2.                                       *
*;    Case 2:  OP1 is equal to OP2                                            *
*;    Case 3:  OP1 is less than OP2                                           *
*;*****************************************************************************
*
        CMPL   ACC, OP2_LSW         ; compare the two operands
        B      OPS_EQ, EQ           ; branch if OP1 == OP2
        B      OP1_GT_OP2, GT       ; branch if OP1 > OP2
        MOV    AR4, #-1             ; set AR4 to -1 if OP1 < OP2
        B      CHECK_SIGNS,UNC
OP1_GT_OP2
        MOVB   XAR4, #1             ; set AR4 to 1 if OP1 > OP2
        B      CHECK_SIGNS,UNC
OPS_EQ
        MOVB   XAR4, #0             ; set AR4 to 0 if OP1 == OP2
CHECK_SIGNS
        MOVB   XAR5, #2             ; initialize AR5 to 2                      
        TBIT   AH, #15              ; test to see if OP1 is negative        
        B      OP1_NONNEG, NTC      ; branch if OP1 is non-negative          
        DEC    AR5                  ; decrememt AR5 if OP1 is negative       
OP1_NONNEG
        TBIT   OP2_MSW, #15         ; test to see if OP2 is negative
        B      OP2_NONNEG, NTC      ; branch if OP2 is non-negative
        DEC    AR5                  ; decrement AR5 if OP2 is negative
OP2_NONNEG
        SETC   SXM                  ; sign extend the next move
        MOV    ACC, AR4             ; move the result from AR4 to ACC
        CMP    AR5, #0              ; test to see if both operands are
                                    ; negative (AR5 == 0)
        B      DONE, GT             ; branch if either operand is non-negative
        NEG    ACC                  ; if OP1 and OP2 are both negative,
                                    ; then reverse the result
DONE
        LRETR
	.endasmfunc


fs_div.asm/     1146129407  0     0     0       696       `
*;*****************************************************************************
*;                                                                            *
*;  FS_DIV v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$DIV - divide two floating point numbers                                *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_div27.inc"
        .elseif .TMS320C2800
                .include "fs_div28.inc"
        .endif

fs_div27.inc/   1146129407  0     0     0       26190     `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_DIV v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$DIV - divide two floating point numbers                                *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$DIV                                                HI MEMORY      *
*;                                                                            *
*;                                                               stack        *
*;                                                         +----------------+ *
*;       This routine divides two floating point      SP-->|                | *
*;       numbers.  Upon entry one operand (OP1) is         +----------------+ *
*;       in ACC and the other (OP2) is on the           -1 |  OP1 high mant | *
*;       stack as shown.  SP is moved to accomodate        +----------------+ *
*;       locals.  When division is finished the SP is   -2 |  OP1 low mant  | *
*;       returned to point at the return address.          +----------------+ *
*;                                                      -3 |      AR3       | *
*;       inputs:  OP1 - in ACC, OP2 - on stack             +----------------+ *
*;                                                      -4 |      AR2       | *
*;       implementation:  OP1 and OP2 are each unpacked    +----------------+ *
*;            into sign, exponent, and two words of     -5 |      AR1       | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated.     -6 |      AR0       | *
*;            The difference of the exponents are taken.   +----------------+ *
*;            IF the result is less than zero underflow -7 | (return addr)  | *
*;            has occurred.  If the result is zero,        +----------------+ *
*;            underflow may have occurred.  If the      -8 | (return addr)  | *
*;            result is equal to 254 overflow may          +----------------+ *
*;            have occurred.  If the result is          -9 |   MSW of OP2   | *
*;            greater than 254 overflow has occurred.      +----------------+ *
*;            Underflow processing returns a value     -10 |   LSW of OP2   | *
*;            of zero.  Overflow processing returns        +----------------+ *
*;            the largest magnitude value along with                          *
*;            the appropriate sign.  If no special             LO MEMORY      *
*;            cases are detected, a 24x24-bit                                 *
*;            divide is executed.  The result of                              *
*;            the eXclusive OR of the sign bits, the         register file    *
*;            difference of the exponents and the 24       +----------------+ *
*;            bit truncated mantissa are packed and    AR0 | OP2 low mant   | *
*;            returned.                                    +----------------+ *
*;                                                     AR1 | OP2 high mant  | *
*;                                                         +----------------+ *
*;                                                     AR2 | res low mant   | *
*;                                                         +----------------+ *
*;                                                     AR3 | res high mant  | *
*;                                                         +----------------+ *
*;                                                     AR4 | OP1 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR5 | OP2 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR6 | res sign       | *
*;                                                         +----------------+ *
*;                                                     AR7 | res exponent   | *
*;                                                         +----------------+ *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;    NOTE: The ordering of the locals are placed to take advantage           *
*;          of long word loads and stores which require the hi and lo         *
*;          words to be at certain addresses. Any future modifications        *
*;          which involve the stack must take this quirk into account         *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$DIV
        .sect     ".text"

FS$$DIV:	.asmfunc
        .asg      AR7,    RES_EXP
        .asg      AR3,    RES_HM
        .asg      AR2,    RES_LM
        .asg      AR6,    RES_SIGN
        .asg      AR4,    OP1_SE
        .asg      AR5,    OP2_SE
        .asg      AR1,    OP2_HM
        .asg      AR0,    OP2_LM
        .asg    *-SP[1],  OP1_HM
        .asg    *-SP[2],  OP1_LM

        .asg    *-SP[9],  OP2_MSW
        .asg    *-SP[10], OP2_LSW

*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of AR0 - AR3, and allocate stack space for locals      *
*;*****************************************************************************
*
        PUSH    AR1:AR0
        PUSH    AR3:AR2
        ADDB    SP, #2            ; Allocate space for locals
*
*;*****************************************************************************
*;       CONFIGURE STATUS BITS                                                *
*;*****************************************************************************
*
        CLRC    SXM
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP1 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa with a long word store                            *
*;*****************************************************************************
*
        TEST    ACC
        B       OP1_ZERO, EQ      ; if OP1 is 0, jump to special case
        MOV     OP1_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOVL    OP1_LM, ACC       ; store mantissa           
        MOV     AH, OP1_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOV     OP1_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP2 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa                                                   *
*;*****************************************************************************
*
        MOVL    ACC, OP2_LSW      ; load ACC with OP2
        B       OP2_ZERO, EQ      ; if OP2 is 0, divide by zero
        MOV     OP2_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOV     OP2_HM, AH
        MOV     OP2_LM, AL        ; store mantissa
        MOV     AH, OP2_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOV     OP2_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of OP1 and OP2 to determine sign of result.        *
*;*****************************************************************************
*
        MOV     AH, OP1_SE        ; load sign and exp of op1 to AH
        XOR     AH, OP2_SE        ; xor with op2 to get sign of result
        AND     AH, #00100h       ; mask to get sign
        MOV     RES_SIGN, AH      ; save sign of result to stack
*
*;*****************************************************************************
*;       EXPONENT SUMMATION                                                   *
*;  Find difference between operand exponents to determine the result         *
*;  exponent.  Since the subtraction process removes the bias it must be      *
*;  re-added in.
*;                                                                            *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp OP1 + exp OP2 results in underflow (exp < 0)               *
*;    Case 2:  exp OP1 + exp OP2 results in overflow (exp >= 0FFh)            *
*;    Case 3:  exp OP1 + exp OP2 results are in range (exp >= 0 & exp < 0FFh) *
*;      NOTE:  Cases when result exp = 0 may result in underflow unless there *
*;             is a carry in the result that increments the exponent to 1.    *
*;             Cases when result exp = 0FEh may result in overflow if there   *
*;             is a carry in the result that increments the exponent to 0FFh. *
*;*****************************************************************************
*
         AND    OP1_SE, #0FFh     ; Mask OP1 exponent
         AND    OP2_SE, #0FFh     ; Mask OP2 exponent
         ADDB   OP1_SE, #07Fh     ; Add offset (difference eliminates offset) 
         MOV    AL, OP1_SE
         SUB    AL, OP2_SE        ; Take difference between exponents
         MOV    RES_EXP, AL       ; Save result exponent on stack
*
         B      UNDERFLOW, LT     ; branch to underflow handler if exp < 0
         SUB    AL, #0FFh         ; test for overflow
         B      OVERFLOW, GT      ; branch to overflow is exp > 127
*
*;*****************************************************************************
*;       DIVISION                                                             *
*;  Division is implemented by parts.  The mantissas for both OP1 and OP2 are *
*;  left shifted in the 32 bit field to reduce the effect of secondary and    *
*;  tertiary contributions to the final result.  The left shifted results     *
*;  are identified as OP1'HI, OP1'LO, OP2'HI, and OP2'LO where OP1'HI and     *
*;  OP2'HI have the xx most significant bits of the mantissas and OP1'LO      *
*;  and OP2'LO contain the remaining bits of each mantissa.  Let QHI and      *
*;  QLO represent the two portions of the resultant mantissa.  Then           *
*;                                                                            *
*;                 OP1'HI + OP1'LO     OP1'HI + OP1'LO          1             *
*;   QHI + QLO  =  ---------------  =  ---------------  * ----------------- . *
*;                 OP2'HI + OP2'LO         OP2'HI        (1 + OP2'LO/OP2'HI)  *
*;                                                                            *
*;   Now let   X = OP2'LO/OP2'HI.                                             *
*;                                                                            *
*;   Then by Taylor's Series Expansion,                                       *
*;                                                                            *
*;               1                2    3                                      *
*;             -----  =  1 - X + X  - X  +  ...                               *
*;             (1+X)                                                          *
*;                                                                            *
*;   Since OP2'HI contains the first xx significant bits of the OP2 mantissa, *
*;                                                                            *
*;                               -yy                                          *
*;          X = OP2'LO/OP2'HI < 2   .                                         *
*;                                                                            *
*;   Therefore the X**2 term and all subsequent terms are less than the       *
*;   least significant bit of the 24-bit result and can be dropped.           *
*;   The result then becomes                                                  *
*;                                                                            *
*;                 OP1'HI + OP1'LO          1                                 *
*;   QHI + QLO  =  ---------------  * ----------------                        *
*;                     OP2'HI        (1 + OP2'LO/OP2'HI)                      *
*;                                                                            *
*;                 OP1'HI + OP1'LO          OP2'LO                            *
*;              =  ---------------  * ( 1 - ------ )                          *
*;                     OP2'HI               OP2'HI                            *
*;                                                                            *
*;                                       OP2'LO                               *
*;               = (Q'HI + Q'LO) * ( 1 - ------ )                             *
*;                                       OP2'HI                               *
*;                                                                            *
*;    where Q'HI and Q'LO represent the first approximation of the result.    *
*;    Also since Q'LO and OP2'LO/OP2'HI are less significant the 24th bit of  *
*;    the result, this product term can be dropped so that                    *
*;                                                                            *
*;     QHI + QLO  =  Q'HI + Q'LO - (Q'HI * OP2'LO)/OP2'HI .                   *
*;                                                                            *
*;*****************************************************************************
*
        MOV     AH, OP2_HM
        MOV     AL, OP2_LM        ; Load divisor mantissa
        LSL     ACC, 7            ; Shift divisor in preparation for division
        MOV     OP2_HM, AH
        MOV     OP2_LM, AL        ; Save off divisor

        MOVL    ACC, OP1_LM       ; Load dividend mantissa
        LSL     ACC, 6            ; Shift dividend in preparation for division

        RPT     #14               ; QHI = OP1'HI/OP2'HI
     || SUBCU   ACC, OP2_HM
        MOV     RES_HM, AL        ; Save QHI

        SUBU    ACC, RES_HM       ; Clear QHI from ACC
        RPT     #10               ; Q'LO = OP1'LO / OP2'HI
     || SUBCU   ACC, OP2_HM
        MOV     RES_LM, ACC << 5  ; Save Q'LO

        MOV     T, RES_HM         ; T = Q'HI
        MPYU    ACC, T, OP2_LM    ; Store Q'HI * OP2'LO in acc A
        SFR     ACC, 1

        RPT     #11               ; Calculate Q'HI * OP2'LO / OP2'HI
     || SUBCU   ACC, OP2_HM       ;   (correction factor)
        LSL     ACC, 4            ; Left shift to bring it to proper range
        MOV     AH, #0            ; Mask off correction factor
        LSL     ACC, 1

        NEG     ACC               ; Subtract correction factor
        ADDCU   ACC, RES_LM       ; Add Q'LO
        ADD     AH, RES_HM        ; Add Q'HI
*	
*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Set up to adjust the normalized result.                                   *
*;    The MSB may be in bit 31.  Test this case and increment the exponent    *
*;    and right shift mantissa 1 bit so result is in bits 30 through 7.       *
*;  Right shift mantissa by 7 bits.                                           *
*;  Store low mantissa on stack.                                              *
*;  Mask implied 1 and store high mantissa on stack.                          *
*;  Test result for underflow and overflow.                                   *
*;*****************************************************************************
*
        SFR     ACC, 1          ; MSB may be in bit 31; shift so we don't
                                ; lose any mantissa during normalization
        ADD     RES_EXP, #1     ; adjust exponent

	RPT	#31
     || NORM    ACC, RES_EXP--  ; normalize the result, and adjust exponent

        ADDB    ACC, #020h      ; add rounding bit
        SFR     ACC, 1          ; addition may result in carry, so shift
                                ; before normalizing to make sure mantissa is
                                ; preserved
        ADD     RES_EXP, #1     ; adjust exponent

	RPT	#31
     || NORM    ACC, RES_EXP--  ; normalize after rounding, and adjust exponent

        MOV     P, ACC          ; save ACC
        MOV     AL, RES_EXP     ; test exponent
        B       UNDERFLOW, LEQ  ; process underflow if it occurs
        SUB     AL, #0FFh       ; adjust to check for overflow
        B       OVERFLOW, GEQ   ; process overflow if it occurs
        MOV     ACC, P          ; restore ACC
        SFR     ACC, 7          ; shift right to place mantissa for splitting
        AND     AH, #07Fh       ; remove implied one
        MOV     RES_HM, AH
        MOV     RES_LM, AL      ; save result mantissa
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
        MOV     ACC, RES_SIGN << 16  ; 0000 000S 0000 0000 0000 0000 0000 0000
        ADD     AH, RES_EXP          ; 0000 000S EEEE EEEE 0000 0000 0000 0000
        LSL     AH, 7                ; SEEE EEEE E000 0000 0000 0000 0000 0000
        ADDCU   ACC, RES_LM          ; SEEE EEEE E000 0000 MMMM MMMM MMMM MMMM
        ADD     AH, RES_HM           ; SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop AR0 - AR3                                                             *
*;*****************************************************************************
*
* entry: A - final result
*
RETURN_VALUE
OP1_ZERO
        SUBB    SP, #2
        POP     AR3:AR2
        POP     AR1:AR0
        RET

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #0            ; Expand value in AL to occupy all of ACC
        SAT     ACC               ; Result exponent  = 0FEh
        SUB     AH, #081h         ; Result high mant = 07Fh
        MOV     P, ACC            ; Move result to P
        MOV     AH, RES_SIGN      ; Calculate sign of result
        B       RETURN_VALUE, NEQ
        MOV     AH, #8000h
        XOR     AH, PH
        MOV     AL, PL
        B       RETURN_VALUE
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
UNDERFLOW
        MOV     ACC, #0 
        B       RETURN_VALUE
*
*;*****************************************************************************
*;       DIVIDE BY ZERO                                                       *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OP2_ZERO
        MOV     P, ACC          ; Save ACC
        MOV     AH, OP1_SE      ; Load sign and exponent of OP1
        AND     AH, #100h       ; Mask to get sign of OP1
        LSL     AH, 7
        MOV     OP1_SE, AH      ; Store sign
        MOV     ACC, P          ; Restore ACC

        SUB     AH,  #081h      ; Result high mant = 7Fh
        XOR     AH,  #8000h
        OR      AH,  OP1_SE     ; Pack sign
        B       RETURN_VALUE
	.endasmfunc
fs_div28.inc/   1146129407  0     0     0       26341     `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_DIV v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$DIV - divide two floating point numbers                                *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$DIV                                                HI MEMORY      *
*;                                                                            *
*;                                                               stack        *
*;                                                         +----------------+ *
*;       This routine divides two floating point      SP-->|                | *
*;       numbers.  Upon entry one operand (OP1) is         +----------------+ *
*;       in ACC and the other (OP2) is on the           -1 |  OP1 high mant | *
*;       stack as shown.  SP is moved to accomodate        +----------------+ *
*;       locals.  When division is finished the SP is   -2 |  OP1 low mant  | *
*;       returned to point at the return address.          +----------------+ *
*;                                                   -3 -4 |     XAR3       | *
*;       inputs:  OP1 - in ACC, OP2 - on stack             +----------------+ *
*;                                                   -5 -6 |     XAR2       | *
*;       implementation:  OP1 and OP2 are each unpacked    +----------------+ *
*;            into sign, exponent, and two words of  -7 -8 |     XAR1       | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated. -9 -10 |     XAR0       | *
*;            The difference of the exponents are taken.   +----------------+ *
*;            IF the result is less than zero underflow-11 | (return addr)  | *
*;            has occurred.  If the result is zero,        +----------------+ *
*;            underflow may have occurred.  If the     -12 | (return addr)  | *
*;            result is equal to 254 overflow may          +----------------+ *
*;            have occurred.  If the result is         -13 |   MSW of OP2   | *
*;            greater than 254 overflow has occurred.      +----------------+ *
*;            Underflow processing returns a value     -14 |   LSW of OP2   | *
*;            of zero.  Overflow processing returns        +----------------+ *
*;            the largest magnitude value along with                          *
*;            the appropriate sign.  If no special             LO MEMORY      *
*;            cases are detected, a 24x24-bit                                 *
*;            divide is executed.  The result of                              *
*;            the eXclusive OR of the sign bits, the         register file    *
*;            difference of the exponents and the 24       +----------------+ *
*;            bit truncated mantissa are packed and    AR0 | OP2 low mant   | *
*;            returned.                                    +----------------+ *
*;                                                     AR1 | OP2 high mant  | *
*;                                                         +----------------+ *
*;                                                     AR2 | res low mant   | *
*;                                                         +----------------+ *
*;                                                     AR3 | res high mant  | *
*;                                                         +----------------+ *
*;                                                     AR4 | OP1 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR5 | OP2 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR6 | res sign       | *
*;                                                         +----------------+ *
*;                                                     AR7 | res exponent   | *
*;                                                         +----------------+ *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;    NOTE: The ordering of the locals are placed to take advantage           *
*;          of long word loads and stores which require the hi and lo         *
*;          words to be at certain addresses. Any future modifications        *
*;          which involve the stack must take this quirk into account         *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$DIV
        .sect     ".text"

FS$$DIV:	.asmfunc
        .asg      AR7,    RES_EXP
        .asg      XAR7,   XRES_EXP
        .asg      AR3,    RES_HM
        .asg      AR2,    RES_LM
        .asg      AR6,    RES_SIGN
        .asg      AR4,    OP1_SE
	.asg      XAR4,   XOP1_SE
        .asg      AR5,    OP2_SE
        .asg      AR1,    OP2_HM
        .asg      AR0,    OP2_LM
        .asg    *-SP[1],  OP1_HM
        .asg    *-SP[2],  OP1_LM

        .asg    *-SP[13],  OP2_MSW
        .asg    *-SP[14], OP2_LSW

*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of AR0 - AR3, and allocate stack space for locals      *
*;*****************************************************************************
*
        PUSH    XAR0
        PUSH    XAR1
        PUSH    XAR2
        PUSH    XAR3
        ADDB    SP, #2            ; Allocate space for locals
*
*;*****************************************************************************
*;       CONFIGURE STATUS BITS                                                *
*;*****************************************************************************
*
        CLRC    SXM
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP1 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa with a long word store                            *
*;*****************************************************************************
*
        TEST    ACC
        B       OP1_ZERO, EQ      ; if OP1 is 0, jump to special case
        MOVZ    OP1_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOVL    OP1_LM, ACC       ; store mantissa           
        MOV     AH, OP1_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOVZ    OP1_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP2 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa                                                   *
*;*****************************************************************************
*
        MOVL    ACC, OP2_LSW      ; load ACC with OP2
        B       OP2_ZERO, EQ      ; if OP2 is 0, divide by zero
        MOVZ    OP2_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOVZ    OP2_HM, AH
        MOVZ    OP2_LM, AL        ; store mantissa
        MOV     AH, OP2_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOVZ    OP2_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of OP1 and OP2 to determine sign of result.        *
*;*****************************************************************************
*
        MOV     AH, OP1_SE        ; load sign and exp of op1 to AH
        XOR     AH, OP2_SE        ; xor with op2 to get sign of result
        AND     AH, #00100h       ; mask to get sign
        MOV     RES_SIGN, AH      ; save sign of result to stack
*
*;*****************************************************************************
*;       EXPONENT SUMMATION                                                   *
*;  Find difference between operand exponents to determine the result         *
*;  exponent.  Since the subtraction process removes the bias it must be      *
*;  re-added in.
*;                                                                            *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp OP1 + exp OP2 results in underflow (exp < 0)               *
*;    Case 2:  exp OP1 + exp OP2 results in overflow (exp >= 0FFh)            *
*;    Case 3:  exp OP1 + exp OP2 results are in range (exp >= 0 & exp < 0FFh) *
*;      NOTE:  Cases when result exp = 0 may result in underflow unless there *
*;             is a carry in the result that increments the exponent to 1.    *
*;             Cases when result exp = 0FEh may result in overflow if there   *
*;             is a carry in the result that increments the exponent to 0FFh. *
*;*****************************************************************************
*
         AND    OP1_SE, #0FFh     ; Mask OP1 exponent
         AND    OP2_SE, #0FFh     ; Mask OP2 exponent
         ADDB   XOP1_SE, #07Fh    ; Add offset (difference eliminates offset) 
         MOV    AL, OP1_SE
         SUB    AL, OP2_SE        ; Take difference between exponents
         MOV    RES_EXP, AL       ; Save result exponent on stack
*
         B      UNDERFLOW, LT     ; branch to underflow handler if exp < 0
         SUB    AL, #0FFh         ; test for overflow
         B      OVERFLOW, GT      ; branch to overflow is exp > 127
*
*;*****************************************************************************
*;       DIVISION                                                             *
*;  Division is implemented by parts.  The mantissas for both OP1 and OP2 are *
*;  left shifted in the 32 bit field to reduce the effect of secondary and    *
*;  tertiary contributions to the final result.  The left shifted results     *
*;  are identified as OP1'HI, OP1'LO, OP2'HI, and OP2'LO where OP1'HI and     *
*;  OP2'HI have the xx most significant bits of the mantissas and OP1'LO      *
*;  and OP2'LO contain the remaining bits of each mantissa.  Let QHI and      *
*;  QLO represent the two portions of the resultant mantissa.  Then           *
*;                                                                            *
*;                 OP1'HI + OP1'LO     OP1'HI + OP1'LO          1             *
*;   QHI + QLO  =  ---------------  =  ---------------  * ----------------- . *
*;                 OP2'HI + OP2'LO         OP2'HI        (1 + OP2'LO/OP2'HI)  *
*;                                                                            *
*;   Now let   X = OP2'LO/OP2'HI.                                             *
*;                                                                            *
*;   Then by Taylor's Series Expansion,                                       *
*;                                                                            *
*;               1                2    3                                      *
*;             -----  =  1 - X + X  - X  +  ...                               *
*;             (1+X)                                                          *
*;                                                                            *
*;   Since OP2'HI contains the first xx significant bits of the OP2 mantissa, *
*;                                                                            *
*;                               -yy                                          *
*;          X = OP2'LO/OP2'HI < 2   .                                         *
*;                                                                            *
*;   Therefore the X**2 term and all subsequent terms are less than the       *
*;   least significant bit of the 24-bit result and can be dropped.           *
*;   The result then becomes                                                  *
*;                                                                            *
*;                 OP1'HI + OP1'LO          1                                 *
*;   QHI + QLO  =  ---------------  * ----------------                        *
*;                     OP2'HI        (1 + OP2'LO/OP2'HI)                      *
*;                                                                            *
*;                 OP1'HI + OP1'LO          OP2'LO                            *
*;              =  ---------------  * ( 1 - ------ )                          *
*;                     OP2'HI               OP2'HI                            *
*;                                                                            *
*;                                       OP2'LO                               *
*;               = (Q'HI + Q'LO) * ( 1 - ------ )                             *
*;                                       OP2'HI                               *
*;                                                                            *
*;    where Q'HI and Q'LO represent the first approximation of the result.    *
*;    Also since Q'LO and OP2'LO/OP2'HI are less significant the 24th bit of  *
*;    the result, this product term can be dropped so that                    *
*;                                                                            *
*;     QHI + QLO  =  Q'HI + Q'LO - (Q'HI * OP2'LO)/OP2'HI .                   *
*;                                                                            *
*;*****************************************************************************
*
        MOV     AH, OP2_HM
        MOV     AL, OP2_LM        ; Load divisor mantissa
        LSL     ACC, 7            ; Shift divisor in preparation for division
        MOVZ    OP2_HM, AH
        MOVZ    OP2_LM, AL        ; Save off divisor

        MOVL    ACC, OP1_LM       ; Load dividend mantissa
        LSL     ACC, 6            ; Shift dividend in preparation for division

        RPT     #14               ; QHI = OP1'HI/OP2'HI
     || SUBCU   ACC, OP2_HM
        MOVZ    RES_HM, AL        ; Save QHI

        SUBU    ACC, RES_HM       ; Clear QHI from ACC
        RPT     #10               ; Q'LO = OP1'LO / OP2'HI
     || SUBCU   ACC, OP2_HM
        MOV     RES_LM, ACC << 5  ; Save Q'LO

        MOV     T, RES_HM         ; T = Q'HI
        MPYU    ACC, T, OP2_LM    ; Store Q'HI * OP2'LO in acc A
        SFR     ACC, 1

        RPT     #11               ; Calculate Q'HI * OP2'LO / OP2'HI
     || SUBCU   ACC, OP2_HM       ;   (correction factor)
        LSL     ACC, 4            ; Left shift to bring it to proper range
        MOV     AH, #0            ; Mask off correction factor
        LSL     ACC, 1

        NEG     ACC               ; Subtract correction factor
        ADDCU   ACC, RES_LM       ; Add Q'LO
        ADD     AH, RES_HM        ; Add Q'HI
*	
*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Set up to adjust the normalized result.                                   *
*;    The MSB may be in bit 31.  Test this case and increment the exponent    *
*;    and right shift mantissa 1 bit so result is in bits 30 through 7.       *
*;  Right shift mantissa by 7 bits.                                           *
*;  Store low mantissa on stack.                                              *
*;  Mask implied 1 and store high mantissa on stack.                          *
*;  Test result for underflow and overflow.                                   *
*;*****************************************************************************
*
        SFR     ACC, 1          ; MSB may be in bit 31; shift so we don't
                                ; lose any mantissa during normalization
        ADD     RES_EXP, #1     ; adjust exponent

	RPT	#31
     || NORM    ACC, XRES_EXP-- ; normalize the result, and adjust exponent

        ADDB    ACC, #020h      ; add rounding bit
        SFR     ACC, 1          ; addition may result in carry, so shift
                                ; before normalizing to make sure mantissa is
                                ; preserved
        ADD     RES_EXP, #1     ; adjust exponent

	RPT	#31
     || NORM    ACC, XRES_EXP-- ; normalize after rounding, and adjust exponent

        MOVL    P, ACC          ; save ACC
        MOV     AL, RES_EXP     ; test exponent
        B       UNDERFLOW, LEQ  ; process underflow if it occurs
        SUB     AL, #0FFh       ; adjust to check for overflow
        B       OVERFLOW, GEQ   ; process overflow if it occurs
        MOVL    ACC, P          ; restore ACC
        SFR     ACC, 7          ; shift right to place mantissa for splitting
        AND     AH, #07Fh       ; remove implied one
        MOVZ    RES_HM, AH
        MOVZ    RES_LM, AL      ; save result mantissa
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
        MOV     ACC, RES_SIGN << 16  ; 0000 000S 0000 0000 0000 0000 0000 0000
        ADD     AH, RES_EXP          ; 0000 000S EEEE EEEE 0000 0000 0000 0000
        LSL     AH, 7                ; SEEE EEEE E000 0000 0000 0000 0000 0000
        ADDCU   ACC, RES_LM          ; SEEE EEEE E000 0000 MMMM MMMM MMMM MMMM
        ADD     AH, RES_HM           ; SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop AR0 - AR3                                                             *
*;*****************************************************************************
*
* entry: A - final result
*
RETURN_VALUE
OP1_ZERO
        SUBB    SP, #2
        POP    XAR3
        POP    XAR2
        POP    XAR1
        POP    XAR0
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #0            ; Expand value in AL to occupy all of ACC
        SAT     ACC               ; Result exponent  = 0FEh
        SUB     AH, #081h         ; Result high mant = 07Fh
        MOVL    P, ACC            ; Move result to P
        MOV     AH, RES_SIGN      ; Calculate sign of result
        B       RETURN_VALUE, NEQ
        MOV     AH, #8000h
        XOR     AH, PH
        MOV     AL, PL
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
UNDERFLOW
        MOV     ACC, #0 
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       DIVIDE BY ZERO                                                       *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OP2_ZERO
        MOVL    P, ACC          ; Save ACC
        MOV     AH, OP1_SE      ; Load sign and exponent of OP1
        AND     AH, #100h       ; Mask to get sign of OP1
        LSL     AH, 7
        MOVZ    OP1_SE, AH      ; Store sign
        MOVL    ACC, P          ; Restore ACC

        SUB     AH,  #081h      ; Result high mant = 7Fh
        XOR     AH,  #8000h
        OR      AH,  OP1_SE     ; Pack sign
        B       RETURN_VALUE,UNC
	.endasmfunc

fs_mpy.asm/     1146129407  0     0     0       694       `
*;*****************************************************************************
*;                                                                            *
*;  FS_MPY v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$MPY - multiply two floating point numbers                              *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_mpy27.inc"
        .elseif .TMS320C2800
                .include "fs_mpy28.inc"
        .endif
fs_mpy27.inc/   1146129407  0     0     0       21842     `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_MPY v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$MPY - multiply two floating point numbers                              *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$MPY                                                HI MEMORY      *
*;                                                                            *
*;                                                               stack        *
*;                                                         +----------------+ *
*;       This routine multiplies two floating point   SP-->|                | *
*;       numbers.  Upon entry one operand (OP1) is         +----------------+ *
*;       in ACC and the other (OP2) is on the           -1 |  OP1 high mant | *
*;       stack as shown.  SP is moved to accomodate        +----------------+ *
*;       locals.  When multiplication is finished the   -2 |  OP1 low mant  | *
*;       SP is returned to point at the return address.    +----------------+ *
*;                                                      -3 |      AR3       | *
*;       inputs:  OP1 - in ACC, OP2 - on stack             +----------------+ *
*;                                                      -4 |      AR2       | *
*;       implementation:  OP1 and OP2 are each unpacked    +----------------+ *
*;            into sign, exponent, and two words of     -5 |      AR1       | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated.     -6 |      AR0       | *
*;            The exponents are summed.  If the            +----------------+ *
*;            result is less than zero underflow        -7 | (return addr)  | *
*;            has occurred.  If the result is zero,        +----------------+ *
*;            underflow may have occurred.  If the      -8 | (return addr)  | *
*;            result is equal to 254 overflow may          +----------------+ *
*;            have occurred.  If the result is          -9 |   MSW of OP2   | *
*;            greater than 254 overflow has occurred.      +----------------+ *
*;            Underflow processing returns a value     -10 |   LSW of OP2   | *
*;            of zero.  Overflow processing returns        +----------------+ *
*;            the largest magnitude value along with                          *
*;            the appropriate sign.  If no special             LO MEMORY      *
*;            cases are detected, a 24x24-bit                                 *
*;            multiply is executed.  The result of                            *
*;            the eXclusive OR of the sign bits, the         register file    *
*;            difference of the exponents and the 24       +----------------+ *
*;            bit truncated mantissa are packed and    AR0 | OP2 low mant   | *
*;            returned.                                    +----------------+ *
*;                                                     AR1 | OP2 high mant  | *
*;                                                         +----------------+ *
*;                                                     AR2 | res low mant   | *
*;                                                         +----------------+ *
*;                                                     AR3 | res high mant  | *
*;                                                         +----------------+ *
*;                                                     AR4 | OP1 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR5 | OP2 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR6 | res sign       | *
*;                                                         +----------------+ *
*;                                                     AR7 | res exponent   | *
*;                                                         +----------------+ *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;    NOTE: The ordering of the locals are placed to take advantage           *
*;          of long word loads and stores which require the hi and lo         *
*;          words to be at certain addresses. Any future modifications        *
*;          which involve the stack must take this quirk into account         *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$MPY
        .sect     ".text"

FS$$MPY:	.asmfunc
        .asg      AR7,    RES_EXP
        .asg      AR3,    RES_HM
        .asg      AR2,    RES_LM
        .asg      AR6,    RES_SIGN
        .asg      AR4,    OP1_SE
        .asg      AR5,    OP2_SE
        .asg      AR1,    OP2_HM
        .asg      AR0,    OP2_LM
        .asg    *-SP[1],  OP1_HM
        .asg    *-SP[2],  OP1_LM

        .asg    *-SP[9],  OP2_MSW
        .asg    *-SP[10], OP2_LSW

*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of AR0 - AR3, and allocate stack space for locals      *
*;*****************************************************************************
*
        PUSH    AR1:AR0
        PUSH    AR3:AR2
        ADDB    SP, #2            ; Allocate space for locals
*
*;*****************************************************************************
*;       CONFIGURE STATUS BITS                                                *
*;*****************************************************************************
*
        CLRC    SXM
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP1 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa with a long word store                            *
*;*****************************************************************************
*
        TEST    ACC
        B       OP_ZERO, EQ       ; if OP1 is 0, jump to special case
        MOV     OP1_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOVL    OP1_LM, ACC       ; store mantissa           
        MOV     AH, OP1_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOV     OP1_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP2 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa                                                   *
*;*****************************************************************************
*
        MOVL    ACC, OP2_LSW      ; load ACC with OP2
        B       OP_ZERO, EQ       ; if OP2 is 0, jump to special case
        MOV     OP2_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOV     OP2_HM, AH
        MOV     OP2_LM, AL        ; store mantissa
        MOV     AH, OP2_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOV     OP2_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of OP1 and OP2 to determine sign of result.        *
*;*****************************************************************************
*
        MOV     AH, OP1_SE        ; load sign and exp of op1 to AH
        XOR     AH, OP2_SE        ; xor with op2 to get sign of result
        AND     AH, #00100h       ; mask to get sign
        MOV     RES_SIGN, AH      ; save sign of result to stack
*
*;*****************************************************************************
*;       EXPONENT SUMMATION                                                   *
*;  Sum the exponents of OP1 and OP2 to determine the result exponent.  Since *
*;  the exponents are biased (excess 127) the summation must be decremented   *
*;  by the bias value to avoid double biasing the result.                     *
*;                                                                            *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp OP1 + exp OP2 results in underflow (exp < 0)               *
*;    Case 2:  exp OP1 + exp OP2 results in overflow (exp >= 0FFh)            *
*;    Case 3:  exp OP1 + exp OP2 results are in range (exp >= 0 & exp < 0FFh) *
*;      NOTE:  Cases when result exp = 0 may result in underflow unless there *
*;             is a carry in the result that increments the exponent to 1.    *
*;             Cases when result exp = 0FEh may result in overflow if there   *
*;             is a carry in the result that increments the exponent to 0FFh. *
*;*****************************************************************************
*
         AND    OP1_SE, #0FFh     ; Mask OP1 exponent
         AND    OP2_SE, #0FFh     ; Mask OP2 exponent
         SUBB   OP1_SE, #07Fh     ; Subtract offset (avoid double bias)       
         MOV    AL, OP1_SE
         ADD    AL, OP2_SE        ; Add the exponents                  
         MOV    RES_EXP, AL       ; Save result exponent on stack
*
         B      UNDERFLOW, LT     ; branch to underflow handler if exp < 0
         SUB    AL, #0FFh         ; test for overflow
         B      OVERFLOW, GT      ; branch to overflow is exp > 127
*
*;*****************************************************************************
*;       MULTIPLICATION                                                       *
*;  Multiplication is implemented by parts.  Mantissa for OP1 is three bytes  *
*;  identified as Q, R, and S (Q represents OP1 high mantissa and R and S     *
*;  represent the two bytes of OP1 low mantissa).  Mantissa for OP2 is also 3 *
*;  bytes identified as X, Y, and Z (X represents OP2 high mant and Y and Z   *
*;  represent the two bytes of OP2 low mantissa).  Then                       *
*;                                                                            *
*;                      0  Q  R  S      (mantissa of OP1)                     *
*;                   x  0  X  Y  Z      (mantissa of OP2)                     *
*;                     ===========                                            *
*;                           RS*YZ      <-- save only upper 16 bits of result *
*;                        RS*0X                                               *
*;                        0Q*YZ                                               *
*;                     0Q*0X            <-- upper 16 bits are always zero     *
*;                     ===========                                            *
*;                        result        <-- result is always in the internal  *
*;                                          32 bits (which ends up in the     *
*;                                          accumulator) of the possible 64   *
*;                                          bit product                       *
*;                                                                            *
*;*****************************************************************************
*
        MOV     T, OP1_LM       ; load low mant of OP1 to T register
        MPYU    ACC, T, OP2_LM  ; ACC = RS * YZ
        MPYU    P, T, OP2_HM    ; P   = RS * 0X
        SFR     ACC, 16
        ADD     ACC, P
        MOV     P, ACC          ; P   = (RS * YZ) + (RS * 0X)
*
        MOV     T, OP1_HM       ; load high mant of OP1 to T register
        MPYU    ACC, T, OP2_LM  ; ACC = 0Q * YZ
        ADD     ACC, P          ; ACC = (RS * YZ) + (RS * 0X) + (0Q * YZ)
        MPYU    P, T, OP2_HM    ; P   = 0Q * 0X
        
        ADD     ACC, PL << 16   ; ACC = final result
*
*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Set up to adjust the normalized result.                                   *
*;    The MSB may be in bit 31.  Test this case and increment the exponent    *
*;    and right shift mantissa 1 bit so result is in bits 30 through 7.       *
*;  Right shift mantissa by 7 bits.                                           *
*;  Store low mantissa on stack.                                              *
*;  Mask implied 1 and store high mantissa on stack.                          *
*;  Test result for underflow and overflow.                                   *
*;*****************************************************************************
*
        ADDB    ACC, #040h       ; Add rounding bit
        B       NORMALIZED, GEQ  ; check if MSB is in 31
        SFR     ACC, 1           ; shift result so result is in bits 30:7
        ADD     RES_EXP, #1      ; increment exponent

NORMALIZED
        MOV     P, ACC           ; save ACC
        MOV     AH, RES_EXP      ; load exponent of result
        B       UNDERFLOW, LEQ   ; check for underflow
        SUB     AH, #0FFh        ; adjust to check for overflow
        B       OVERFLOW, GEQ    ; check for overflow
        MOV     ACC, P           ; restore ACC
        SFR     ACC, 7           ; shift to get 23 ms bits of mantissa result
        AND     AH, #07Fh        ; remove implied one
        MOV     RES_HM, AH
        MOV     RES_LM, AL       ; store the mantissa result
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
        MOV     ACC, RES_SIGN << 16  ; 0000 000S 0000 0000 0000 0000 0000 0000
        ADD     AH, RES_EXP          ; 0000 000S EEEE EEEE 0000 0000 0000 0000
        LSL     AH, 7                ; SEEE EEEE E000 0000 0000 0000 0000 0000
        ADDCU   ACC, RES_LM          ; SEEE EEEE E000 0000 MMMM MMMM MMMM MMMM
        ADD     AH, RES_HM           ; SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop AR0 - AR3                                                             *
*;*****************************************************************************
*
* entry: A - final result
*
RETURN_VALUE
OP_ZERO
        SUBB    SP, #2
        POP     AR3:AR2
        POP     AR1:AR0
        RET

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, RES_SIGN
        LSL     AH, 7             ; Load sign of result
        ADD     AH, #07F7Fh       ; Result exponent  = 0FEh
                                  ; Result high mant = 07Fh
        B       RETURN_VALUE     
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
UNDERFLOW
        MOV     ACC, #0 
        B       RETURN_VALUE
	.endasmfunc
fs_mpy28.inc/   1146129407  0     0     0       21931     `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_MPY v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$MPY - multiply two floating point numbers                              *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$MPY                                                HI MEMORY      *
*;                                                                            *
*;                                                               stack        *
*;                                                         +----------------+ *
*;       This routine multiplies two floating point   SP-->|                | *
*;       numbers.  Upon entry one operand (OP1) is         +----------------+ *
*;       in ACC and the other (OP2) is on the           -1 |  OP1 high mant | *
*;       stack as shown.  SP is moved to accomodate        +----------------+ *
*;       locals.  When multiplication is finished the   -2 |  OP1 low mant  | *
*;       SP is returned to point at the return address.    +----------------+ *
*;                                                   -3 -4 |     XAR3       | *
*;       inputs:  OP1 - in ACC, OP2 - on stack             +----------------+ *
*;                                                   -5 -6 |     XAR2       | *
*;       implementation:  OP1 and OP2 are each unpacked    +----------------+ *
*;            into sign, exponent, and two words of  -7 -8 |     XAR1       | *
*;            mantissa.  If either exponent is zero        +----------------+ *
*;            special case processing is initiated. -9 -10 |     XAR0       | *
*;            The exponents are summed.  If the            +----------------+ *
*;            result is less than zero underflow       -11 | (return addr)  | *
*;            has occurred.  If the result is zero,        +----------------+ *
*;            underflow may have occurred.  If the     -12 | (return addr)  | *
*;            result is equal to 254 overflow may          +----------------+ *
*;            have occurred.  If the result is         -13 |   MSW of OP2   | *
*;            greater than 254 overflow has occurred.      +----------------+ *
*;            Underflow processing returns a value     -14 |   LSW of OP2   | *
*;            of zero.  Overflow processing returns        +----------------+ *
*;            the largest magnitude value along with                          *
*;            the appropriate sign.  If no special             LO MEMORY      *
*;            cases are detected, a 24x24-bit                                 *
*;            multiply is executed.  The result of                            *
*;            the eXclusive OR of the sign bits, the         register file    *
*;            difference of the exponents and the 24       +----------------+ *
*;            bit truncated mantissa are packed and    AR0 | OP2 low mant   | *
*;            returned.                                    +----------------+ *
*;                                                     AR1 | OP2 high mant  | *
*;                                                         +----------------+ *
*;                                                     AR2 | res low mant   | *
*;                                                         +----------------+ *
*;                                                     AR3 | res high mant  | *
*;                                                         +----------------+ *
*;                                                     AR4 | OP1 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR5 | OP2 sign & exp | *
*;                                                         +----------------+ *
*;                                                     AR6 | res sign       | *
*;                                                         +----------------+ *
*;                                                     AR7 | res exponent   | *
*;                                                         +----------------+ *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;    NOTE: The ordering of the locals are placed to take advantage           *
*;          of long word loads and stores which require the hi and lo         *
*;          words to be at certain addresses. Any future modifications        *
*;          which involve the stack must take this quirk into account         *
*;                                                                            *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$MPY
        .sect     ".text"

FS$$MPY:	.asmfunc
        .asg      AR7,    RES_EXP
        .asg      AR3,    RES_HM
        .asg      AR2,    RES_LM
        .asg      AR6,    RES_SIGN
        .asg      AR4,    OP1_SE
        .asg      XAR4,   XOP1_SE
        .asg      AR5,    OP2_SE
        .asg      AR1,    OP2_HM
        .asg      AR0,    OP2_LM
        .asg    *-SP[1],  OP1_HM
        .asg    *-SP[2],  OP1_LM

        .asg    *-SP[13],  OP2_MSW
        .asg    *-SP[14], OP2_LSW

*
*;*****************************************************************************
*;       CONTEXT SAVE                                                         *
*;       Save contents of AR0 - AR3, and allocate stack space for locals      *
*;*****************************************************************************
*
        PUSH    XAR0
        PUSH    XAR1
        PUSH    XAR2
        PUSH    XAR3
        ADDB    SP, #2            ; Allocate space for locals
*
*;*****************************************************************************
*;       CONFIGURE STATUS BITS                                                *
*;*****************************************************************************
*
        CLRC    SXM
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP1 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa with a long word store                            *
*;*****************************************************************************
*
        TEST    ACC
        B       OP_ZERO, EQ       ; if OP1 is 0, jump to special case
        MOVZ    OP1_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOVL    OP1_LM, ACC       ; store mantissa           
        MOV     AH, OP1_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOVZ    OP1_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP2 for special case treatment of zero.                              *
*;  Split the MSW of A in the accumulator.                                    *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store entire mantissa                                                   *
*;*****************************************************************************
*
        MOVL    ACC, OP2_LSW      ; load ACC with OP2
        B       OP_ZERO, EQ       ; if OP2 is 0, jump to special case
        MOVZ    OP2_SE, AH        ; store AH before sign & exp are removed
        AND     AH, #07Fh         ; mask off sign & exp to get high mantissa
        ADD     AH, #080h         ; add implied 1 to mantissa
        MOVZ    OP2_HM, AH
        MOVZ    OP2_LM, AL        ; store mantissa
        MOV     AH, OP2_SE        ; Restore high part containing sign & exp
        LSR     AH, 7             ; Remove high mantissa     
        MOVZ    OP2_SE, AH        ; store sign and exponent
*
*;*****************************************************************************
*;       SIGN EVALUATION                                                      *
*;  Exclusive OR sign bits of OP1 and OP2 to determine sign of result.        *
*;*****************************************************************************
*
        MOV     AH, OP1_SE        ; load sign and exp of op1 to AH
        XOR     AH, OP2_SE        ; xor with op2 to get sign of result
        AND     AH, #00100h       ; mask to get sign
        MOV     RES_SIGN, AH      ; save sign of result to stack
*
*;*****************************************************************************
*;       EXPONENT SUMMATION                                                   *
*;  Sum the exponents of OP1 and OP2 to determine the result exponent.  Since *
*;  the exponents are biased (excess 127) the summation must be decremented   *
*;  by the bias value to avoid double biasing the result.                     *
*;                                                                            *
*;  Branch to one of three blocks of processing                               *
*;    Case 1:  exp OP1 + exp OP2 results in underflow (exp < 0)               *
*;    Case 2:  exp OP1 + exp OP2 results in overflow (exp >= 0FFh)            *
*;    Case 3:  exp OP1 + exp OP2 results are in range (exp >= 0 & exp < 0FFh) *
*;      NOTE:  Cases when result exp = 0 may result in underflow unless there *
*;             is a carry in the result that increments the exponent to 1.    *
*;             Cases when result exp = 0FEh may result in overflow if there   *
*;             is a carry in the result that increments the exponent to 0FFh. *
*;*****************************************************************************
*
         AND    OP1_SE, #0FFh     ; Mask OP1 exponent
         AND    OP2_SE, #0FFh     ; Mask OP2 exponent
         SUBB   XOP1_SE, #07Fh    ; Subtract offset (avoid double bias)       
         MOV    AL, OP1_SE
         ADD    AL, OP2_SE        ; Add the exponents                  
         MOV    RES_EXP, AL       ; Save result exponent on stack
*
         B      UNDERFLOW, LT     ; branch to underflow handler if exp < 0
         SUB    AL, #0FFh         ; test for overflow
         B      OVERFLOW, GT      ; branch to overflow is exp > 127
*
*;*****************************************************************************
*;       MULTIPLICATION                                                       *
*;  Multiplication is implemented by parts.  Mantissa for OP1 is three bytes  *
*;  identified as Q, R, and S (Q represents OP1 high mantissa and R and S     *
*;  represent the two bytes of OP1 low mantissa).  Mantissa for OP2 is also 3 *
*;  bytes identified as X, Y, and Z (X represents OP2 high mant and Y and Z   *
*;  represent the two bytes of OP2 low mantissa).  Then                       *
*;                                                                            *
*;                      0  Q  R  S      (mantissa of OP1)                     *
*;                   x  0  X  Y  Z      (mantissa of OP2)                     *
*;                     ===========                                            *
*;                           RS*YZ      <-- save only upper 16 bits of result *
*;                        RS*0X                                               *
*;                        0Q*YZ                                               *
*;                     0Q*0X            <-- upper 16 bits are always zero     *
*;                     ===========                                            *
*;                        result        <-- result is always in the internal  *
*;                                          32 bits (which ends up in the     *
*;                                          accumulator) of the possible 64   *
*;                                          bit product                       *
*;                                                                            *
*;*****************************************************************************
*
        MOV     T, OP1_LM       ; load low mant of OP1 to T register
        MPYU    ACC, T, OP2_LM  ; ACC = RS * YZ
        MPYU    P, T, OP2_HM    ; P   = RS * 0X
        SFR     ACC, 16
        ADDL    ACC, P
        MOVL    P, ACC          ; P   = (RS * YZ) + (RS * 0X)
*
        MOV     T, OP1_HM       ; load high mant of OP1 to T register
        MPYU    ACC, T, OP2_LM  ; ACC = 0Q * YZ
        ADDL    ACC, P          ; ACC = (RS * YZ) + (RS * 0X) + (0Q * YZ)
        MPYU    P, T, OP2_HM    ; P   = 0Q * 0X
        
        ADD     ACC, PL << 16   ; ACC = final result
*
*;*****************************************************************************
*;       POST-NORMALIZATION ADJUSTMENT AND STORAGE                            *
*;  Set up to adjust the normalized result.                                   *
*;    The MSB may be in bit 31.  Test this case and increment the exponent    *
*;    and right shift mantissa 1 bit so result is in bits 30 through 7.       *
*;  Right shift mantissa by 7 bits.                                           *
*;  Store low mantissa on stack.                                              *
*;  Mask implied 1 and store high mantissa on stack.                          *
*;  Test result for underflow and overflow.                                   *
*;*****************************************************************************
*
        ADDB    ACC, #040h       ; Add rounding bit
        B       NORMALIZED, GEQ  ; check if MSB is in 31
        SFR     ACC, 1           ; shift result so result is in bits 30:7
        ADD     RES_EXP, #1      ; increment exponent

NORMALIZED
        MOVL    P, ACC           ; save ACC
        MOV     AH, RES_EXP      ; load exponent of result
        B       UNDERFLOW, LEQ   ; check for underflow
        SUB     AH, #0FFh        ; adjust to check for overflow
        B       OVERFLOW, GEQ    ; check for overflow
        MOVL    ACC, P           ; restore ACC
        SFR     ACC, 7           ; shift to get 23 ms bits of mantissa result
        AND     AH, #07Fh        ; remove implied one
        MOVZ    RES_HM, AH
        MOVZ    RES_LM, AL       ; store the mantissa result
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Load sign.                                                                *
*;  Pack exponent.                                                            *
*;  Pack mantissa.                                                            *
*;*****************************************************************************
*
        MOV     ACC, RES_SIGN << 16  ; 0000 000S 0000 0000 0000 0000 0000 0000
        ADD     AH, RES_EXP          ; 0000 000S EEEE EEEE 0000 0000 0000 0000
        LSL     AH, 7                ; SEEE EEEE E000 0000 0000 0000 0000 0000
        ADDCU   ACC, RES_LM          ; SEEE EEEE E000 0000 MMMM MMMM MMMM MMMM
        ADD     AH, RES_HM           ; SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
*
*;*****************************************************************************
*;       CONTEXT RESTORE                                                      *
*;  Pop local floating point variables.                                       *
*;  Pop AR0 - AR3                                                             *
*;*****************************************************************************
*
* entry: A - final result
*
RETURN_VALUE
OP_ZERO
        SUBB    SP, #2
        POP     XAR3
	POP	XAR2
	POP	XAR1
	POP	XAR0
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, RES_SIGN
        LSL     AH, 7             ; Load sign of result
        ADD     AH, #07F7Fh       ; Result exponent  = 0FEh
                                  ; Result high mant = 07Fh
        B       RETURN_VALUE,UNC     
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
UNDERFLOW
        MOV     ACC, #0 
        B       RETURN_VALUE,UNC
	.endasmfunc

fs_neg.asm/     1146129407  0     0     0       694       `
*;*****************************************************************************
*;                                                                            *
*;  FS_NEG v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$NEG - negate a floating point number                                   *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_neg27.inc"
        .elseif .TMS320C2800
                .include "fs_neg28.inc"
        .endif
fs_neg27.inc/   1146129407  0     0     0       6761      `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_NEG v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$NEG - negate a floating point number                                   *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$NEG                                                HI MEMORY      *
*;                                                                            *
*;       This routine negates a floating point                   stack        *
*;       number.  Upon entry the number is in ACC.         +----------------+ *
*;       The sign is the most significant bit in the  SP-->|                | *
*;       ACC.  Since the mantissa is in magnitude          +----------------+ *
*;       format, only the sign bit must be modified.    -1 | (return addr)  | *
*;                                                         +----------------+ *
*;       inputs:  OP1 (floating point number)           -2 | (return addr)  | *
*;                                                         +----------------+ *
*;       implementation:  OP1 ^ 80000000h                                     *
*;                                                             LO MEMORY      *
*;            The sign bit of ACC is eXclusive ORed.                          *
*;                                                                            *
*;       special cases:  zero - no sign bit modification                      *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$NEG
        .sect     ".text"

FS$$NEG:	.asmfunc
*;*****************************************************************************
*;       PROCEDURE                                                            *
*;  Exclusive OR the sign bit except for the special case of zero.            *
*;*****************************************************************************
        TEST ACC           ; test if OP1 == 0
        B    CALL_ADD, EQ  ; zero is a special case, don't negate
        XOR  AH, #8000h    ; xor sign bit of OP1 high mantissa
CALL_ADD:
        RET
	.endasmfunc

fs_neg28.inc/   1146129407  0     0     0       6763      `
        .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS_NEG v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;  FS$$NEG - negate a floating point number                                   *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$NEG                                                HI MEMORY      *
*;                                                                            *
*;       This routine negates a floating point                   stack        *
*;       number.  Upon entry the number is in ACC.         +----------------+ *
*;       The sign is the most significant bit in the  SP-->|                | *
*;       ACC.  Since the mantissa is in magnitude          +----------------+ *
*;       format, only the sign bit must be modified.    -1 | (return addr)  | *
*;                                                         +----------------+ *
*;       inputs:  OP1 (floating point number)           -2 | (return addr)  | *
*;                                                         +----------------+ *
*;       implementation:  OP1 ^ 80000000h                                     *
*;                                                             LO MEMORY      *
*;            The sign bit of ACC is eXclusive ORed.                          *
*;                                                                            *
*;       special cases:  zero - no sign bit modification                      *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
        .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
        .page
        .global   FS$$NEG
        .sect     ".text"

FS$$NEG:	.asmfunc
*;*****************************************************************************
*;       PROCEDURE                                                            *
*;  Exclusive OR the sign bit except for the special case of zero.            *
*;*****************************************************************************
        TEST ACC           ; test if OP1 == 0
        B    CALL_ADD, EQ  ; zero is a special case, don't negate
        XOR  AH, #8000h    ; xor sign bit of OP1 high mantissa
CALL_ADD:
        LRETR
	.endasmfunc

fs_tofd.asm/    1146129407  0     0     0       705       `
*;*****************************************************************************
*;                                                                            *
*;  FS_TOFD v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  FS$$TOFD - Convert an IEEE 754 format single precision floating point     *
*;             number to 754 format double precision floating point number    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fs_tofd28.inc"
        .endif

fs_tofd28.inc/  1146129407  0     0     0       8882      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  FS_TOFD v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  FS$$TOFD - Convert an IEEE 754 format single precision floating point     *
;*             number to 754 format double precision floating point number    *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN ACC  
;*   o RESULT IS RETURNED IN *XAR6
;*
;*   o SIGNALING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY
;*       (0x7ff00000:00000000) or (0xfff00000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |   32-bit representation                                      |
;* |   31 30    23 22                    0                        |
;* |   +-+--------+-----------------------+                       |
;* |   |S|    E   |           M           +                       |
;* |   +-+--------+-----------------------+                       |
;* |                                                              |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE             |
;* |                               1 - NEGATIVE VALUE             |
;* |                                                              |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0            |
;* |                         01...FE - EXPONENT VALUE (127 BIAS)  |
;* |                              FF - INFINITY                   |
;* |                                                              |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;******************************************************************************
;*                             						      *
;*                              		    register file	      *
;*                                                +-------------------+       *
;*                                           AR4  |        | RES_EXP  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                          XAR6  | PTR TO RET VALUE  |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   FS$$TOFD
        .sect     ".text"

FS$$TOFD:	.asmfunc
        .asg       AR4,    RES_EXP
        .asg       AR5,    RES_SIGN
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
	MOVL	P, ACC		  ; Save input float
        MOVL    ACC, XAR6         ;
        B       RETURN, EQ        ; Return if return pointer is null
*
*;*****************************************************************************
*;    1 Save the sign of the input                                            *
*;    2 Extract the exponent                                                  *
*;*****************************************************************************
*
	MOVL	ACC, P		; Restore input in ACC
	MOV	RES_SIGN, AH	; Save the sign of the input float

	MOV	P, #0		; Zero out P 

	LSR64   ACC:P, 7 	; Move the 8 bit exponent into AH bits 7 - 0 
	ANDB	AH, #0xFF	; Mask out the sign; keep only the exponent
*
*;*****************************************************************************
*;  Check input for the following special cases.                              *
*;   - If exp is zero, input is zero or denormal - Underflow                  *
*;   - If exp is 0xFF, input is infinite or NaN - Overflow                    *
*;*****************************************************************************
*
	B	UNDERFLOW, EQ	; Underflow if input is zero/denormals

	CMPB	AH, #0xFF	; Check if input number is infinite
	B  	OVERFLOW, EQ	; Overflow if input is infinite
*
*;*****************************************************************************
*;    1 Adjust the bias to make it a double precision bias(1023)              *
*;    2 Pack the sign, exponent and mantissa in double precision format       *
*;*****************************************************************************
*
	ADD	AH, #0x380	; Adjust the bias for double precision float

	LSL64	ACC:P, 4	; Move exponent and mantissa to bits 62 -      

	AND	RES_SIGN, #0x8000 ; Mask the sign bit
	OR	AH, RES_SIGN	; Set the sign bit
*
RETURN_VALUE:
        MOVL    RES_LSW, P     ;
        MOVL    RES_MSW, ACC   ; Load the return value in the return area.
RETURN:
        LRETR

        .page
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC:P to 0xFFF0000:000000000 if sign is negative; otherwise set it to *
*;  0x7FF00000:00000000                                                       *
*;*****************************************************************************
*
OVERFLOW:
        OVERFLOW64      RES_SIGN
        B       RETURN_VALUE,UNC
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
UNDERFLOW:
	ZAPA                    ; For underflow result (ACC:P)= 0
		B       RETURN_VALUE,UNC
	.endasmfunc
fs_toi.asm/     1146129407  0     0     0       695       `
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOI - convert a floating point value to a 16-bit signed integer       *
*;  FS_TOI v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_toi27.inc"
        .elseif .TMS320C2800
                .include "fs_toi28.inc"
        .endif


fs_toi27.inc/   1146129407  0     0     0       11455     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOI - convert a floating point value to a 16-bit signed integer       *
*;  FS_TOI v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOI                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 16-bit signed integer.  Upon           +----------------+ *
*;       entry the floating point number is in         AR5 |15-bit magnitude| *
*;       ACC.  When the conversion is complete,            +----------------+ *
*;       the integer value will be in AL                                      *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  A is unpacked into sign,                            *
*;            exponent, and mantissa.                                         *
*;            If the exponent exceeds a value of 08Dh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 08Dh, the                                 *
*;            denormalized result is truncacted to                            *
*;            fifteen bits and the properly signed                            *
*;            result is placed in AL.                                         *
*;                                                                            *
*;       result:  returned in AL                                              *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOI

FS$$TOI		.asmfunc
	 .asg	AR4, OP_SE
	 .asg   AR5, RES_MAG

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP for special case treatment of zero.                               *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store most significant 15 bits of mantissa                              *
*;*****************************************************************************
*
        TEST    ACC
        B       ZERO, EQ        ; if OP is zero, return
        MOV     OP_SE, AH       ; save original high mantissa
        AND     AH, #07Fh       ; zero sign & exp to get mantissa
        ADD     AH, #080h       ; add implied 1 to mantissa
        LSL     ACC, 7
        MOV     RES_MAG, AH     ; save 15 most significant magnitude bits 
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
        MOV     OP_SE, AH       ; save sign and exponent
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 08Dh; 08Dh is the exponent for integer values      *
*;             in the absolute range from 16384 to 32767.                     *
*;             Result returned is 7FFFh or 8000h (the largest 16-bit value).  *
*;    Case 3:  exponents in the range of 07Fh to 08Dh inclusive will result   *
*;             in 16-bit signed integer values from -32767 to +32767          *
*;*****************************************************************************
*	
        AND     AH, #0FFh
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #0Eh       ; if exponent > 08Dh then overflow occurs
        B       OVERFLOW, GT
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 16-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize (result in lower accumulator).    *
*;*****************************************************************************
*
        NEG     AH
        MOV     T, AH             ; place shift count into T register
        MOV     ACC, RES_MAG      ; load denormalized mantissa
        CLRC    SXM
        SFR     ACC, T            ; T is in [0..14]
*
*;*****************************************************************************
*; Convert number to signed value                                             *
*;*****************************************************************************
*
        TBIT    OP_SE, #8       ; test sign bit
        B       POSITIVE, NTC   ; leave number alone if positive
	CLRC	OVM		; Clear OVM to get desired result in NEG.
        NEG     ACC             ; convert to two's compliment value
POSITIVE
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        RET
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
UNDERFLOW
         MOV    AL, #0
         RET
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AL, #7fffh      ; load return value with saturated value
        TBIT    OP_SE, #8
        B       RETURN, NTC
        ADD     AL, #1          ; Add one to get -32768
        NEG     AL              ; Convert to two's compliment value        
        RET 
	.endasmfunc

fs_toi28.inc/   1146129408  0     0     0       11461     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOI - convert a floating point value to a 16-bit signed integer       *
*;  FS_TOI v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOI                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 16-bit signed integer.  Upon           +----------------+ *
*;       entry the floating point number is in         AR5 |15-bit magnitude| *
*;       ACC.  When the conversion is complete,            +----------------+ *
*;       the integer value will be in AL                                      *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  A is unpacked into sign,                            *
*;            exponent, and mantissa.                                         *
*;            If the exponent exceeds a value of 08Dh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 08Dh, the                                 *
*;            denormalized result is truncacted to                            *
*;            fifteen bits and the properly signed                            *
*;            result is placed in AL.                                         *
*;                                                                            *
*;       result:  returned in AL                                              *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOI

FS$$TOI		.asmfunc
	 .asg	AR4, OP_SE
	 .asg   AR5, RES_MAG

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP for special case treatment of zero.                               *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store most significant 15 bits of mantissa                              *
*;*****************************************************************************
*
        TEST    ACC
        B       ZERO, EQ        ; if OP is zero, return
        MOVZ    OP_SE, AH       ; save original high mantissa
        AND     AH, #07Fh       ; zero sign & exp to get mantissa
        ADD     AH, #080h       ; add implied 1 to mantissa
        LSL     ACC, 7
        MOVZ    RES_MAG, AH     ; save 15 most significant magnitude bits 
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
        MOVZ    OP_SE, AH       ; save sign and exponent
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 08Dh; 08Dh is the exponent for integer values      *
*;             in the absolute range from 16384 to 32767.                     *
*;             Result returned is 7FFFh or 8000h (the largest 16-bit value).  *
*;    Case 3:  exponents in the range of 07Fh to 08Dh inclusive will result   *
*;             in 16-bit signed integer values from -32767 to +32767          *
*;*****************************************************************************
*	
        AND     AH, #0FFh
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #0Eh       ; if exponent > 08Dh then overflow occurs
        B       OVERFLOW, GT
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 16-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize (result in lower accumulator).    *
*;*****************************************************************************
*
        NEG     AH
        MOV     T, AH             ; place shift count into T register
        MOV     ACC, RES_MAG      ; load denormalized mantissa
        CLRC    SXM
        SFR     ACC, T            ; T is in [0..14]
*
*;*****************************************************************************
*; Convert number to signed value                                             *
*;*****************************************************************************
*
        TBIT    OP_SE, #8       ; test sign bit
        B       POSITIVE, NTC   ; leave number alone if positive
	CLRC	OVM		; Clear OVM to get desired result in NEG.
        NEG     ACC             ; convert to two's compliment value
POSITIVE
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        LRETR
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
UNDERFLOW
         MOV    AL, #0
         LRETR
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AL, #7fffh      ; load return value with saturated value
        TBIT    OP_SE, #8
        B       RETURN, NTC
        ADD     AL, #1          ; Add one to get -32768
        NEG     AL              ; Convert to two's compliment value        
        LRETR 
	.endasmfunc

fs_tol.asm/     1146129408  0     0     0       693       `
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOL - convert a floating point value to a 32-bit signed integer       *
*;  FS_TOL v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_tol27.inc"
        .elseif .TMS320C2800
                .include "fs_tol28.inc"
        .endif

fs_tol27.inc/   1146129408  0     0     0       11889     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOL - convert a floating point value to a 32-bit signed integer       *
*;  FS_TOL v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOL                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 32-bit signed integer.  Upon           +----------------+ *
*;       entry the floating point number is in                                *
*;       ACC.  When the conversion is complete,                               *
*;       the integer value will be in ACC                                     *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  A is unpacked into sign,                            *
*;            exponent, and mantissa.                                         *
*;            If the exponent exceeds a value of 09Eh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 09Eh, the                                 *
*;            mantissa is normalized and returned.                            *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOL

FS$$TOL		.asmfunc
	 .asg	AR4, OP_SE

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;*****************************************************************************
*
	CLRC	OVM		; Clear OVM to get desired result in NEG.
        TEST    ACC
        B       ZERO, EQ        ; if OP is zero, return
        MOV     OP_SE, AH       ; save original high mantissa
        AND     AH, #07Fh       ; zero sign & exp to get mantissa
        ADD     AH, #080h       ; add implied 1 to mantissa
        LSL     ACC, 7          ; shift mantissa to ready for denormalization
        MOV     PH, AH          ; save current high result
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
        MOV     OP_SE, AH       ; save sign and exponent
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 09Dh; 09Dh is the exponent for integer values      *
*;             in the absolute range from 1073741824 to 2147483648.           *
*;             Result returned is 7FFFFFFFh or 80000000h                      *
*;    Case 3:  exponents in the range of 07Fh to 09Dh inclusive will result   *
*;             in 16-bit signed integer values from -2MB to +2MB              *
*;*****************************************************************************
*
        AND     AH, #0FFh
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #1Eh       ; if exponent > 09Dh then overflow occurs
        B       OVERFLOW, GT
        B       TEST_SIGN1, EQ ; test if denormalizing shift count is zero
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 32-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize                                   *
*;*****************************************************************************
*
        ADD     AH, #010h         ; check if right shift is > 16
        B       FIN_SHIFT, GEQ    ; if exp >= -16, only one shift is needed
        MOV     AL, PH            ; else shift 16
        MOV     PH, #0            ; else shift 16
        B       DENORMALIZE
FIN_SHIFT
        SUB     AH, #010h         ; restore original shift value if right shift
                                  ; is <= 16
DENORMALIZE
        TEST    ACC
        PUSH    ST0
        MOV     T, AH
        MOV     AH, PH            ; restore current high result
        POP     ST0
        B       LSHIFT, GT
        CLRC    SXM
RSHIFT
        B       END_NORMALIZE, EQ
        SFR     ACC, 1
        INC     T
        B       RSHIFT, LEQ
LSHIFT
        LSL     ACC, 1
        DEC     T
        B       LSHIFT, GT
END_NORMALIZE
        B   	TEST_SIGN
*
*;*****************************************************************************
*; Convert number to signed value                                             *
*;*****************************************************************************
*
TEST_SIGN1
	MOV	AH,PH
TEST_SIGN
        TBIT    OP_SE, #8       ; test sign bit
        B       POSITIVE, NTC   ; leave number alone if positive
        NEG     ACC             ; convert to two's compliment value
POSITIVE
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        RET
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
UNDERFLOW
         MOV    ACC, #0
         RET
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #07fffh     ; load return value with saturated value
        MOV     AL, #0ffffh     ; load return value with saturated value
        TBIT    OP_SE, #8
        B       RETURN, NTC
        ADD     ACC, #1         ; Add one to get -2147483648
        RET 
	.endasmfunc

fs_tol28.inc/   1146129408  0     0     0       11143     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOL - convert a floating point value to a 32-bit signed integer       *
*;  FS_TOL v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOL                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 32-bit signed integer.  Upon           +----------------+ *
*;       entry the floating point number is in                                *
*;       ACC.  When the conversion is complete,                               *
*;       the integer value will be in ACC                                     *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  A is unpacked into sign,                            *
*;            exponent, and mantissa.                                         *
*;            If the exponent exceeds a value of 09Eh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 09Eh, the                                 *
*;            mantissa is normalized and returned.                            *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOL

FS$$TOL		.asmfunc
	 .asg	AR4, OP_SE

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;*****************************************************************************
*
	CLRC	OVM		; Clear OVM to get desired result in NEG.
        TEST    ACC
        B       ZERO, EQ        ; if OP is zero, return
        MOVZ    OP_SE, AH       ; save original high mantissa
        AND     AH, #07Fh       ; zero sign & exp to get mantissa
        ADD     AH, #080h       ; add implied 1 to mantissa
        LSL     ACC, 7          ; shift mantissa to ready for denormalization
        MOV     PH, AH          ; save current high result
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
        MOVZ    OP_SE, AH       ; save sign and exponent
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 09Eh; 09Dh is the exponent for integer values      *
*;             in the absolute range from 1073741824 to 2147483648.           *
*;             Result returned is 7FFFFFFFh or 80000000h                      *
*;    Case 3:  exponents in the range of 07Fh to 09Dh inclusive will result   *
*;             in 16-bit signed integer values from -2MB to +2MB              *
*;*****************************************************************************
*
        AND     AH, #0FFh
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #1Eh       ; if exponent > 09Dh then overflow occurs
        B       OVERFLOW, GT
        B       TEST_SIGN1, EQ ; test if denormalizing shift count is zero
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 32-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize                                   *
*;*****************************************************************************
*
	NEG	AH
	MOV	T, AH
	MOV	AH, PH		  ; restore current high result
	LSRL	ACC,T		  ; 

	B	TEST_SIGN,UNC
*
*;*****************************************************************************
*; Convert number to signed value                                             *
*;*****************************************************************************
*
TEST_SIGN1
	MOV	AH,PH
TEST_SIGN
        TBIT    OP_SE, #8       ; test sign bit
        B       POSITIVE, NTC   ; leave number alone if positive
        NEG     ACC             ; convert to two's compliment value
POSITIVE
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        LRETR
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
UNDERFLOW
         MOV    ACC, #0
         LRETR
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #07fffh     ; load return value with saturated value
        MOV     AL, #0ffffh     ; load return value with saturated value
        TBIT    OP_SE, #8
        B       RETURN, NTC
        ADD     ACC, #1         ; Add one to get -2147483648
        LRETR 
	.endasmfunc

fs_toll.asm/    1146129408  0     0     0       363       `
******************************************************************************
* fs_toll.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fs_toll28.inc"
        .endif

fs_toll28.inc/  1146129408  0     0     0       11105     `
         .width 96
;******************************************************************************
;*                                                                            *
;*  FS_TOLL v4.1.3 
;*  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
;*  FS$$TOLL  - Convert an IEEE 754 format single precision floating point    *
;*              number into an unsigned 64 bit long long integer	      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
*;                                                                            *
*;       FS$$TOLL                                            register file   *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 64-bit signed integer.  Upon           +----------------+ *
*;       entry the floating point number is in                                *
*;       ACC.  When the conversion is complete,                               *
*;       the integer value will be in ACC:P                                   *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  A is unpacked into sign,                            *
*;            exponent, and mantissa.                                         *
*;            If the exponent exceeds a value of 0BEh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 0BEh, the                                 *
*;            mantissa is normalized and returned.                            *
*;                                                                            *
*;       result:  returned in ACC:P                                           *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOLL

FS$$TOLL	.asmfunc
	 .asg	AR4, OP_SE

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;*****************************************************************************
*
        TEST    ACC
        B       ZERO, EQ        ; if OP is zero, return
        MOVZ    OP_SE, AH       ; save original high mantissa
        AND     AH, #07Fh       ; zero sign & exp to get mantissa
        ADD     AH, #080h       ; add implied 1 to mantissa
        LSL     ACC, 7          ; shift mantissa to ready for denormalization
        MOV     PH, AH          ; save current high result
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 09Eh; 09Dh is the exponent for integer values      *
*;             in the absolute range from 1073741824 to 2147483648.           *
*;             Result returned is 7FFFFFFFh or 80000000h                      *
*;    Case 3:  exponents in the range of 07Fh to 09Dh inclusive will result   *
*;             in 16-bit signed integer values from -2MB to +2MB              *
*;*****************************************************************************
*
        AND     AH, #0FFh
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #3Eh       ; if exponent > 0BDh then overflow occurs
        B       OVERFLOW, GT
        B       TEST_SIGN1, EQ ; test if denormalizing shift count is zero
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 64-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize                                   *
*;*****************************************************************************
*
	NEG	AH		  ;
	MOV	T, AH		  ;
	MOV	AH,PH		  ;
	MOV	P,#0		  ;
	LSR64   ACC:P, T	  ;
	B	TEST_SIGN, UNC    ;

*
*;*****************************************************************************
*; Convert number to signed value                                             *
*;*****************************************************************************
*
TEST_SIGN1
	MOV	AH,PH
	MOV	P, #0
TEST_SIGN
        TBIT    OP_SE, #15      ; test sign bit
        B       POSITIVE, NTC   ; leave number alone if positive
        NEG64   ACC:P           ; convert to two's compliment value
POSITIVE
        LRETR
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Set ACC to 0x80000000:00000000 if sign is negative; otherwise             *
*;          to 0x7fffffff:ffffffff                                            *
*;*****************************************************************************
*
OVERFLOW:
	MOV	OVC, OP_SE	; Load OVC with bits 15-10 of OP_SE, which
				; is sign bit and 5 MSB of exponent 
	SAT64	ACC:P		; If OVC > 0 ACC:P = 0x7fffffff:ffffffff
				; else if OVC < 0, ACC:P = 0x80000000:00000000
				; When OVC = 0, ACC is not modified. For this 
				; case to happen, 5 MSBs of exp should be zero
				; which means the exponent is less than 0x3FF 
				; and should have been underflowed.           
        LRETR
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
ZERO
UNDERFLOW
         ZAPA
         LRETR			 ; return
	.endasmfunc


fs_tou.asm/     1146129408  0     0     0       695       `
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOU - convert a floating point value to a 16-bit unsigned integer     *
*;  FS_TOU v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_tou27.inc"
        .elseif .TMS320C2800
                .include "fs_tou28.inc"
        .endif


fs_tou27.inc/   1146129408  0     0     0       10848     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOU - convert a floating point value to a 16-bit unsigned integer     *
*;  FS_TOU v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOU                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 16-bit unsigned integer.  Upon         +----------------+ *
*;       entry the floating point number is in         AR5 |16-bit magnitude| *
*;       ACC.  When the conversion is complete,            +----------------+ *
*;       the integer value will be in AL                                      *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  A is unpacked into sign,                            *
*;            exponent, and mantissa.                                         *
*;            If the exponent exceeds a value of 08Eh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 08Eh, the                                 *
*;            denormalized result is truncacted to                            *
*;            fifteen bits and the properly signed                            *
*;            result is placed in AL.  Negative floating                      *
*;            point values are returned as zero.                              *
*;                                                                            *
*;       result:  returned in AL                                              *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOU

FS$$TOU		.asmfunc
	 .asg	AR4, OP_SE
	 .asg	AR5, RES_MAG

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP for special case treatment of zero.                               *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store most significant 16 bits of mantissa                              *
*;*****************************************************************************
*
        TEST    ACC
        B       NEGATIVE, LT    ; if OP is negative, return 0
        MOV     PH, AH          ; save AH
        LSR     AH, 7           ; remove high mantissa from AH
        MOV     OP_SE, AH       ; save sign and exponent
        MOV     AH, PH          ; restore original AH
        LSL     ACC, 9          ; zero sign & exp to get mantissa
        CLRC    SXM
        SFR     ACC, 1
        ADD     AH, #08000h     ; add implied 1 to mantissa
        MOV     RES_MAG, AH     ; save 16 most significant magnitude bits
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 08Eh; 08Eh is the exponent for integer values      *
*;             in the absolute range from 32768 to 65535.                     *
*;             Result returned is 7FFFh (the largest 16-bit value).           *
*;    Case 3:  exponents in the range of 07Fh to 08Eh inclusive will result   *
*;             in 16-bit unsigned integer values from 0 to 65535              *
*;*****************************************************************************
*	
        MOV     AH, OP_SE      ; load exponent
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #0Fh       ; if exponent > 08Eh then overflow occurs
        B       OVERFLOW, GT
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 16-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize (result in lower accumulator).    *
*;*****************************************************************************
*
        NEG     AH
        MOV     T, AH             ; place shift count into T register
        MOV     ACC, RES_MAG      ; load denormalized mantissa
        SFR     ACC, T            ; T is in [0..15]
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        RET
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
UNDERFLOW
NEGATIVE
         MOV    AL, #0
         RET
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV    AL, #0FFFFh
        RET
	.endasmfunc

fs_tou28.inc/   1146129408  0     0     0       10854     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOU - convert a floating point value to a 16-bit unsigned integer     *
*;  FS_TOU v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOU                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 16-bit unsigned integer.  Upon         +----------------+ *
*;       entry the floating point number is in         AR5 |16-bit magnitude| *
*;       ACC.  When the conversion is complete,            +----------------+ *
*;       the integer value will be in AL                                      *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  A is unpacked into sign,                            *
*;            exponent, and mantissa.                                         *
*;            If the exponent exceeds a value of 08Eh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 08Eh, the                                 *
*;            denormalized result is truncacted to                            *
*;            fifteen bits and the properly signed                            *
*;            result is placed in AL.  Negative floating                      *
*;            point values are returned as zero.                              *
*;                                                                            *
*;       result:  returned in AL                                              *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOU

FS$$TOU		.asmfunc
	 .asg	AR4, OP_SE
	 .asg	AR5, RES_MAG

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;  Test OP for special case treatment of zero.                               *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;    Store most significant 16 bits of mantissa                              *
*;*****************************************************************************
*
        TEST    ACC
        B       NEGATIVE, LT    ; if OP is negative, return 0
        MOV     PH, AH          ; save AH
        LSR     AH, 7           ; remove high mantissa from AH
        MOVZ    OP_SE, AH       ; save sign and exponent
        MOV     AH, PH          ; restore original AH
        LSL     ACC, 9          ; zero sign & exp to get mantissa
        CLRC    SXM
        SFR     ACC, 1
        ADD     AH, #08000h     ; add implied 1 to mantissa
        MOVZ    RES_MAG, AH     ; save 16 most significant magnitude bits
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 08Eh; 08Eh is the exponent for integer values      *
*;             in the absolute range from 32768 to 65535.                     *
*;             Result returned is 7FFFh (the largest 16-bit value).           *
*;    Case 3:  exponents in the range of 07Fh to 08Eh inclusive will result   *
*;             in 16-bit unsigned integer values from 0 to 65535              *
*;*****************************************************************************
*	
        MOV     AH, OP_SE      ; load exponent
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #0Fh       ; if exponent > 08Eh then overflow occurs
        B       OVERFLOW, GT
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 16-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize (result in lower accumulator).    *
*;*****************************************************************************
*
        NEG     AH
        MOV     T, AH             ; place shift count into T register
        MOV     ACC, RES_MAG      ; load denormalized mantissa
        SFR     ACC, T            ; T is in [0..15]
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        LRETR
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
UNDERFLOW
NEGATIVE
         MOV    AL, #0
         LRETR
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV    AL, #0FFFFh
        LRETR
	.endasmfunc

fs_toul.asm/    1146129408  0     0     0       696       `
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOUL - convert a floating point value to a 32-bit unsigned integer    *
*;  FS_TOUL v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "fs_toul27.inc"
        .elseif .TMS320C2800
                .include "fs_toul28.inc"
        .endif
fs_toul27.inc/  1146129408  0     0     0       11173     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOUL - convert a floating point value to a 32-bit unsigned integer    *
*;  FS_TOUL v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOUL                                            register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 32-bit unsigned integer.  Upon         +----------------+ *
*;       entry the floating point number is in                                *
*;       ACC.  When the conversion is complete,                               *
*;       the integer value will be in ACC                                     *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  The exponent is used as a                           *
*;            shift value to denormalize the mantissa.                        *
*;            If the exponent exceeds a value of 09Fh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 09Fh, the                                 *
*;            mantissa is normalized and returned.                            *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOUL

FS$$TOUL	.asmfunc
	 .asg	AR4, OP_SE

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;*****************************************************************************
*
        TEST    ACC
        B       NEGATIVE, LT    ; if OP is negative, return 0
        MOV     OP_SE, AH       ; save original high mantissa
        LSL     ACC, 8          ; zero sign & exp to get mantissa
        OR      AH, #08000h     ; add implied 1 to mantissa
        MOV     PH, AH          ; save current high result
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
        MOV     OP_SE, AH       ; move exponent into OP_SE
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 09Eh                                               *
*;             Result returned is 80000000h                                   *
*;    Case 3:  exponents in the range of 07Fh to 09Eh inclusive will result   *
*;             in 16-bit signed integer values from 0 to +4MB                 *
*;*****************************************************************************
*
        AND     AH, #0FFh      ; mask sign bit
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #1Fh       ; if exponent > 09Eh then overflow occurs
        B       OVERFLOW, GT
        B       RETURN1, EQ    ; if resulting exponent (shift value) == 0
                               ; then we're done
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 32-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize                                   *
*;*****************************************************************************
*
        ADD     AH, #010h         ; check if right shift is > 16
        B       FIN_SHIFT, GEQ    ; if exp >= -16, only one shift is needed
        MOV     AL, PH            ; else shift 16
        MOV     PH, #0            ; else shift 16
        B       DENORMALIZE
FIN_SHIFT
        SUB     AH, #010h         ; restore original shift value if right shift
                                  ; is <= 16
DENORMALIZE
        TEST    ACC
        PUSH    ST0
        MOV     T, AH
        MOV     AH, PH            ; restore current high result
        POP     ST0
        B       LSHIFT, GT
        CLRC    SXM
RSHIFT
        B       END_NORMALIZE, EQ
        SFR     ACC, 1
        INC     T
        B       RSHIFT, LEQ
LSHIFT
        LSL     ACC, 1
        DEC     T
        B       LSHIFT, GT
END_NORMALIZE
	B	RETURN
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN1
	MOV	AH,PH
RETURN
        RET
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #0ffffh     ; load return value with saturated value
        MOV     AL, #0ffffh     ; load return value with saturated value
        RET 
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
NEGATIVE
UNDERFLOW
         MOV    ACC, #0
         RET
	.endasmfunc


fs_toul28.inc/  1146129408  0     0     0       10435     `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  FS$$TOUL - convert a floating point value to a 32-bit unsigned integer    *
*;  FS_TOUL v4.1.3 
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       FS$$TOUL                                            register file    *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 32-bit unsigned integer.  Upon         +----------------+ *
*;       entry the floating point number is in                                *
*;       ACC.  When the conversion is complete,                               *
*;       the integer value will be in ACC                                     *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  The exponent is used as a                           *
*;            shift value to denormalize the mantissa.                        *
*;            If the exponent exceeds a value of 09Fh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 09Fh, the                                 *
*;            mantissa is normalized and returned.                            *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOUL

FS$$TOUL	.asmfunc
	 .asg	AR4, OP_SE

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;*****************************************************************************
*
        TEST    ACC
        B       NEGATIVE, LT    ; if OP is negative, return 0
        MOVZ    OP_SE, AH       ; save original high mantissa
        LSL     ACC, 8          ; zero sign & exp to get mantissa
        OR      AH, #08000h     ; add implied 1 to mantissa
        MOV     PH, AH          ; save current high result
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
        MOVZ    OP_SE, AH       ; move exponent into OP_SE
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 09Eh                                               *
*;             Result returned is 80000000h                                   *
*;    Case 3:  exponents in the range of 07Fh to 09Eh inclusive will result   *
*;             in 16-bit signed integer values from 0 to +4MB                 *
*;*****************************************************************************
*
        AND     AH, #0FFh      ; mask sign bit
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #1Fh       ; if exponent > 09Eh then overflow occurs
        B       OVERFLOW, GT
        B       RETURN1, EQ    ; if resulting exponent (shift value) == 0
                               ; then we're done
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 32-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize                                   *
*;*****************************************************************************
*
	NEG	AH
	MOV	T, AH
	MOV	AH, PH		  ; restore current high result
	LSRL	ACC,T		  ; 

	B	RETURN,UNC
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN1
	MOV	AH,PH
RETURN
        LRETR
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #0ffffh     ; load return value with saturated value
        MOV     AL, #0ffffh     ; load return value with saturated value
        LRETR 
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
NEGATIVE
UNDERFLOW
         MOV    ACC, #0
         LRETR
	.endasmfunc

fs_toull.asm/   1146129408  0     0     0       365       `
******************************************************************************
* fs_toull.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "fs_toull28.inc"
        .endif

fs_toull28.inc/ 1146129408  0     0     0       10527     `
         .width 96
;******************************************************************************
;*                                                                            *
;*  FS_TOULL v4.1.3 
;*  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
;*  FS$$TOULL  - Convert an IEEE 754 format single precision floating point   *
;*               number into an unsigned 64 bit long long integer	      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
*;                                                                            *
*;       FS$$TOULL                                            register file   *
*;                                                         +----------------+ *
*;       This routine converts a floating point        AR4 | OP sign & exp  | *
*;       value to a 64-bit unsigned integer.  Upon         +----------------+ *
*;       entry the floating point number is in                                *
*;       ACC.  When the conversion is complete,                               *
*;       the integer value will be in ACC:P                                   *
*;                                                                            *
*;       inputs:  A (floating point value) in ACC                             *
*;                                                                            *
*;       implementation:  The exponent is used as a                           *
*;            shift value to denormalize the mantissa.                        *
*;            If the exponent exceeds a value of 0BFh                         *
*;            then an overflow has occurred and a                             *
*;            saturated value will be returned.  For                          *
*;            all exponents less than 07Fh the value                          *
*;            of zero is returned.  Within the exponent                       *
*;            range of 07Fh through 0BFh, the                                 *
*;            mantissa is normalized and returned.                            *
*;                                                                            *
*;       result:  returned in ACC:P                                           *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   FS$$TOULL

FS$$TOULL	.asmfunc
	 .asg	AR4, OP_SE

*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - UNPACK                         *
*;    Save the sign and exponent on the stack [xxxx xxxS EEEE EEEE].          *
*;    Add the implied one to the mantissa value.                              *
*;*****************************************************************************
*
        TEST    ACC
        B       NEGATIVE, LT    ; if OP is negative, return 0
        MOVZ    OP_SE, AH       ; save original high mantissa
        LSL     ACC, 8          ; zero sign & exp to get mantissa
        OR      AH, #08000h     ; add implied 1 to mantissa
        MOV     PH, AH          ; save current high result
        MOV     AH, OP_SE       ; restore original high mantissa
        LSR     AH, 7
        MOVZ    OP_SE, AH       ; move exponent into OP_SE
*
*;*****************************************************************************
*;       EXPONENT EVALUATION                                                  *
*;  Test the exponent to determine into which of the three cases it belongs.  *
*;    Case 1:  exponents < 07Fh; 07Fh is the exponent for integer value 1.    *
*;             Result returned is 0 since the absolute value is less than 1.  *
*;    Case 2:  exponents > 09Eh                                               *
*;             Result returned is 80000000h                                   *
*;    Case 3:  exponents in the range of 07Fh to 09Eh inclusive will result   *
*;             in 16-bit signed integer values from 0 to +4MB                 *
*;*****************************************************************************
*
        AND     AH, #0FFh      ; mask sign bit
        SUB     AH, #07Fh      ; if exponent < 07Fh then underflow occurs
        B       UNDERFLOW, LT
        SUB     AH, #3Fh       ; if exponent > 09Eh then overflow occurs
        B       OVERFLOW, GT
        B       RETURN, EQ     ; if resulting exponent (shift value) == 0
                               ; then we're done
*
*;*****************************************************************************
*;       NORMAL REPRESENTABLE 64-BIT RESULTS                                  *
*;  Load shift value needed to denormalize to T register                      *
*;  Shift via the T-register to denormalize                                   *
*;*****************************************************************************
*
	NEG	AH		  ;
	MOV	T, AH		  ;
	MOV	AH,PH		  ;
	MOV	P,#0		  ;
	LSR64   ACC:P, T	  ;
	LRETR			  ; return
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
	MOV	AH,PH
	MOV     P,#0
        LRETR			  ; return
*
*;*****************************************************************************
*;       OVERFLOW PROCESSING                                                  *
*;  Load accumulator with return value.                                       *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #0ffffh     ; load return value with saturated value
        MOV     AL, #0ffffh     ; 
	MOVL	P,ACC
        LRETR 			; return
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Load accumulator with return value.                                       *
*;  This is not an error condition since results are always truncated.        *
*;*****************************************************************************
*
NEGATIVE
UNDERFLOW
         ZAPA
         LRETR			 ; return
	.endasmfunc


fscanf.c/       1146129408  0     0     0       5661      `
/*****************************************************************************/
/*  FSCANF.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSCANF      -  Read formatted input from a stream                      */
/*    SCANF       -  Read formatted input from stdin                         */
/*    _INPCHAR    -  Get a character from the stream                         */
/*    _UNINPCHAR  -  Put a character back onto the stream                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static int _inpchar(void **inp);
static void _uninpchar(void **inp, int outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);

/*****************************************************************************/
/* FSCANF   -  Read formatted input from a stream                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/
_CODE_ACCESS int fscanf(FILE *_fp, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (_fp->fd == -1) return (EOF);

   return (_scanfi((void *)_fp, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
   
}

/*****************************************************************************/
/* SCANF -  Read formatted input from stdin                                  */
/*                                                                           */ 
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/ 
int scanf(const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (stdin->fd == -1) return (EOF);

   return (_scanfi((void *)stdin, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
 
}

/*****************************************************************************/
/* _INPCHAR -  Get a character from the stream                               */
/*****************************************************************************/
static int _inpchar(void **inp) { return (fgetc((FILE *)(*inp))); }

/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back onto the stream                       */
/*****************************************************************************/
static void _uninpchar(void **inp, int outchar)
{ 
   ungetc(outchar, (FILE *)*inp);
}

/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns an EOF if   */
/*    the end of the file is reached prematurely, a 0 upon reaching the end  */
/*    of the format string, or a 1 if a '%' is encountered.                  */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   FILE        *_fp = (FILE *)*inp;
   signed char  c;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while (isspace(**_format))
   {
      for(c = fgetc(_fp);isspace(c);c = fgetc(_fp)) (*num_read)++;
      ungetc(c, _fp);
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if (*((*_format)++) != (c = fgetc(_fp))) 
      {
         ungetc(c, _fp);
         return ((c == EOF) ? EOF : 0);
      }
      else (*num_read)++;

   if (**_format == '%') return 1;
   else return (0);
}


fseek.c/        1146129408  0     0     0       2342      `
/*****************************************************************************/
/*  FSEEK.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSEEK -  Reposition the file pointer of a stream                       */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _doflush(FILE *_fp);




/*****************************************************************************/ 
/* FSEEK -  Reposition the file pointer of a stream                          */
/*                                                                           */ 
/*    This funtion flushes stream _FP, clears the EOF and I/O Error flags,   */
/*    repositions the file pointer of the stream.  It returns a 0 upon       */
/*    success, and an EOF upon failure.                                      */
/*                                                                           */ 
/*****************************************************************************/ 
_CODE_ACCESS int fseek(register FILE *_fp, long _offset, int _ptrname)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* When positioning to a location relative to the current location,       */
   /* adjust for the fact that there may be something in the buffer.         */
   /*------------------------------------------------------------------------*/
   if(_ptrname == SEEK_CUR && _STCHK(_fp, _MODER) && _fp->buff_stop)
      _offset -= (_fp->buff_stop - _fp->pos);

   _doflush(_fp);

   _UNSET(_fp, (_STATEOF | _UNGETC));
   
   if((lseek(_fp->fd, _offset, _ptrname)) == -1) return (EOF);
   
   return (0);
}
   
fsetpos.c/      1146129408  0     0     0       1044      `
/*****************************************************************************/
/*  FSETPOS.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSETPOS  -  Position the file indicator for stream _FP                 */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"


/*****************************************************************************/
/* FSETPOS  -  Position the file indicator for stream _FP                    */
/*****************************************************************************/
_CODE_ACCESS int fsetpos(FILE *_fp, const fpos_t *_pos)
{
   return (fseek(_fp, *_pos, SEEK_SET));
}

ftell.c/        1146129408  0     0     0       3089      `
/*****************************************************************************/
/*  FTELL.C v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <errno.h>
#include <stdio.h>
#include "file.h"

/*****************************************************************************/
/* FTELL -  Get the location of the file pointer in a stream                 */
/*                                                                           */
/*    This function gets the current location of the file pointer for the    */
/*    given stream, and returns it after adjusting it for any inaccuracies   */
/*    that buffering might have caused.                                      */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS long ftell(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   fpos_t  _pos;
   int   adjust   = 0;

   /*------------------------------------------------------------------------*/
   /* If the stream pointer given is not currently open, return a -1.        */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* For files in read mode, we must subtract the unread data in the buffer */
   /* from the location of the file pointer.  For files in write mode, we    */
   /* must add the data in the buffer that has not yet gone to disk.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODER) && _fp->buff_stop > _fp->pos)
      adjust = -(_fp->buff_stop - _fp->pos);
   if(_STCHK(_fp, _MODEW)) adjust = (_fp->pos - _fp->buf); 
 
   /*------------------------------------------------------------------------*/
   /* Get the file pointer's position                                        */
   /*------------------------------------------------------------------------*/
   _pos = lseek(_fp->fd, 0L, SEEK_CUR);

   /*------------------------------------------------------------------------*/
   /* If the call to lseek was unsuccessful, return an -1                    */
   /*------------------------------------------------------------------------*/
   if(_pos < 0) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* Make the necessary adjustment, and return the value                    */
   /*------------------------------------------------------------------------*/
   _pos += adjust;
   return (_pos);
}


fwrite.c/       1146129408  0     0     0       7512      `
/*****************************************************************************/
/*  FWRITE.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FWRITE   -  Write a block of bytes to a stream                         */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <stdlib.h>
#include <string.h>
 
extern int _doflush(FILE *_fp);
extern int _wrt_ok(FILE *_fp);

 
/*****************************************************************************/
/* FWRITE   -  Write a block of bytes to a stream                            */
/*                                                                           */
/*    This function reads _COUNT blocks of size _SIZE from a buffer          */
/*    pointed to by _PTR, and writes them to stream _FP.  It returns the     */
/*    number of blocks successfully written.                                 */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS size_t fwrite(const void *_ptr, size_t _size, size_t _count,
                           register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char    *fpos       = (unsigned char *)_ptr;
   unsigned char    *nl_pos;
            size_t   buffer_size = (_fp->bufend - _fp->buf),
                     next_nl,
                     room_left;
            size_t   num_left    = _size * _count,
                     num_to_write,
                     num_written  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF) 
   {
       int num_written = 0;

       while (num_left > 0)
       {
	   int write_return = write(_fp->fd, 
				    (char *)fpos + num_written, num_left);
	   if (write_return <= 0) 
	   { 
	       _SET(_fp, _STATERR); 
	       return (num_written / _size);
	   }
	   else
	   {
	       num_written += write_return;
	       num_left    -= write_return;
	   }
       }

       return (num_written / _size);
   }
 
   room_left   = (_fp->bufend - _fp->pos);
   if (_STCHK(_fp, _IOLBF))
       next_nl = (char *)memchr(fpos, '\n', num_left) - (char *)fpos + 1;
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* Determine how many characters should be written based on buffering  */
      /* mode.  For non-buffered streams, call the lowlevel WRITE function.  */
      /* For fully buffered streams, put as many characters in the buffer as */
      /* possible.  For line buffered streams, put characters into the       */
      /* util the buffer is full, the last character is reached, or a        */
      /* newline character is reached.                                       */
      /*---------------------------------------------------------------------*/
      switch (_BUFFMODE(_fp))
      {
         case _IOFBF : num_to_write = (room_left > num_left) ? 
                       num_left : room_left;
                       break;
 
         case _IOLBF : num_to_write = (room_left > next_nl) ? next_nl :
                       (room_left > num_left) ? num_left : room_left;
                       break;
 
         default     : return (0);
      }
 
      /*---------------------------------------------------------------------*/
      /* Write the data to the buffer, and update the buffer pointer and the */
      /* ROOM_LEFT coutner.                                                  */
      /*---------------------------------------------------------------------*/
      memcpy(_fp->pos, fpos, num_to_write);
      _fp->pos += num_to_write;
      room_left = (_fp->bufend - _fp->pos);

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, or a newline character has been encountered  */
      /* on a line-buffered stream, flush it.                                */
      /*---------------------------------------------------------------------*/
      if (room_left == 0 || (_STCHK(_fp, _IOLBF) && num_to_write == next_nl))
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR); 
            return (num_written / _size);
         }
         room_left = buffer_size;

         /*------------------------------------------------------------------*/
         /* The _DOFLUSH function clears the write flag on streams opened in */
         /* update mode.  Make sure that the write flag is still set here.   */
         /*------------------------------------------------------------------*/
         _SET(_fp, _MODEW);
      }

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      num_written += num_to_write;
      fpos += num_to_write;
      num_left -= num_to_write;
 
      /*---------------------------------------------------------------------*/
      /* For line-buffered streams, find the next occurance of a newline     */
      /* character.  If there are no more, and the remaining data will fit   */
      /* in the buffer, exit the loop where the remaining data will be moved */
      /* there.  Otherwise loop until this condition is true.                */
      /*---------------------------------------------------------------------*/
      if (_STCHK(_fp, _IOLBF))
      {
         nl_pos = (unsigned char *)memchr((fpos + 1), '\n', 
					  (num_left > 0) ? (num_left-1) : 0);
         if (! nl_pos)
         {
            if (num_left < room_left) break;
            else next_nl = buffer_size + 1;
         }
         else next_nl = (nl_pos - fpos) + 1;
      }
   }

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the characters into the buffer for line-buffered      */
   /* streams.                                                               */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _IOLBF))
   {
      memcpy(_fp->pos, fpos, num_left);
      num_written += num_left;
      _fp->pos += num_left;
   }
 
   return (num_written / _size);
}
 
gmtime.c/       1146129408  0     0     0       600       `
/****************************************************************************/
/*  gmtime v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>

_CODE_ACCESS struct tm *gmtime(const time_t *timer)
{
    time_t gtime = _tz.timezone; /* DIFFERENCE BETWEEN CURRENT TIME ZONE    */
				 /* AND GMT IN SECONDS                      */

    if (timer) gtime += *timer;
    return (localtime(&gtime));
}
guard.cpp/      1146129408  0     0     0       3056      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ functions to for one-time initialization guard variables.

*/

#include "basics.h"
#include "runtime.h"

#ifdef __EDG_IA64_ABI

typedef unsigned long long a_guard;
			/* A guard variable.  This definition must
			   match the type selected in
			   lower_init.c:add_first_time_test. */

typedef a_guard *a_guard_ptr;
			/* A pointer to a guard variable. */

/*
These functions are used by the front end only if
IA64_ABI_USE_GUARD_ACQUIRE_RELEASE is TRUE.
*/

EXTERN_C int ABI_NAMESPACE::__cxa_guard_acquire(a_guard_ptr guard)
/*
If the guard variable indicates that the guarded variable has already
been initialized, return 0.  Otherwise, return 1.
*/
{
  char *first_byte = (char *)guard;
  int  initialize = FALSE;

  if (*first_byte == 0) {
    initialize = TRUE;
  }  /* if */
  return initialize;
}  /* __cxa_guard_acquire */


EXTERN_C void ABI_NAMESPACE::__cxa_guard_release(a_guard_ptr guard)
/*
Called when the initialization of the guarded object is complete.
*/
{
  /* Set the guard variable to indicate that the initialization is complete.
     A multi-threaded implementation would then release the lock. */
  char *first_byte = (char *)guard;
  *first_byte = 1;
}  /* __cxa_guard_release */


EXTERN_C void ABI_NAMESPACE::__cxa_guard_abort(a_guard_ptr guard)
/*
The initialization of the guarded object has been aborted due to an
exception being thrown.  Reset the guard so that the initialization 
will be tried again.
*/
{
  *(char *)guard = 0;
}  /* __cxa_guard_abort */

#endif /* ifdef __EDG_IA64_ABI */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
i_div.asm/      1146129408  0     0     0       431       `
******************************************************************************
* i_div.asm  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "i_div27.inc"
        .elseif .TMS320C2800
                .include "i_div28.inc"
        .endif


i_div27.inc/    1146129408  0     0     0       3895      `
******************************************************************************
* i_div27.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the functions for signed 16-bit divide and modulus.
*
* SYMBOL DEFINITIONS:
*
*  NUM - Numerator 
*  DEN - Denominator 
*  SIGN - Sign of result
*
* NO MEMORY USED ON STACK
******************************************************************************

******************************************************************************
* ASSIGN ALIASES TO REGISTERS USED
******************************************************************************
	.asg	AR6,SIGN     	; sign of result
	.asg	AR4,DEN	 	; denominator
	.asg	AR5,NUM	 	; numerator

	.page
******************************************************************************
* 16-BIT SIGNED DIVIDE, CALCULATE NUM/DEN RETURN QUOTIENT IN AL
******************************************************************************
	.global	I$$DIV

I$$DIV:		.asmfunc
******************************************************************************
* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	MOV	DEN,AH		; store off divisor
	XOR	AH,AL		; determine sign of result			
	MOV	SIGN,AH		; save off sign of result

	SETC	SXM		; turn on sign-extension, needed for ABS step
	MOV	ACC,AL		; sign-extend dividend		 
	ABS	ACC		; dividend = | dividend |
	MOV	NUM,AL		; save off dividend 
	MOV	ACC,DEN		; sign-extend divisor
	ABS	ACC		; divisor = | divisor |
	MOV	DEN,AL		; save off divisor

	MOV	AL,NUM		; reload dividend
******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,DEN		; divide step

******************************************************************************
* QUOTIENT IS IN AL, REMAINDER IS IN AH 
******************************************************************************
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET1,NTC	; if (1)
	NEG	AL		; negate Quotient
RET1:
	FFCRET	*XAR7		; return
	.endasmfunc



	.page
******************************************************************************
* 16-BIT SIGNED MODULUS, CALCULATE NUM % DEN, RETURN REMAINDER IN AL
******************************************************************************
	.global	I$$MOD

I$$MOD:		.asmfunc

******************************************************************************
* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	MOV	SIGN,AL		; sign of result is sign of dividend, save

	MOV	DEN,AH		; store off divisor
	SETC	SXM		; turn on sign-extension, needed for ABS step
	MOV	ACC,AL		; sign-extend dividend		 
	ABS	ACC		; dividend = | dividend |
	MOV	NUM,AL		; save off dividend 
	MOV	ACC,DEN		; sign-extend divisor
	ABS	ACC		; divisor = | divisor |
	MOV	DEN,AL		; save off divisor

	MOV	AL,NUM		; reload dividend
******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,DEN		; divide step

******************************************************************************
* QUOTIENT IS IN AL, REMAINDER IS IN AH 
******************************************************************************
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET2,NTC	; if (1)
	NEG	AH		; negate Q
RET2:
	MOV	AL,AH

	FFCRET	*XAR7		; return
	.endasmfunc

i_div28.inc/    1146129408  0     0     0       3901      `
******************************************************************************
* i_div28.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the functions for signed 16-bit divide and modulus.
*
* SYMBOL DEFINITIONS:
*
*  NUM - Numerator 
*  DEN - Denominator 
*  SIGN - Sign of result
*
* NO MEMORY USED ON STACK
******************************************************************************

******************************************************************************
* ASSIGN ALIASES TO REGISTERS USED
******************************************************************************
	.asg	AR6,SIGN     	; sign of result
	.asg	AR4,DEN	 	; denominator
	.asg	AR5,NUM	 	; numerator

	.page
******************************************************************************
* 16-BIT SIGNED DIVIDE, CALCULATE NUM/DEN RETURN QUOTIENT IN AL
******************************************************************************
	.global	I$$DIV

I$$DIV:		.asmfunc
******************************************************************************
* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	MOVZ	DEN,AH		; store off divisor
	XOR	AH,AL		; determine sign of result			
	MOV	SIGN,AH		; save off sign of result

	SETC	SXM		; turn on sign-extension, needed for ABS step
	MOV	ACC,AL		; sign-extend dividend		 
	ABS	ACC		; dividend = | dividend |
	MOVZ	NUM,AL		; save off dividend 
	MOV	ACC,DEN		; sign-extend divisor
	ABS	ACC		; divisor = | divisor |
	MOVZ	DEN,AL		; save off divisor

	MOV	AL,NUM		; reload dividend
******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,DEN		; divide step

******************************************************************************
* QUOTIENT IS IN AL, REMAINDER IS IN AH 
******************************************************************************
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET1,NTC	; if (1)
	NEG	AL		; negate Quotient
RET1:
	FFCRET	*XAR7		; return
	.endasmfunc



	.page
******************************************************************************
* 16-BIT SIGNED MODULUS, CALCULATE NUM % DEN, RETURN REMAINDER IN AL
******************************************************************************
	.global	I$$MOD

I$$MOD:		.asmfunc

******************************************************************************
* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	MOV	SIGN,AL		; sign of result is sign of dividend, save

	MOVZ	DEN,AH		; store off divisor
	SETC	SXM		; turn on sign-extension, needed for ABS step
	MOV	ACC,AL		; sign-extend dividend		 
	ABS	ACC		; dividend = | dividend |
	MOVZ	NUM,AL		; save off dividend 
	MOV	ACC,DEN		; sign-extend divisor
	ABS	ACC		; divisor = | divisor |
	MOVZ	DEN,AL		; save off divisor

	MOV	AL,NUM		; reload dividend
******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,DEN		; divide step

******************************************************************************
* QUOTIENT IS IN AL, REMAINDER IS IN AH 
******************************************************************************
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET2,NTC	; if (1)
	NEG	AH		; negate Q
RET2:
	MOV	AL,AH

	FFCRET	*XAR7		; return
	.endasmfunc

i_tofd.asm/     1146129408  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  I_TOFD v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  I$$TOFD - Convert a signed 16 bit integer into an IEEE 754 format double  *
*;            precision floating point number                                 *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "i_tofd28.inc"
        .endif

i_tofd28.inc/   1146129408  0     0     0       6956      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  I_TOFD v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  I$$TOFD  - Convert a signed 16 bit integer into an IEEE 754 format double *
;*             precision floating point number    			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN AL   
;*   o RESULT IS RETURNED IN *XAR6
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                             						      *
;*                              		    register file	      *
;*                                                +-------------------+       *
;*                                           AR4  |        | RES_EXP  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                          XAR6  | PTR TO RET VALUE  |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   I$$TOFD
        .sect     ".text"

I$$TOFD		.asmfunc
        .asg      XAR4,    XRES_EXP
        .asg       AR4,    RES_EXP
        .asg       AR5,    RES_SIGN
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
        MOVL    P, ACC            ; Save input float
        MOVL    ACC, XAR6         ;
        B       RETURN, EQ        ; Return if return pointer is null

*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Save the sign of the input                                            *
*;    3 Get the absolute value of input                                       *
*;    4 Normalize the value and adjust the exponent                           *
*;*****************************************************************************
*
	MOVL	ACC, P		; Restore input in ACC
	LSL	ACC, #16	; Move integer to AH 
	B	OP_ZERO, EQ	; Return zero if integer is zero

	MOV	RES_SIGN, AH	; Save the sign
	MOVL	XRES_EXP, #0x40D; Normalize the value and adjust the exponent

	B	$10, GEQ	; 
	SB      1, OV           ; Clear V (overflow)
	CLRC	OVM		; Clear OVM to get desired result in NEG.
	NEG	ACC		; Take absolute value of input
	B	$10, NOV	; 
	INC	RES_EXP		; Negate overflows when acc is 0x8000:0
				; Account for the overflow by incrementing exp.
$10:
	RPT	#15		;
     || NORM	ACC, XRES_EXP--	;
	
*
*;*****************************************************************************
*;     Pack the sign, mantissa and exponent into Double precision format      *
*;*****************************************************************************
*
	MOV 	P, #0 		; Zero out P

        LSR64   ACC:P, #14      ; Move the mantissa out of AH. Since only 16 
                                ; bits of the mantissa are significant this 
                                ; is not a problem
        MOV     AH, RES_EXP     ; Load exponent and remove implied one 
        LSL64   ACC:P, #4       ; Shift back mantissa and exponent

	AND	RES_SIGN, #0x8000 ; Mask the sign bit
	OR	AH, RES_SIGN	; Set the sign bit
*
RETURN_VALUE:
        MOVL    RES_LSW, P     ;
        MOVL    RES_MSW, ACC   ; Load the return value in the return area.

RETURN:
        LRETR

        .page
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
OP_ZERO:
        ZAPA	                  ; For underflow result in ACC:P = 0
        B       RETURN_VALUE,UNC
	.endasmfunc

i_tofs.asm/     1146129408  0     0     0       692       `
*;*****************************************************************************
*;                                                                            *
*;  I$$TOFS - convert a 16-bit signed integer to floating point               *
*;  I_TOFS v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "i_tofs27.inc"
        .elseif .TMS320C2800
                .include "i_tofs28.inc"
        .endif
i_tofs27.inc/   1146129408  0     0     0       9961      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  I$$TOFS - convert a 16-bit signed integer to floating point               *
*;  I_TOFS v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       I$$TOFS                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a 16-bit signed         AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in ACC.             AR5 |sign of integer | *
*;       When the conversion is complete the               +----------------+ *
*;       float value will be in ACC.                                          *
*;                                                                            *
*;       inputs:  A (integer value) in AL                                     *
*;                                                                            *
*;       implementation:  The absolute value of the                           *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            into ACC                                                        *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   I$$TOFS

I$$TOFS		.asmfunc
        .asg    AR4, EXPONENT
        .asg    AR5, SIGN
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the three cases it belongs.   *
*;    Case 1:  value is 08000h; requires special processing                   *
*;    Case 2:  value is 0; requires special processing                        *
*;    Case 3:  all other values                                               *
*;*****************************************************************************
*
        SETC    SXM
        MOV     ACC, AL         ; sign extend AL into ACC
        B       ZERO, EQ        ; Branch if integer = 0
        LSL     ACC, 16         ; move integer to AH for norm
        MOV     SIGN, AH        ; save the sign of the integer
        SB      1, OV           ; reset V so that ABS gives desired results
        ABS     ACC
        B       OVERFLOW, OV    ; branch if integer == 08000h
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (0Eh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOV     EXPONENT, #08Dh ; set exponent count to 0EH (offset binary)

	RPT	#31		;
     || NORM    ACC, EXPONENT-- ; normalize ACC to get mantissa value and
                                ; find actual exponent value
* 
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM 0000 0000 0000 0000]                *
*;  Shift mantissa   [0000 0000 0000 0000 00MM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0000 0000 00EE EEEE EEMM MMMM MMMM MMMM]                *
*;  Shift            [0EEE EEEE EMMM MMMM MMMM MMM0 000 0000]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMM0 000 0000]                *
*;*****************************************************************************
*
        AND     AH, #03FFFh         ; remove implied one and sign bit
        SFR     ACC, 16             ; shift mantissa to make room for exponent
        ADD     ACC, EXPONENT << 14 ; pack exponent
        LSL     ACC, 9              ; shift for correct placement
        TBIT    SIGN, #15           ; check sign
        B       RETURN, NTC         ; if positive, return
        OR      AH, #08000h         ; make negative
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        RET
*
*;*****************************************************************************
*;       SPECIAL CASE PROCESSING                                              *
*;  Load default for 08000h (floating point equivalent = C700 0000)           *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #0C700h
        MOV     AL, #0           ; load default value into ACC
        RET
	.endasmfunc
*


i_tofs28.inc/   1146129408  0     0     0       9997      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  I$$TOFS - convert a 16-bit signed integer to floating point               *
*;  I_TOFS v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       I$$TOFS                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a 16-bit signed         AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in ACC.             AR5 |sign of integer | *
*;       When the conversion is complete the               +----------------+ *
*;       float value will be in ACC.                                          *
*;                                                                            *
*;       inputs:  A (integer value) in AL                                     *
*;                                                                            *
*;       implementation:  The absolute value of the                           *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            into ACC                                                        *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   I$$TOFS

I$$TOFS		.asmfunc
        .asg    AR4, EXPONENT
        .asg    XAR4, XEXPONENT
        .asg    AR5, SIGN
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the three cases it belongs.   *
*;    Case 1:  value is 08000h; requires special processing                   *
*;    Case 2:  value is 0; requires special processing                        *
*;    Case 3:  all other values                                               *
*;*****************************************************************************
*
        SETC    SXM
        MOV     ACC, AL         ; sign extend AL into ACC
        B       ZERO, EQ        ; Branch if integer = 0
        LSL     ACC, 16         ; move integer to AH for norm
        MOVZ    SIGN, AH        ; save the sign of the integer
        SB      1, OV           ; reset V so that ABS gives desired results
        ABS     ACC
        B       OVERFLOW, OV    ; branch if integer == 08000h
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (0Eh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOVB    XEXPONENT, #08Dh ; set exponent count to 0EH (offset binary)

	RPT	#31
     || NORM    ACC, XEXPONENT-- ; normalize ACC to get mantissa value and
                                ; find actual exponent value
* 
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM 0000 0000 0000 0000]                *
*;  Shift mantissa   [0000 0000 0000 0000 00MM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0000 0000 00EE EEEE EEMM MMMM MMMM MMMM]                *
*;  Shift            [0EEE EEEE EMMM MMMM MMMM MMM0 000 0000]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMM0 000 0000]                *
*;*****************************************************************************
*
        AND     AH, #03FFFh         ; remove implied one and sign bit
        SFR     ACC, 16             ; shift mantissa to make room for exponent
        ADD     ACC, EXPONENT << 14 ; pack exponent
        LSL     ACC, 9              ; shift for correct placement
        TBIT    SIGN, #15           ; check sign
        B       RETURN, NTC         ; if positive, return
        OR      AH, #08000h         ; make negative
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        LRETR
*
*;*****************************************************************************
*;       SPECIAL CASE PROCESSING                                              *
*;  Load default for 08000h (floating point equivalent = C700 0000)           *
*;*****************************************************************************
*
OVERFLOW
        MOV     AH, #0C700h
        MOV     AL, #0           ; load default value into ACC
        LRETR
	.endasmfunc
*


inttypes.h/     1146129408  0     0     0       5509      `
/*****************************************************************************/
/* INTTYPES.H v4.1.3                                                         */
/* Copyright (c) 2002-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _INTTYPES_H_
#define _INTTYPES_H_

#include <stdint.h>

/* 7.8 Format conversion of integer types */

typedef struct { intmax_t quot, rem; } imaxdiv_t;

/* 
   According to footnotes in the 1999 C standard, "C++ implementations
   should define these macros only when __STDC_FORMAT_MACROS is defined
   before <inttypes.h> is included." 
*/
#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS)

/* 7.8.1 Macros for format specifiers */


#define PRIdLEAST8     	"d"
#define PRIiLEAST8     	"i"
#define PRIoLEAST8     	"o"
#define PRIuLEAST8     	"u"
#define PRIxLEAST8     	"x"
#define PRIXLEAST8     	"X"
#define PRIdFAST8     	"d"
#define PRIiFAST8     	"i"
#define PRIoFAST8     	"o"
#define PRIuFAST8     	"u"
#define PRIxFAST8     	"x"
#define PRIXFAST8     	"X"
#define PRId16		"d"
#define PRIi16		"i"
#define PRIo16		"o"
#define PRIu16		"u"
#define PRIx16		"x"
#define PRIX16		"X"
#define PRIdLEAST16    	"d"
#define PRIiLEAST16    	"i"
#define PRIoLEAST16    	"o"
#define PRIuLEAST16    	"u"
#define PRIxLEAST16    	"x"
#define PRIXLEAST16    	"X"
#define PRIdFAST16    	"d"
#define PRIiFAST16    	"i"
#define PRIoFAST16    	"o"
#define PRIuFAST16    	"u"
#define PRIxFAST16    	"x"
#define PRIXFAST16    	"X"

#define SCNdLEAST8 	"d"
#define SCNiLEAST8 	"i"
#define SCNoLEAST8 	"o"
#define SCNuLEAST8 	"u"
#define SCNxLEAST8 	"x"
#define SCNdFAST8 	"d"
#define SCNiFAST8 	"i"
#define SCNoFAST8 	"o"
#define SCNuFAST8 	"u"
#define SCNxFAST8 	"x"
#define SCNd16		"d"
#define SCNi16		"i"
#define SCNo16		"o"
#define SCNu16		"u"
#define SCNx16		"x"
#define SCNdLEAST16 	"d"
#define SCNiLEAST16 	"i"
#define SCNoLEAST16 	"o"
#define SCNuLEAST16 	"u"
#define SCNxLEAST16 	"x"
#define SCNdFAST16 	"d"
#define SCNiFAST16 	"i"
#define SCNoFAST16 	"o"
#define SCNuFAST16 	"u"
#define SCNxFAST16 	"x"

#define PRId32		"ld"
#define PRIi32		"li"
#define PRIo32		"lo"
#define PRIu32		"lu"
#define PRIx32		"lx"
#define PRIX32		"lX"
#define PRIdLEAST32    	"ld"
#define PRIiLEAST32    	"li"
#define PRIoLEAST32    	"lo"
#define PRIuLEAST32    	"lu"
#define PRIxLEAST32    	"lx"
#define PRIXLEAST32    	"lX"
#define PRIdFAST32    	"ld"
#define PRIiFAST32    	"li"
#define PRIoFAST32    	"lo"
#define PRIuFAST32    	"lu"
#define PRIxFAST32    	"lx"
#define PRIXFAST32    	"lX"
#define SCNd32		"ld"
#define SCNi32		"li"
#define SCNo32		"lo"
#define SCNu32		"lu"
#define SCNx32		"lx"
#define SCNdLEAST32    	"ld"
#define SCNiLEAST32    	"li"
#define SCNoLEAST32    	"lo"
#define SCNuLEAST32    	"lu"
#define SCNxLEAST32    	"lx"
#define SCNdFAST32    	"ld"
#define SCNiFAST32    	"li"
#define SCNoFAST32    	"lo"
#define SCNuFAST32    	"lu"
#define SCNxFAST32    	"lx"


#if 0 || 0 || defined(__TMS320C28X__)
#define PRId64		"lld"
#define PRIi64		"lli"
#define PRIo64		"llo"
#define PRIu64		"llu"
#define PRIx64		"llx"
#define PRIX64		"llX"
#define PRIdLEAST64    	"lld"
#define PRIiLEAST64    	"lli"
#define PRIoLEAST64    	"llo"
#define PRIuLEAST64    	"llu"
#define PRIxLEAST64    	"llx"
#define PRIXLEAST64    	"llX"
#define PRIdFAST64    	"lld"
#define PRIiFAST64    	"lli"
#define PRIoFAST64    	"llo"
#define PRIuFAST64    	"llu"
#define PRIxFAST64    	"llx"
#define PRIXFAST64    	"llX"
#define SCNd64		"lld"
#define SCNi64		"lli"
#define SCNo64		"llo"
#define SCNu64		"llu"
#define SCNx64		"llx"
#define SCNdLEAST64    	"lld"
#define SCNiLEAST64    	"lli"
#define SCNoLEAST64    	"llo"
#define SCNuLEAST64    	"llu"
#define SCNxLEAST64    	"llx"
#define SCNdFAST64    	"lld"
#define SCNiFAST64    	"lli"
#define SCNoFAST64    	"llo"
#define SCNuFAST64    	"llu"
#define SCNxFAST64    	"llx"
#endif

#define PRIdPTR		"ld"
#define PRIiPTR		"li"
#define PRIoPTR		"lo"
#define PRIuPTR		"lu"
#define PRIxPTR		"lx"
#define PRIXPTR		"lX"
#define SCNdPTR		"ld"
#define SCNiPTR		"li"
#define SCNoPTR		"lo"
#define SCNuPTR		"lu"
#define SCNxPTR		"lx"

#if defined(__TMS320C27X__) || 0 || 0
#define PRIdMAX		"ld"
#define PRIiMAX		"li"
#define PRIoMAX		"lo"
#define PRIuMAX		"lu"
#define PRIxMAX		"lx"
#define PRIXMAX		"lX"
#define SCNdMAX		"ld"
#define SCNiMAX		"li"
#define SCNoMAX		"lo"
#define SCNuMAX		"lu"
#define SCNxMAX		"lx"
#elif defined(__TMS320C28X__) || defined(__TMS320C55X__) || defined(__TMS470__) || defined(_TMS320C6X)
#define PRIdMAX		"lld"
#define PRIiMAX		"lli"
#define PRIoMAX		"llo"
#define PRIuMAX		"llu"
#define PRIxMAX		"llx"
#define PRIXMAX		"llX"
#define SCNdMAX		"lld"
#define SCNiMAX		"lli"
#define SCNoMAX		"llo"
#define SCNuMAX		"llu"
#define SCNxMAX		"llx"
#endif

#endif /* !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) */

/* 7.8.2 Functions for greatest-width integer types */
#include <linkage.h>

_CODE_ACCESS intmax_t  imaxabs(intmax_t j);
_CODE_ACCESS imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
_CODE_ACCESS intmax_t  strtoimax(const char * restrict nptr, 
		    char ** restrict endptr, int base);
_CODE_ACCESS uintmax_t strtoumax(const char * restrict nptr, 
		    char ** restrict endptr, int base);

#endif /* _INTTYPES_H_ */

isalnum.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isalnum v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isalnum(int c)
{
    return(_isalnum(c));
}

isalpha.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isalpha v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isalpha(int c)
{
    return(_isalpha(c));
}

isascii.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isascii v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isascii(int c)
{
    return(_isascii(c));
}

iscntrl.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  iscntrl v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int iscntrl(int c)
{
    return(_iscntrl(c));
}

isdigit.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isdigit v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isdigit(int c)
{
    return(_isdigit(c));
}

isgraph.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isgraph v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isgraph(int c)
{
    return(_isgraph(c));
}

islower.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  islower v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int islower(int c)
{
    return(_islower(c));
}

iso646.h/       1146129408  0     0     0       528       `
/*****************************************************************************/
/* ISO646.H v4.1.3                                                           */
/* Copyright (c) 2000-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#define and    &&
#define and_eq &=
#define bitand &
#define bitor  |
#define compl  ~
#define not    !
#define not_eq !=
#define or     ||
#define or_eq  |=
#define xor    ^
#define xor_eq ^=
isprint.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isprint v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isprint(int c)
{
    return(_isprint(c));
}

ispunct.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  ispunct v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int ispunct(int c)
{
    return(_ispunct(c));
}

isspace.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isspace v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isspace(int c)
{
    return(_isspace(c));
}

isupper.c/      1146129408  0     0     0       426       `
/****************************************************************************/
/*  isupper v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isupper(int c)
{
    return(_isupper(c));
}

isxdigit.c/     1146129408  0     0     0       428       `
/****************************************************************************/
/*  isxdigit v4.1.3                                                         */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isxdigit(int c)
{
    return(_isxdigit(c));
}

l_div.asm/      1146129408  0     0     0       429       `
******************************************************************************
* l_div.asm  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "l_div27.inc"
        .elseif .TMS320C2800
                .include "l_div28.inc"
        .endif

l_div27.inc/    1146129408  0     0     0       14719     `
******************************************************************************
* l_div27.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************


******************************************************************************
* This module contains the functions for 32-bit divide and modulus, signed and
* unsigned.  This stack map and these defines apply to all the routines in 
* this module.               
*
* SYMBOL DEFINITIONS:
*
* QUOT  - Dividend on input, quotient on output
* DEN   - denominator 
* REM   - remainder
* xHI   - High word of that object
* xLO   - Low word of that object
* COUNT - Iteration count of divide routine
* SIGN  - Sign of result
*
******************************************************************************

;	STACK MAP
;
;	+-----------+	
;	|           |    <-- SP (during MAINDIV routine)
;	+-----------+
;	| return    |    
;	+-----------+
;	| address   |  0 <-- SP (after frame allocation)
;	+-----------+	
;	|  REM_HI   | -1
;	+-----------+
;	|  REM_LO   | -2
;	+-----------+
;	|  NUM_HI   | -3
;	+-----------+
;	|  NUM_LO   | -4 <-- SP (on entry)
;	+-----------+	
;	| no return address
;	+-----------+
;	| called with FFC, return in XAR7
;	+-----------+
;	|  DEN_HI   | -5  (-7 from MAINDIV)
;	+-----------+
;	|  DEN_LO   | -6  (-8 from MAINDIV)
;	+-----------+
;	|           |
;
; Numerator passed in ACC, denominator is on stack


FSIZE	.set	4		; frame size

******************************************************************************
* SET UP ALIASES FOR STACK REFERENCES AND REGISTERS USED
******************************************************************************
	.asg	AR5,COUNT	; iteration counter
	.asg	AR6,SIGN	; sign of result
	.asg	*-SP[5],DEN_HI	; denominator high
	.asg	*-SP[6],DEN	; denominator 
	.asg	*-SP[2],REM	; remainder
	.asg	*-SP[4],QUOT	; quotient	
	.asg 	*-SP[4],NUM	; numerator (store in same place as quotient)

	.asg	*-SP[6 + 2],MD_DEN    	; MAINDIV access of denominator
	.asg	*-SP[4 + 2],MD_QUOT 	; MAINDIV access of quotient
	.asg    *-SP[2 + 2],MD_REM	; MAINDIV access of remainder

	.page
******************************************************************************
* 32-bit SIGNED DIVIDE, CALCULATE NUM / DEN AND RETURN IN ACCUMULATOR 
******************************************************************************
	.global	L$$DIV

L$$DIV:		.asmfunc
******************************************************************************
* ALLOCATE FRAME, THE COMPILER WILL DO ANY NECESSARY SAVING OF REGISTERS
* USED AT THE CALL SITE
******************************************************************************
	MPYB	P,T,#0
	PUSHL 	PL:PH
	PUSHL	PL:PH

******************************************************************************
* DETERMINE SIGN OF RESULT
******************************************************************************
	CLRC	OVM		; Clear OVM to get desired effect on ABS & NEG
	MOVL	NUM,ACC		; save off numerator
	XOR	AH,DEN_HI	; determine sign of result
	MOV	SIGN,AH		; save off sign of result

******************************************************************************
* TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	MOVL	ACC,DEN		; load denominator
	ABS	ACC		; take absolute value of denominator
	MOVL	DEN,ACC		; save off |denominator|

	MOVL	ACC,NUM		; load numerator
	ABS	ACC		; take absolute value of numerator
	
******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	CMPL	ACC,DEN		; compare denominator to numerator
	B	EQ1,EQ		; branch if equal (return 1)
	B	EQ0,LO		; branch if denominator > numerator (return 0)

******************************************************************************
* CALL MAIN DIVIDE ROUTINE
******************************************************************************
	CALL	MAINDIV		; call main divide routine
	MOV	ACC,P	        ; load result into ACC


******************************************************************************
* QUOTIENT IS IN ACC
******************************************************************************
CHECK_SIGN1:
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET1,NTC	; return quotient as is if positive, otherwise
	NEG	ACC		; negate quotient
RET1:
	SUBB	SP,#FSIZE	; deallocate frame
	FFCRET	*XAR7		; return

******************************************************************************
* DENOMINATOR == NUMERATOR RETURN 1 (OR -1)
******************************************************************************
EQ1:
	MOVB	ACC,#1		; tentatively set quotient to 1
	B	CHECK_SIGN1	; check sign and return

******************************************************************************
* IF DENOMINATOR > NUMERATOR, RETURN 0
******************************************************************************
EQ0:
	MOVB 	ACC,#0		; set quotient to zero
	B	RET1		; return
	.endasmfunc



	.page
******************************************************************************
* 32-bit SIGNED MODULUS, CALCULATE NUM % DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	L$$MOD

L$$MOD:		.asmfunc
******************************************************************************
* ALLOCATE FRAME
******************************************************************************
	MPYB	P,T,#0
	PUSHL 	PL:PH
	PUSHL	PL:PH

******************************************************************************
* DETERMINE SIGN OF RESULT
******************************************************************************
	CLRC	OVM		; Clear OVM to get desired effect on ABS & NEG
	MOV	SIGN,AH		; sign of result is sign of numerator

******************************************************************************
* TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	ABS	ACC		; take absolute value of numerator
	MOVL	NUM,ACC		; save off |numerator|

	MOVL	ACC,DEN		; load denominator
	ABS	ACC		; take absolute value of denominator
	MOVL	DEN,ACC		; save off |denominator|

	MOVL	ACC,NUM		; reload numerator

******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	CMPL	ACC,DEN		; compare denominator to numerator
	B	EQ2,EQ		; branch if equal (return 0)
	B	CHECK_SIGN2,LO  ; if (denominator > numerator) return numerator

******************************************************************************
* CALL MAIN DIVIDE ROUTINE, MAINDIV RETURNS QUOTIENT IN ACC
******************************************************************************
	CALL	MAINDIV		; call main divide routine
	MOVL	ACC,REM		; reload remainder

******************************************************************************
* NEGATE SIGN OF REMAINDER IF NECESSARY
******************************************************************************
CHECK_SIGN2:
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET2, NTC	; if(positive) branch to return
	NEG	ACC		; otherwise, negate remainder

RET2:
	SUBB	SP,#FSIZE	; deallocate frame
	FFCRET	*XAR7		; return

******************************************************************************
* NUM AND DEN ARE EQUAL, RETURN 0
******************************************************************************
EQ2:
	MOVB	ACC,#0		; load return register with 0
	SUBB	SP,#FSIZE	; deallocate frame
	FFCRET	*XAR7		; return
	.endasmfunc



	.page
******************************************************************************
* 32-bit UNSIGNED DIVIDE, CALCULATE NUM / DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	UL$$DIV

UL$$DIV:	.asmfunc
******************************************************************************
* ALLOCATE FRAME
******************************************************************************
	MPYB	P,T,#0
	PUSHL 	PL:PH
	PUSHL	PL:PH

******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	CMPL	ACC,DEN		; compare denominator to numerator
	B	EQ3,EQ		; branch if equal (return 1)
	B	DGT3,LO  	; branch if denominator > numerator (return 0) 
        CMP     DEN_HI,#0       ; check if upper word of denominator is zero.
        SB      DIVUDenHighZero,EQ

******************************************************************************
* CALL MAIN DIVIDE ROUTINE
******************************************************************************
	CALL	MAINDIV		; call main divide routine
	MOV	ACC,P	        ; load result into ACC

******************************************************************************
* QUOTIENT IS IN ACC
******************************************************************************
RET3:
	SUBB	SP,#FSIZE	; deallocate frame
	FFCRET	*XAR7		; return

******************************************************************************
* NUM AND DWN ARE EQUAL, RETURN 1
******************************************************************************
EQ3:
	MOVB	ACC,#1		; quotient = 1
	B	RET3		; return

******************************************************************************
* IF DEN > NUM, RETURN 0
******************************************************************************
DGT3:
	MOVB 	ACC,#0		; set quotient to zero
	B	RET3		; return

******************************************************************************
* FOLLOWING PIECE OF CODE IS FAST OUT IF UPPER WORD OF DENOMINATOR IS ZERO
******************************************************************************
DIVUDenHighZero:
        MOV     P,ACC
        MOVU    ACC,AH
        RPT     #15
      ||SUBCU   ACC,DEN
        MOV     PH,AL
        MOV     AL,PL
        RPT     #15
      ||SUBCU   ACC,DEN
        MOV     AH,PH
        B       RET3
	.endasmfunc



	.page
******************************************************************************
* 32-bit UNSIGNED MODULUS, CALCULATE NUM % DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	UL$$MOD

UL$$MOD:	.asmfunc
******************************************************************************
* ALLOCATE FRAME
******************************************************************************
	MPYB	P,T,#0
	PUSHL 	PL:PH
	PUSHL	PL:PH

******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	CMPL	ACC,DEN		; compare denominator to numerator
	B	EQ4,EQ		; branch if equal (return 0)
	B	RET4,LO         ; if (denominator > numerator) return numerator
        CMP     DEN_HI,#0       ; check if upper word of denominator is zero
        SB      MODUDenHighZero,EQ

******************************************************************************
* CALL MAIN DIVIDE ROUTINE, MOVE REMAINDER INTO ACC
******************************************************************************
	CALL	MAINDIV		; call main divide routine
	MOVL	ACC,REM		; load remainder into return ACC

******************************************************************************
* RETURN SEQUENCE
******************************************************************************
RET4:
	SUBB	SP,#FSIZE	; deallocate frame
	FFCRET	*XAR7		; return

******************************************************************************
* NUM AND DEN ARE EQUAL, RETURN 0
******************************************************************************
EQ4:
	MOVB	ACC,#0		; load return ACC with 0
	B	RET4		; return

******************************************************************************
* FOLLOWING PIECE OF CODE IS FAST OUT IF UPPER WORD OF DENOMINATOR IS ZERO.
******************************************************************************
MODUDenHighZero:
        MOV     P,ACC
        MOVU    ACC,AH
        RPT     #15
      ||SUBCU   ACC,DEN
        MOV     AL,PL
        RPT     #15
      ||SUBCU   ACC,DEN
	MOV	AL,AH
        MOV     AH,#0
        B       RET4
	.endasmfunc


	.page
******************************************************************************
* MAIN DIVIDE ROUTINE
* ASSUMES NUM AND DEN ARE UNSIGNED AND NUM != 0.  IF DEN == 0, THEN THIS 
* ROUTINE WILL TAKE A LONG TIME ...
******************************************************************************
*
* This routine is based on the following psuedo-code
*
*    count = 31;
*
*    while (q <<= 1 shifts 0 into carry)
*      count--;
* 
*    /* just shifted 1 into carry */
*    r = 1; *
*    for(;;)
*    {
*      if (r >= d)
*      {
*	 r -= d;
*	 q |= 1;
*      }
*
*      if (count-- == 0) return;
*
*      r <<= 1;
*      if (MSB(q) == 1) r |= 1;
*      q <<= 1;
*    }


******************************************************************************
* QUOT IS IN ACCUMULATOR. P REGISTER AND REMAINDER HAVE BEEN INITIALIZED TO ZERO
******************************************************************************
MAINDIV:	.asmfunc
        MOVB    AR5,#31         ; Initialize loop counter
        TEST    ACC             ; Test ACC value
        SB      LOOP,LT         ; If negative, then skip
 
        RPT     #29             ; Normalize Numerator
     || NORM    ACC,AR5--
 
        LSL     ACC,1           ; If normalized, bit-31= 0
	SUBB	AR5,#1
LOOP:
        LSL     ACC,1           ; Shift bit into Carry (C)
        MOVL    MD_QUOT,ACC     ; Store shifted intermediate quotient
        MOVL    ACC,MD_REM      ; Load Remainder
        ROL     ACC             ; Shift Carry into bit-0
        MOVL    MD_REM,ACC      ; Store Remainder
        SUBL    ACC,MD_DEN      ; Subtract denominator
        SB      SKIP,LO	        ; Skip if lower (Carry=0)
        MOVL    MD_REM,ACC      ; else, store new Remainder
SKIP:
        MOV     ACC,P           ; Load Quotient (Carry preserved)
        ROL     ACC             ; Shift carry into bit-0
        MOV     P,ACC           ; Store Quotient
        MOVL    ACC,MD_QUOT     ; Reload intermediate quotient
        BANZ    LOOP,AR5--      ; Loop until count = 0
 
        RET                    ; Return to setup routine
	.endasmfunc 

l_div28.inc/    1146129408  0     0     0       5559      `
******************************************************************************
* l_div28.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************


******************************************************************************
* This module contains the functions for 32-bit divide and modulus, signed and
* unsigned.  This stack map and these defines apply to all the routines in 
* this module.               
*
* SYMBOL DEFINITIONS:
*
* DEN   - denominator 
*
******************************************************************************
; Numerator passed in ACC, denominator is on stack
;


******************************************************************************
* SET UP ALIASES FOR STACK REFERENCES AND REGISTERS USED
******************************************************************************
	.asg	*-SP[2],DEN	; denominator 

	.page
******************************************************************************
* 32-bit SIGNED DIVIDE, CALCULATE NUM / DEN AND RETURN IN ACCUMULATOR 
******************************************************************************
	.global	L$$DIV

L$$DIV:		.asmfunc
******************************************************************************
* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	CLRC	OVM		; Clear the OVM bit to get desired effect on 
				; the ABS instruction.
	CLRC	TC		; Clear TC flag, used to store sign
	ABSTC	ACC		; Take absolute value, TC = sign ^ TC
	MOVL	P, ACC		; Load P register with the numerator
	MOVL	ACC, DEN	; Load the denominator
	ABSTC	ACC		; Take absolute value, TC = sign ^ TC
	MOVL	DEN, ACC	; Move |denomiator| to DEN

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	MOVB	ACC, #0		; Clear ACC to perform the division.
	RPT	#31		;
     || SUBCUL	ACC, DEN	; Divide numerator by the denominator; the 
				; quotient is in P and the remainder is in ACC

	MOVL	ACC, @P		; Load the quotient into ACC
	NEGTC	ACC		; Negate ACC if TC = 1

	CLRC	OVM		; Clear the OVM bit 
	FFCRET	*XAR7		; return
	.endasmfunc



	.page
******************************************************************************
* 32-bit SIGNED MODULUS, CALCULATE NUM % DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	L$$MOD

L$$MOD:		.asmfunc
******************************************************************************
* DETERMINE SIGN OF RESULT, TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
        CLRC    OVM             ; Clear the OVM bit to get desired effect on
                                ; the ABS instruction.
        CLRC    TC              ; Clear TC flag, used to store sign
        ABSTC   ACC             ; Take absolute value, TC = sign ^ TC
        MOVL    P, ACC          ; Load P register with the numerator
        MOVL    ACC, DEN        ; Load the denominator
        ABS     ACC             ; Take absolute value, TC = sign ^ TC
        MOVL    DEN, ACC        ; Move |denomiator| to DEN.

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
        MOVB    ACC, #0         ; Clear ACC to perform the division.
        RPT     #31             ;
     || SUBCUL	ACC, DEN	; Divide numerator by the denominator; the 
				; quotient is in P and the remainder is in ACC

        NEGTC   ACC             ; Negate ACC if TC = 1

        CLRC    OVM             ; Clear the OVM bit
	FFCRET	*XAR7		; return
	.endasmfunc



	.page
******************************************************************************
* 32-bit UNSIGNED DIVIDE, CALCULATE NUM / DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	UL$$DIV

UL$$DIV:	.asmfunc
	MOVL	P, ACC		; Load the numerator into P 

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
        MOVB    ACC, #0         ; Clear ACC to perform the division.
        RPT     #31             ;
     || SUBCUL	ACC, DEN	; Divide numerator by the denominator; the 
				; quotient is in P and the remainder is in ACC

	MOVL	ACC, P		; Load the quotient into return register.
	FFCRET	*XAR7		; return
	.endasmfunc

******************************************************************************
* 32-bit UNSIGNED MODULUS, CALCULATE NUM % DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	UL$$MOD

UL$$MOD:	.asmfunc
	MOVL	P, ACC		; Load the numerator into P 

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
        MOVB    ACC, #0         ; Clear ACC to perform the division.
        RPT     #31             ;
     || SUBCUL	ACC, DEN	; Divide numerator by the denominator; the 
				; quotient is in P and the remainder is in ACC

	FFCRET	*XAR7		; return
	.endasmfunc


l_lsl.asm/      1146129408  0     0     0       359       `
******************************************************************************
* l_lsl.asm  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "l_lsl27.inc"
        .endif

l_lsl27.inc/    1146129408  0     0     0       1002      `
******************************************************************************
* l_lsl27.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the routine for 32-bit left shift
*
* Value to be shifted is passed in accumulator
* Shift value is passed in AR4
******************************************************************************

	.global	L$$LSL
******************************************************************************
* 32-BIT LEFT SHIFT
******************************************************************************
L$$LSL:		.asmfunc
	MOV	T,AR4		; move shift arg to T 
	TBIT	T,#4		; see if CNT >= 16
	B	LT16,NTC	; branch if it isn't
	LSL	ACC,16		; shift the first 16
LT16:
	LSL	ACC,T		; finish off shift using value in T

	FFCRET	*XAR7		; return
	.endasmfunc
l_lsr.asm/      1146129408  0     0     0       361       `
******************************************************************************
* l_lsr.asm  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "l_lsr27.inc"
        .endif


l_lsr27.inc/    1146129408  0     0     0       1195      `
******************************************************************************
* l_lsr27.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the routine for signed 32-bit right shift
*
* Value to be shifted is passed in accumulator.
* Shift value is passed in AR4.
*
* No stack memory used.
******************************************************************************

******************************************************************************
* 32-BIT SIGNED RIGHT SHIFT
******************************************************************************
	.global	L$$LSR

L$$LSR:		.asmfunc
        MOV     T,AR4           ; move shift arg to T 
	SETC	SXM		; turn on sign extension mode
        TBIT    T,#4             ; see if CNT >= 16
        B       LT16,NTC        ; branch if it isn't
        SFR     ACC,16          ; shift the first 16
LT16:
        SFR     ACC,T           ; finish off shift using value in T
 
	FFCRET	*XAR7		; return
	.endasmfunc


l_mpy.asm/      1146129408  0     0     0       359       `
******************************************************************************
* l_mpy.asm  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "l_mpy27.inc"
        .endif

l_mpy27.inc/    1146129408  0     0     0       3126      `
******************************************************************************
* l_mpy27.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the routine for 32-bit multiply
*
* SYMBOL DEFINITIONS:
*
* I,J - operands of the multiply
* xHI - High word of that object
* xLO - Low word of that object
*
******************************************************************************

;	STACK MAP
;
;	+-----------+	
;	|           |  0  <-- SP (on entry)
;	+-----------+	
;	| ret addr  | -1
;	+-----------+
;	| ret addr  | -2
;	+-----------+
;	|    JHI    | -3
;	+-----------+
;	|    JLO    | -4
;	+-----------+
;	|           |
;
; On entry, operand I is in accumulator 


******************************************************************************
* Set up aliases for stack, register references
******************************************************************************
	.asg	AH,IHI     	; high half of operand I
	.asg	AR6,ILO		; low half of operand I
	.asg	*-SP[1],JHI     ; high half of operand J
	.asg	*-SP[2],JLO     ; low half of operand J

	.page
******************************************************************************
* 16-BIT MULTIPLY, CALCULATE I * J AND RETURN IN ACCUMULATOR "A"
******************************************************************************
	.global	L$$MPY

L$$MPY:		.asmfunc
******************************************************************************
* SET UP 
******************************************************************************
	MOV	ILO,AL		; write out operand I

******************************************************************************
* A 32X32 MULTIPLY WITH A 64-BIT RESULT WOULD BE CALCULATED:
*
*                IHI ILO
*             X  JHI JLO
*             ----------
*             ILO * JLO
*       JLO * IHI
*       ILO * JHI
* IHI * JHI
* ----------------------
*     64-bit result
*
* BUT WE NEED ONLY THE LOWER 32-BITS OF THIS CALCULATION.  THEREFORE THE
* IHI * JHI CALCULATION ISN'T DONE AT ALL AND THE UPPER HALF OF THE JLO * IHI
* AND ILO * JHI CALCULATIONS IS THROWN AWAY.  ALSO, THE ILO * JLO MULTIPLY
* MUST BE UNSIGNED, BUT THE SIGNNESS OF THE OTHER MULTIPLIES DOESN'T MATTER
* SINCE THE DIFFERENCE ALWAYS APPEARS IN THE UPPER 16-BITS.
******************************************************************************
	MOV	T,JLO		; T = JLO
	MPY	ACC,T,IHI	; ACC = JLO * IHI
	MOV	T,ILO		; T = ILO
	MPY	P,T,JHI		; P = ILO * JHI
	ADD	ACC,P		; ACC += ILO * JHI
	MPYU	P,T,JLO		; P = ILO  * JLO
	MOV	ACC,AL << 16 	; ACC = ((JLO * IHI) + (ILO * JHI)) << 16
	ADD	ACC,P		; ACC = (((JLO * IHI) + (ILO * JHI)) << 16) +
	                        ;        (ILO * JLO)

******************************************************************************
* RETURN
******************************************************************************
	FFCRET	*XAR7		; return
	.endasmfunc
l_tofd.asm/     1146129408  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  L_TOFD v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  L$$TOFD - Convert a signed 32 bit integer into an IEEE 754 format double  *
*;            precision floating point number                                 *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "l_tofd28.inc"
        .endif

l_tofd28.inc/   1146129408  0     0     0       6947      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  L_TOFD v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  L$$TOFD  - Convert a signed 32 bit integer into an IEEE 754 format double *
;*             precision floating point number    			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN ACC  
;*   o RESULT IS RETURNED IN *XAR6
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                             						      *
;*                              		    register file	      *
;*                                                +-------------------+       *
;*                                           AR4  |        | RES_EXP  |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | RES_SIGN |       *
;*                                                +-------------------+       *
;*                                          XAR6  | PTR TO RET VALUE  |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   L$$TOFD
        .sect     ".text"

L$$TOFD		.asmfunc
        .asg      XAR4,    XRES_EXP
        .asg       AR4,    RES_EXP
        .asg       AR5,    RES_SIGN
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
        MOVL    P, ACC            ; Save input float
        MOVL    ACC, XAR6         ;
        B       RETURN, EQ        ; Return if return pointer is null
*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Save the sign of the input                                            *
*;    3 Get the absolute value of input                                       *
*;    4 Normalize the value and adjust the exponent                           *
*;*****************************************************************************
*
        MOVL    ACC, P          ; Restore input in ACC
	B	OP_ZERO, EQ	; Return zero if ACC is zero

	MOV	RES_SIGN, AH	; Save the sign

	MOVL	XRES_EXP, #0x41D; Normalize the value and adjust the exponent
	B	$10, GEQ	; 
        SB      1, OV           ; Clear V (overflow)                        
	CLRC	OVM		; Clear OVM to get desired result in NEG.
	NEG	ACC		; Take absolute value of input
	B	$10, NOV	; 
	INC	RES_EXP		; Negate overflows when input is 0x8000:0
				; Account for the overflow by incrementing exp.
$10:
	RPT	#31		;
     || NORM	ACC, XRES_EXP--	;
	
*
*;*****************************************************************************
*;     Pack the sign, mantissa and exponent into Double precision format      *
*;*****************************************************************************
*
	MOV 	P, #0 		; Zero out P

        LSR64   ACC:P, #14      ; Move the mantissa out of AH. Since only 32 
                                ; bits of the mantissa are significant this 
                                ; is not a problem
        MOV     AH, RES_EXP     ; Load exponent and remove implied one 
        LSL64   ACC:P, #4       ; Shift back mantissa and exponent

	AND	RES_SIGN, #0x8000 ; Mask the sign bit
	OR	AH, RES_SIGN	; Set the sign bit
*
RETURN_VALUE:
        MOVL    RES_LSW, P      ;
        MOVL    RES_MSW, ACC    ; Load the return value in the return area.

RETURN:
        LRETR
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
OP_ZERO:
        ZAPA	                  ; For underflow result in ACC:P = 0
        B       RETURN_VALUE,UNC
	.endasmfunc

l_tofs.asm/     1146129408  0     0     0       694       `
*;*****************************************************************************
*;                                                                            *
*;  L$$TOFS - convert a 32-bit signed integer to a floating point value       *
*;  L_TOFS - v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "l_tofs27.inc"
        .elseif .TMS320C2800
                .include "l_tofs28.inc"
        .endif
l_tofs27.inc/   1146129408  0     0     0       9878      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  L$$TOFS - convert a 32-bit signed integer to a floating point value       *
*;  L_TOFS - v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       L$$TOFS                                             reigster file    *
*;                                                         +----------------+ *
*;       This routine converts a 32-bit signed         AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in ACC.             AR5 |sign of integer | *
*;       When the conversion is complete                   +----------------+ *
*;       the float value will be in ACC.                                      *
*;                                                                            *
*;       inputs:  A (long value) in ACC                                       *
*;                                                                            *
*;       implementation:  The absolute value of the                           *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            back into ACC.                                                  *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;       NOTE : POSSIBLE LOSS OF PRECISION SINCE 32-BIT FLOAT HAS ONLY        *
*;              24 BITS OF PRECISION                                          *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   L$$TOFS

L$$TOFS		.asmfunc
	 .asg	AR4, EXPONENT
	 .asg   AR5, SIGN
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the three cases it belongs.   *
*;    Case 1:  value is 08000h; requires special processing                   *
*;    Case 2:  value is 0; requires special processing                        *
*;    Case 3:  all other values                                               *
*;*****************************************************************************
*
        TEST    ACC
        B       ZERO, EQ        ; branch if integer == 0
        MOV     SIGN, AH        ; save the sign of the integer
        SB      1, OV           ; reset V so ABS gives correct results
        ABS     ACC
        B       OVERFLOW, OV    ; branch if integer == 80000000h;
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (1Eh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOV     EXPONENT, #09Dh ; set exponent count to 1EH (offset binary)

	RPT	#31
     || NORM    ACC, EXPONENT-- ; normalize ACC to get mantissa value and
                                ; find actual exponent value
* 
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Shift mantissa   [0000 0000 0MMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0EEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;*****************************************************************************
*
        AND     AH, #03FFFh         ; remove implied one and sign bit
        CLRC    SXM
        SFR     ACC, 7              ; shift mantissa to make room for exponent
        MOV     PH, AH              ; save AH
        MOV     AH, EXPONENT
        LSL     AH, 7               ; adjust exponent
        OR      AH, PH              ; restore AH with exponent
        TBIT    SIGN, #15           ; check sign
        B       RETURN, NTC         ; if positive, return
        OR      AH, #08000h         ; make negative
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        RET
*
*;*****************************************************************************
*;       SPECIAL CASE PROCESSING                                              *
*;  Load default for 08000h (floating point equivalent = CF00 0000)           *
*;*****************************************************************************
*
OVERFLOW
        MOV     AL, #0
        MOV     AH, #0CF00h
        RET
	.endasmfunc

l_tofs28.inc/   1146129408  0     0     0       9916      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  I$$TOFS - convert a 32-bit signed integer to a floating point value       *
*;  I_TOFS - v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       L$$TOFS                                             reigster file    *
*;                                                         +----------------+ *
*;       This routine converts a 32-bit signed         AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in ACC.             AR5 |sign of integer | *
*;       When the conversion is complete                   +----------------+ *
*;       the float value will be in ACC.                                      *
*;                                                                            *
*;       inputs:  A (long value) in ACC                                       *
*;                                                                            *
*;       implementation:  The absolute value of the                           *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            back into ACC.                                                  *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;       NOTE : POSSIBLE LOSS OF PRECISION SINCE 32-BIT FLOAT HAS ONLY        *
*;              24 BITS OF PRECISION                                          *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   L$$TOFS

L$$TOFS		.asmfunc
	 .asg	AR4, EXPONENT
	 .asg	XAR4, XEXPONENT
	 .asg   AR5, SIGN
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the three cases it belongs.   *
*;    Case 1:  value is 08000h; requires special processing                   *
*;    Case 2:  value is 0; requires special processing                        *
*;    Case 3:  all other values                                               *
*;*****************************************************************************
*
        TEST    ACC
        B       ZERO, EQ        ; branch if integer == 0
        MOVZ    SIGN, AH        ; save the sign of the integer
        SB      1, OV           ; reset V so ABS gives correct results
        ABS     ACC
        B       OVERFLOW, OV    ; branch if integer == 80000000h;
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (1Eh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOVB    XEXPONENT, #09Dh ; set exponent count to 1EH (offset binary)

        RPT	#31
     || NORM    ACC, XEXPONENT-- ; normalize ACC to get mantissa value and
                                 ; find actual exponent value
* 
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Shift mantissa   [0000 0000 0MMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0EEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;*****************************************************************************
*
        AND     AH, #03FFFh         ; remove implied one and sign bit
        CLRC    SXM
        SFR     ACC, 7              ; shift mantissa to make room for exponent
        MOV     PH, AH              ; save AH
        MOV     AH, EXPONENT
        LSL     AH, 7               ; adjust exponent
        OR      AH, PH              ; restore AH with exponent
        TBIT    SIGN, #15           ; check sign
        B       RETURN, NTC         ; if positive, return
        OR      AH, #08000h         ; make negative
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        LRETR
*
*;*****************************************************************************
*;       SPECIAL CASE PROCESSING                                              *
*;  Load default for 08000h (floating point equivalent = CF00 0000)           *
*;*****************************************************************************
*
OVERFLOW
        MOV     AL, #0
        MOV     AH, #0CF00h
        LRETR
	.endasmfunc

ldexp.c/        1146129408  0     0     0       1075      `
/****************************************************************************/
/*  ldexp  v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <errno.h>

double ldexp(double x, int exp)
{
     int *ptr = (int *)&x;
     long texp = (long) exp + ((ptr[1] >> 7) & 0xFF);
 
     /***********************************************************************/
     /* IF RESULT UNDERFLOWS, RETURN 0.0.  IF RESULT OVERFLOWS, RETURN      */
     /* +- INFINITY.                                                        */
     /***********************************************************************/
     if      (texp < 1)      
       x = 0.0; 
     else if (texp > 0xFE) 
     { 
       errno = ERANGE;
       x = (x < 0) ? -HUGE_VAL : HUGE_VAL;
     }
     else                   
       ptr[1] = (ptr[1] & 0x807F) | ((int)texp << 7);
   
     return x;
}

limits.h/       1146129408  0     0     0       2081      `
/*****************************************************************************/
/* limits.h   v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _LIMITS
#define _LIMITS

#define CHAR_BIT                16    /* NUMBER OF BITS IN TYPE CHAR  */
#define SCHAR_MAX            32767    /* MAX VALUE FOR SIGNED CHAR    */
#define SCHAR_MIN   (-SCHAR_MAX-1)    /* MIN VALUE FOR SIGNED CHAR    */
#define UCHAR_MAX           65535u    /* MAX VALUE FOR UNSIGNED CHAR  */
#define CHAR_MIN         SCHAR_MIN    /* MIN VALUE FOR CHAR           */
#define CHAR_MAX         SCHAR_MAX    /* MAX VALUE FOR CHAR           */
#define MB_LEN_MAX               1
 
#define SHRT_MAX             32767    /* MAX VALUE FOR SHORT          */
#define SHRT_MIN     (-SHRT_MAX-1)    /* MIN VALUE FOR SHORT          */
#define USHRT_MAX           65535u    /* MAX VALUE FOR UNSIGNED SHORT */
 
#define INT_MAX              32767    /* MAX VALUE FOR INT            */
#define INT_MIN       (-INT_MAX-1)    /* MIN VALUE FOR INT            */
#define UINT_MAX            65535u    /* MAX VALUE FOR UNSIGNED INT   */
 
#define LONG_MAX        2147483647    /* MAX VALUE FOR LONG           */
#define LONG_MIN     (-LONG_MAX-1)    /* MIN VALUE FOR LONG           */
#define ULONG_MAX       4294967295    /* MAX VALUE FOR UNSIGNED LONG  */

#if defined(__TMS320C28X__)

#define LLONG_MAX    9223372036854775807 /* MAX VALUE FOR LONG LONG          */
#define LLONG_MIN         (-LLONG_MAX-1) /* MIN VALUE FOR LONG LONG          */
#define ULLONG_MAX  18446744073709551615 /* MAX VALUE FOR UNSIGNED LONG LONG */

#else

#define LLONG_MAX              LONG_MAX  /* MAX VALUE FOR LONG LONG          */
#define LLONG_MIN              LONG_MIN  /* MIN VALUE FOR LONG LONG          */
#define ULLONG_MAX             ULONG_MAX /* MAX VALUE FOR UNSIGNED LONG LONG */

#endif

#endif /* _LIMITS */

linkage.h/      1146129408  0     0     0       1786      `
/*****************************************************************************/
/* linkage.h   v4.1.3                                                         */
/* Copyright (c) 1998-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _LINKAGE
#define _LINKAGE

/* No modifiers needed to access code */

#define _CODE_ACCESS

/*--------------------------------------------------------------------------*/
/* Define _DATA_ACCESS ==> how to access RTS global or static data          */
/*--------------------------------------------------------------------------*/
#ifndef _FAR_RTS
#define _DATA_ACCESS
#else
#define _DATA_ACCESS far
#endif

/*--------------------------------------------------------------------------*/
/* Define _OPTIMIZE_FOR_SPACE ==> Always optimize for space.                */
/*--------------------------------------------------------------------------*/
#ifndef _OPTIMIZE_FOR_SPACE
#define _OPTIMIZE_FOR_SPACE 1
#endif

/*--------------------------------------------------------------------------*/
/* Define LARGE_MODEL ==> used with large memory model switch               */
/*--------------------------------------------------------------------------*/
#ifndef LARGE_MODEL
#define LARGE_MODEL  0
#endif

/*--------------------------------------------------------------------------*/
/* Define _IDECL ==> how inline functions are declared                      */
/*--------------------------------------------------------------------------*/
#ifdef _INLINE
#define _IDECL static __inline
#define _IDEFN static __inline
#else
#define _IDECL extern _CODE_ACCESS
#define _IDEFN _CODE_ACCESS
#endif

#endif /* _LINKAGE */
ll_abs.asm/     1146129408  0     0     0       361       `
******************************************************************************
* ll_abs.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ll_abs28.inc"
        .endif

ll_abs28.inc/   1146129408  0     0     0       1341      `
******************************************************************************
* ll_abs28.inc  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the routine that returns 64-bit absolute value.
******************************************************************************

******************************************************************************
* Set up aliases for stack, register references
******************************************************************************

	.page
******************************************************************************
* LOGIC FOR 64-BIT ABS.
*                        
* if (i < 0) return -i;
* else       return i;
*                        
******************************************************************************
	.global	LL$$ABS

LL$$ABS:	.asmfunc
	CMP64   ACC:P		; Clear V flag.
	CMP64   ACC:P		; Test ACC:P
	B	$5,GEQ		;
	NEG64	ACC:P		;
$5:

******************************************************************************
* RETURN
******************************************************************************
	FFCRET	*XAR7		; return
	.endasmfunc


ll_aox.asm/     1146129408  0     0     0       361       `
******************************************************************************
* ll_aox.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ll_aox28.inc"
        .endif

ll_aox28.inc/   1146129408  0     0     0       1202      `
******************************************************************************
* ll_aox28.inc  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains 64-bit bitwise AND, OR and XOR routines.              
******************************************************************************

	.page

	.global	LL$$AND
	.global	LL$$OR
	.global	LL$$XOR

        .asg   *-SP[1],    HI_MSB
        .asg   *-SP[2],    HI_LSB
        .asg   *-SP[3],    LO_MSB
        .asg   *-SP[4],    LO_LSB


LL$$AND:	.asmfunc
	AND	HI_MSB, AH
	AND	HI_LSB, AL
	MOVL	ACC,LO_LSB
	AND	AH,PH
	AND	AL,PL
	MOVL	P,ACC
	MOVL	ACC,HI_LSB

	FFCRET	*XAR7		; return
	.endasmfunc

LL$$OR:		.asmfunc
	OR	HI_MSB, AH
	OR	HI_LSB, AL
	MOVL	ACC,LO_LSB
	OR	AH,PH
	OR	AL,PL
	MOVL	P,ACC
	MOVL	ACC,HI_LSB

	FFCRET	*XAR7		; return
	.endasmfunc

LL$$XOR:	.asmfunc
	XOR	HI_MSB, AH
	XOR	HI_LSB, AL
	MOVL	ACC,LO_LSB
	XOR	AH,PH
	XOR	AL,PL
	MOVL	P,ACC
	MOVL	ACC,HI_LSB

	FFCRET	*XAR7		; return
	.endasmfunc

ll_cmp.asm/     1146129408  0     0     0       361       `
******************************************************************************
* ll_cmp.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ll_cmp28.inc"
        .endif

ll_cmp28.inc/   1146129409  0     0     0       2505      `
******************************************************************************
* ll_cmp28.inc  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains signed and unsigned 64-bit compares.           
*
* SYMBOL DEFINITIONS:
*
* I,J - Input 1 and 2 that needs to be compared.
* AL  - Return value
*     OP1 > OP2  : return 1
*     OP1 < OP2  : return -1
*     OP1 == OP2 : return 0
* xHI - High 32bits of that object
* xLO - Low 32bits of that object
*
******************************************************************************

******************************************************************************
* Set up aliases for stack, register references
******************************************************************************
	.asg   *-SP[2],  JHI
	.asg   *-SP[4],  JLO

	.page
******************************************************************************
* Signed Compare (LL$CMP):
* if IHI is equal to JHI
*    return 0 if ILO is equal to JLO
*    return 1 if ILO is higher than JLO (unsigned compare)
*    return -1 if ILO is lower than JLO (unsigned compare)
* else
*    return 0 if IHI is equal to JHI
*    return 1 if IHI is greater than JHI (signed compare)
*    return -1 if IHI is less than JHI (signed compare)
*    
* Unsigned Compare (ULL$CMP):
* if IHI is equal to JHI
*    return 0 if ILO is equal to JLO
*    return 1 if ILO is higher than JLO (unsigned compare)
*    return -1 if ILO is lower than JLO (unsigned compare)
* else
*    return 0 if IHI is equal to JHI
*    return 1 if IHI is higher than JHI (unsigned compare)
*    return -1 if IHI is lower than JHI (unsigned compare)
*    
*                        
******************************************************************************
	.global	LL$$CMP

LL$$CMP:	.asmfunc
	MOV	T,#-1		;
	CMPL	ACC,JHI		; 
	B	$5,NEQ	;

	MOVL	ACC,P  		; 
	CMPL	ACC,JLO		;
	MOVB	T,#0,EQ		; 
	MOVB	T,#1,HI		;
	MOV 	AL,T     	;

	FFCRET	*XAR7		; Return
$5:
	MOVB	T,#0,EQ		;
	MOVB	T,#1,GT		;
	MOV 	AL,T     	;

	FFCRET	*XAR7		; Return
	.endasmfunc

	.global	ULL$$CMP

ULL$$CMP:	.asmfunc
	MOV	T,#-1		;
	CMPL	ACC,JHI		; 
	B	$10,NEQ	;
	MOVL	ACC,P		;
	CMPL	ACC,JLO		;
$10:
	MOVB	T,#0,EQ		;
	MOVB	T,#1,HI		;
	MOV 	AL,T     	;

	FFCRET	*XAR7		; Return
	.endasmfunc


ll_div.asm/     1146129409  0     0     0       361       `
******************************************************************************
* ll_div.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ll_div28.inc"
        .endif

ll_div28.inc/   1146129409  0     0     0       19078     `
******************************************************************************
* ll_div28.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************


******************************************************************************
* This module contains the functions for 64-bit divide and modulus, signed and
* unsigned.  This stack map and these defines apply to all the routines in 
* this module.               
*
* SYMBOL DEFINITIONS:
*
* QUOT  - Intermediate Quotient
* Q     - Quotient
* DEN   - denominator 
* REM   - remainder
* xHI   - High word of that object
* xLO   - Low word of that object
* CNT   - Iteration count of divide routine
* SIGN  - Sign of result
*
******************************************************************************

;	STACK MAP
;
;	+-----------+	
;	|           |    <-- SP (during MAINDIV routine)
;	+-----------+
;	| ret addr  |  0 <-- SP (after frame allocation)
;	+-----------+	
;	|   Q_HI    | -2
;	+-----------+	
;	|   Q_LO    | -4
;	+-----------+	
;	|  REM_HI   | -6
;	+-----------+
;	|  REM_LO   | -8
;	+-----------+
;	| LDEN_HI   | -10
;	+-----------+
;	| LDEN_LO   | -12 <-- SP (on entry)
;	+-----------+	
;	| ret addr  |
;	+-----------+
;	|  DEN_HI   | -16  
;	+-----------+
;	|  DEN_LO   | -18  
;	+-----------+
;	|           |
;
; Numerator passed in ACC:P, denominator is on stack


FSIZE	.set	12		; frame size

******************************************************************************
* SET UP ALIASES FOR STACK REFERENCES AND REGISTERS USED
******************************************************************************
        .asg   *-SP[FSIZE+3],  DEN_MSB
        .asg   *-SP[FSIZE+4],  DEN_HI 
        .asg   *-SP[FSIZE+6],  DEN_LO  


	.asg	AR0,CNT		; iteration counter
	.asg	XAR0,XCNT	; iteration counter
	.asg	AR7,SIGN	; sign of result

	.asg	*-SP[2],   	Q_HI
	.asg	*-SP[4],   	Q_LO
	.asg	*-SP[5],   	REM_MSB
	.asg	*-SP[6],   	REM_HI
	.asg	*-SP[8],   	REM_LO
	.asg	*-SP[10],  	LDEN_HI
	.asg	*-SP[12],  	LDEN_LO

        .asg    XAR4,      	RES_HI  
        .asg    XAR5,      	RES_LO   

	.asg	*-SP[2 +2],   	MD_Q_HI
	.asg	*-SP[4 +2],   	MD_Q_LO
	.asg	*-SP[5 +2],   	MD_REM_MSB
	.asg	*-SP[6 +2],   	MD_REM_HI
	.asg	*-SP[8 +2],   	MD_REM_LO
	.asg	*-SP[10+2],   	MD_LDEN_HI
	.asg	*-SP[12+2],   	MD_LDEN_LO

        .asg    XAR4,   	QUOT_HI  
        .asg    XAR5,   	QUOT_LO   

        .asg    XAR4,         	LNUM_HI  
        .asg    XAR5,         	LNUM_LO   

        .asg    AR5,            TMP16  
        .asg    XAR5,           TMP32  

	.page
******************************************************************************
* 32-bit SIGNED DIVIDE, CALCULATE NUM / DEN AND RETURN IN ACCUMULATOR 
******************************************************************************
	.global	LL$$DIV
	.include "fd_util28.inc"

LL$$DIV:	.asmfunc
******************************************************************************
* ALLOCATE FRAME, THE COMPILER WILL DO ANY NECESSARY SAVING OF REGISTERS
* USED AT THE CALL SITE
******************************************************************************
	MOVB	TMP32,#0
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32

******************************************************************************
* DETERMINE SIGN OF RESULT
******************************************************************************
	MOVZ	SIGN, DEN_MSB   ;
	XOR	SIGN, AH  	; determine sign of result
	CLRC	OVM		; Clear OVM to get desired effect on NEG64.

******************************************************************************
* TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	CMP64   ACC:P		; Clear V flag
	CMP64   ACC:P		; Test contents of ACC:P
	B	$10, GEQ	;
	NEG64	ACC:P		; take absolute value of numerator
$10:
	MOVL    LNUM_HI,ACC     ; save off |numerator|
	MOVL    LNUM_LO,P       ; 
	
	MOVL	P,DEN_LO	; load denominator
	MOVL	ACC,DEN_HI	; load denominator
	B	$5, GEQ	;
	NEG64	ACC:P		;
$5:
	MOVL    LDEN_HI,ACC     ; save off |denominator|
	MOVL    LDEN_LO,P       ; 

******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	CMPL	ACC,LNUM_HI	;
	B	$15,NEQ		;
	MOVL	ACC,P		;
	CMPL	ACC,LNUM_LO	; compare denominator to numerator
$15:
	B	EQ1,EQ		; branch if equal (return 1)
	B	EQ0,HI		; branch if denominator > numerator (return 0)
	MOVL	ACC,LDEN_HI	;
        SB      SDIVUDenHighZero,EQ

******************************************************************************
* CALL MAIN DIVIDE ROUTINE
******************************************************************************
	MOVL	P,LNUM_LO	;
	MOVL	ACC,LNUM_HI	;
	LCR	MAINDIV		; call main divide routine
	MOVL	ACC, Q_HI	;
	MOVL	P, Q_LO		; load the result into ACC:P


******************************************************************************
* QUOTIENT IS IN ACC
******************************************************************************
CHECK_SIGN1:
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET1,NTC	; return quotient as is if positive, otherwise
	NEG64	ACC:P		; negate quotient
RET1:
	SUBB	SP,#FSIZE	; deallocate frame
	LRETR			; return

******************************************************************************
* DENOMINATOR == NUMERATOR RETURN 1 (OR -1)
******************************************************************************
EQ1:
	MOV	PL,#1		;
	MOV	PH,#0		;
	MOVB	ACC,#0		; tentatively set quotient to 1
	B	CHECK_SIGN1,UNC	; check sign and return

******************************************************************************
* IF DENOMINATOR > NUMERATOR, RETURN 0
******************************************************************************
EQ0:
	ZAPA        		; set quotient to zero
	B	RET1,UNC	; return


******************************************************************************
* FOLLOWING PIECE OF CODE IS FAST OUT IF UPPER WORD OF DENOMINATOR IS ZERO
******************************************************************************
SDIVUDenHighZero:
	MOVB	ACC,#0
	MOVL	P, LNUM_HI
	RPT	#31
      ||SUBCUL  ACC, LDEN_LO
        MOVL    RES_HI, P
        MOVL    P, LNUM_LO
	RPT	#31
      ||SUBCUL  ACC, LDEN_LO
	MOVL	ACC,RES_HI 
        B       CHECK_SIGN1, UNC
	.endasmfunc


	.page
******************************************************************************
* 32-bit SIGNED MODULUS, CALCULATE NUM % DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	LL$$MOD

LL$$MOD:	.asmfunc
******************************************************************************
* ALLOCATE FRAME
******************************************************************************
	MOVB	TMP32,#0
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32

******************************************************************************
* DETERMINE SIGN OF RESULT
******************************************************************************
	MOVZ	SIGN,AH         ; sign of result is sign of numerator
	CLRC	OVM		; Clear OVM to get desired effect on NEG64.

******************************************************************************
* TAKE ABSOLUTE VALUE OF OPERANDS
******************************************************************************
	CMP64   ACC:P		; Clear V flag
	CMP64   ACC:P		; Test contents of ACC:P
	B	$25, GEQ	;
	NEG64	ACC:P		; take absolute value of numerator
$25:
	MOVL    LNUM_HI,ACC     ; save off |numerator|
	MOVL    LNUM_LO,P       ; 
	
	MOVL	P,DEN_LO	; load denominator
	MOVL	ACC,DEN_HI	; load denominator
	B	$20, GEQ	;
	NEG64	ACC:P		;
$20:
	MOVL    LDEN_HI,ACC     ; save off |denominator|
	MOVL    LDEN_LO,P       ; 

******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	CMPL	ACC,LNUM_HI	;
	B	$30,NEQ		;
	MOVL	ACC,P		;
	CMPL	ACC,LNUM_LO	; compare denominator to numerator
$30
	B	EQ2,EQ		; branch if equal (return 0)
	B	RET_NUM1,HI     ; if (denominator > numerator) return numerator
        MOVL	ACC, LDEN_HI     ; check if upper word of denominator is zero
        SB      SMODUDenHighZero,EQ

******************************************************************************
* CALL MAIN DIVIDE ROUTINE, MAINDIV RETURNS QUOTIENT IN ACC
******************************************************************************
	MOVL	P,LNUM_LO	;
	MOVL	ACC,LNUM_HI	;
	LCR	MAINDIV		; call main divide routine
	MOVL	ACC,REM_HI	; reload remainder
	MOVL	P,REM_LO	; reload remainder

******************************************************************************
* NEGATE SIGN OF REMAINDER IF NECESSARY
******************************************************************************
CHECK_SIGN2:
	TBIT	SIGN,#15	; check MSB(sign)
	B	RET2, NTC	; if(positive) branch to return
	NEG64	ACC:P		; otherwise, negate remainder

RET2:
	SUBB	SP,#FSIZE	; deallocate frame
	LRETR			; return

RET_NUM1:
	MOVL	ACC, LNUM_HI	;
	MOVL	P, LNUM_LO	;
	B	CHECK_SIGN2,UNC	;
******************************************************************************
* NUM AND DEN ARE EQUAL, RETURN 0
******************************************************************************
EQ2:
	ZAPA       		; load return register with 0
	SUBB	SP,#FSIZE	; deallocate frame
	LRETR     		; return


******************************************************************************
* FOLLOWING PIECE OF CODE IS FAST OUT IF UPPER WORD OF DENOMINATOR IS ZERO.
* THE RESULT (REMAINDER) IS IN ACC:P UPON RETURN.
******************************************************************************
SMODUDenHighZero:
	MOVB	ACC,#0
	MOVL	P, LNUM_HI
	RPT	#31
      ||SUBCUL  ACC, LDEN_LO
        MOVL    P, LNUM_LO
	RPT	#31
      ||SUBCUL  ACC, LDEN_LO
        MOVL    P, ACC
        MOVB    ACC, #0
        B       CHECK_SIGN2, UNC
	.endasmfunc

	.page
******************************************************************************
* 32-bit UNSIGNED DIVIDE, CALCULATE NUM / DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	ULL$$DIV

ULL$$DIV:	.asmfunc
******************************************************************************
* ALLOCATE FRAME
******************************************************************************
	MOVB	TMP32,#0
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32

******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	MOVL	LNUM_HI, ACC    ; Save off NUM_HI
	MOVL	LNUM_LO, P      ; Save off NUM_LO
	CMPL	ACC,DEN_HI	;
	B	$35,NEQ		;
	MOVL	ACC,P		;
	CMPL	ACC,DEN_LO	; compare denominator to numerator
$35
	B	EQ3,EQ		; branch if equal (return 1)
	B	DGT3,LO  	; branch if denominator > numerator (return 0) 

	MOVL	ACC,DEN_HI	;
        SB      DIVUDenHighZero,EQ

******************************************************************************
* CALL MAIN DIVIDE ROUTINE
******************************************************************************
	MOVL	ACC, DEN_HI	; Move the denomiator to local variable 
	MOVL	LDEN_HI, ACC	; that MAINDIV accesses
	MOVL	ACC, DEN_LO	;
	MOVL	LDEN_LO, ACC	;

	MOVL	ACC,LNUM_HI	; Load numerator to ACC:P to pass to MAINDIV
	LCR	MAINDIV		; call main divide routine
	MOVL	ACC,Q_HI        ; load result into ACC:P
	MOVL	P,Q_LO          ; 

******************************************************************************
* QUOTIENT IS IN ACC
******************************************************************************
RET3:
	SUBB	SP,#FSIZE	; deallocate frame
	LRETR    		; return

******************************************************************************
* NUM AND DWN ARE EQUAL, RETURN 1
******************************************************************************
EQ3:
	MOV	PL,#1		;
	MOV	PH,#0		;
	MOVB	ACC,#0		; quotient = 1
	B	RET3,UNC	; return

******************************************************************************
* IF DEN > NUM, RETURN 0
******************************************************************************
DGT3:
	ZAPA        		; set quotient to zero
	B	RET3,UNC	; return

******************************************************************************
* FOLLOWING PIECE OF CODE IS FAST OUT IF UPPER WORD OF DENOMINATOR IS ZERO
* THE RESULT (QUOTIENT) IS IN ACC:P UPON RETURN.
******************************************************************************
DIVUDenHighZero:
	MOVB	ACC,#0
	MOVL	P, LNUM_HI
	RPT	#31
      ||SUBCUL  ACC, DEN_LO
        MOVL    RES_HI, P
        MOVL    P, LNUM_LO
	RPT	#31
      ||SUBCUL  ACC, DEN_LO
	MOVL	ACC, RES_HI
        B       RET3, UNC
	.endasmfunc



	.page
******************************************************************************
* 32-bit UNSIGNED MODULUS, CALCULATE NUM % DEN AND RETURN IN ACCUMULATOR
******************************************************************************
	.global	ULL$$MOD

ULL$$MOD:	.asmfunc
******************************************************************************
* ALLOCATE FRAME
******************************************************************************
	MOVB	TMP32,#0
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32
	PUSH	TMP32

******************************************************************************
* LOOK FOR EASY OUTS
******************************************************************************
	MOVL	LNUM_HI, ACC    ; save off NUM_HI
	MOVL	LNUM_LO, P      ; save off NUM_LO
	CMPL	ACC,DEN_HI	;
	B	$40,NEQ		;
	MOVL	ACC,P		;
	CMPL	ACC,DEN_LO	; compare denominator to numerator
$40
	B	EQ4,EQ		; branch if equal (return 0)
	B	RET_NUM2,LO     ; if (denominator > numerator) return numerator
        MOVL	ACC, DEN_HI     ; check if upper word of denominator is zero
        SB      MODUDenHighZero,EQ

******************************************************************************
* CALL MAIN DIVIDE ROUTINE, MOVE REMAINDER INTO ACC
******************************************************************************
	MOVL	ACC, DEN_HI	; Move the denomiator to local variable 
	MOVL	LDEN_HI, ACC	; that MAINDIV accesses
	MOVL	ACC, DEN_LO	;
	MOVL	LDEN_LO, ACC	;

	MOVL	ACC,LNUM_HI	; Load numerator to ACC:P to pass to MAINDIV
	LCR	MAINDIV		; call main divide routine
	MOVL	ACC,REM_HI	; load remainder into ACC:P
	MOVL	P,REM_LO	; 

******************************************************************************
* RETURN SEQUENCE
******************************************************************************
RET4:
	SUBB	SP,#FSIZE	; deallocate frame
	LRETR	  		; return

RET_NUM2:
	MOVL	ACC,LNUM_HI	;
	B	RET4, UNC	;
******************************************************************************
* NUM AND DEN ARE EQUAL, RETURN 0
******************************************************************************
EQ4:
	ZAPA       	 	; load return ACC:P with 0
	B	RET4,UNC	; return

******************************************************************************
* FOLLOWING PIECE OF CODE IS FAST OUT IF UPPER WORD OF DENOMINATOR IS ZERO.
* THE RESULT (REMAINDER) IS IN ACC:P UPON RETURN.
******************************************************************************
MODUDenHighZero:
	MOVB	ACC,#0
	MOVL	P, LNUM_HI
	RPT	#31
      ||SUBCUL  ACC, DEN_LO
        MOVL    P, LNUM_LO
	RPT	#31
      ||SUBCUL  ACC, DEN_LO
        MOVL	P,ACC
	MOVB	ACC,#0
        B       RET4, UNC
	.endasmfunc

	.page
******************************************************************************
* MAIN DIVIDE ROUTINE
* ASSUMES NUM AND DEN ARE UNSIGNED AND NUM != 0.  IF DEN == 0, THEN THIS 
* ROUTINE WILL TAKE A LONG TIME ...
******************************************************************************
*
* This routine is based on the following psuedo-code
*
*    count = 63;
*
*    while (q <<= 1 shifts 0 into carry)
*      count--;
* 
*    /* just shifted 1 into carry */
*    r = 1; *
*    for(;;)
*    {
*      if (r >= d)
*      {
*	 r -= d;
*	 q |= 1;
*      }
*
*      if (count-- == 0) return;
*
*      r <<= 1;
*      if (MSB(q) == 1) r |= 1;
*      q <<= 1;
*    }


******************************************************************************
* INPUT : NUMERATOR IN ACC:P. DENOMINATOR IN MD_LDEN_HI:MD_LDEN_LO
*         MD_REM_HI:MD_REM_LO and MD_Q_HI:MD_Q_LO are initilaized to zero.
*
* OUTPUT: REMAINDER IN MD_REM_HI:MD_REM_LO AND QUOTIENT IS IN MD_Q_HI:MD_Q_LO
*
* LOCALS: QUOT_HI:QUOT_LO - intermediate quotient.
*         CNT	- loop count (ARn)
*         TMP16 - loc16 temp for the normalize macro.
******************************************************************************
MAINDIV:	.asmfunc
        MOVB    XCNT,#63     	; Initialize loop counter
	CMP64   ACC:P		; Clear V flag
	CMP64   ACC:P		; Test contents of ACC:P

        SB      LOOP,LT         ; If negative, then skip normalization
 
 	NORMALIZE64 CNT, TMP16	;

        LSL64   ACC:P,#1        ; If normalized, bit-63= 0
	SUBB	XCNT,#1
LOOP:
        LSL64   ACC:P,#1        ; Shift bit into Carry (C)

        MOVL    QUOT_HI,ACC     ; Store shifted intermediate quotient
        MOVL    QUOT_LO,P       ; Store shifted intermediate quotient

        MOVL    ACC,MD_REM_LO   ; Load Remainder low
        ROL     ACC             ; Shift Carry into bit-0
        MOVL    MD_REM_LO,ACC   ; Store Remainder
	MOVL    P,ACC		;
        MOVL    ACC,MD_REM_HI   ; Load Remainder high
        ROL     ACC             ; Shift Carry from remainder low into bit-32
        MOVL    MD_REM_HI,ACC   ; Store Remainder

	CMPL	ACC,MD_LDEN_HI  ;
	B	MD_NEQ, NEQ	;
	MOVL	ACC,P		;
	CMPL	ACC,MD_LDEN_LO	;
MD_NEQ:
	B	SKIP, LO	;

	MOVL	ACC, MD_REM_HI  ;
	SUBUL	P, MD_LDEN_LO	;
	SUBBL	ACC, MD_LDEN_HI ;

        MOVL    MD_REM_HI,ACC   ; else, store new Remainder
        MOVL    MD_REM_LO,P     ; else, store new Remainder
	SETC	C		;
	B	SKIP1,UNC	;
SKIP:
	MOVL	ACC, MD_REM_HI  ;
	CLRC	C		;
SKIP1:
        MOVL    ACC,MD_Q_LO     ; Load Quotient low (Carry preserved)
        ROL     ACC             ; Shift carry into bit-0
	MOVL	MD_Q_LO,ACC
        MOVL    ACC,MD_Q_HI     ; Load Quotient high (Carry preserved)
        ROL     ACC             ; Shift carry into bit-32
	MOVL	MD_Q_HI,ACC

        MOVL    ACC,QUOT_HI     ; Reload intermediate quotient
        MOVL    P,QUOT_LO       ; Reload intermediate quotient
        BANZ    LOOP,CNT--      ; Loop until count = 0
 
        LRETR                   ; Return to setup routine
	.endasmfunc
 
ll_mpy.asm/     1146129409  0     0     0       361       `
******************************************************************************
* ll_mpy.asm  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ll_mpy28.inc"
        .endif

ll_mpy28.inc/   1146129409  0     0     0       2670      `
******************************************************************************
* ll_mpy28.inc  v4.1.3
* Copyright (c) 2003-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the routine for 64-bit multiply
*
* SYMBOL DEFINITIONS:
*
* I,J - operands of the multiply in ACC:P and stack respectively
* R   - Result of the multiply returned in ACC:P
* xHI - High 32bits of that object
* xLO - Low 32bits of that object
*
******************************************************************************

******************************************************************************
* Set up aliases for stack, register references
******************************************************************************
        .asg   *-SP[6],    IHI 
        .asg   *-SP[8],    ILO 
        .asg   *-SP[2],    JHI
        .asg   *-SP[4],    JLO
        .asg   XAR4,       RLO 

	.page
******************************************************************************
* A 64X64 MULTIPLY WITH A 128-BIT RESULT WOULD BE CALCULATED:
*
*                IHI ILO
*             X  JHI JLO
*             ----------
*             ILO * JLO
*       JLO * IHI
*       ILO * JHI
* IHI * JHI
* ----------------------
*             RHI : RLO
*     128-bit result
*
* BUT WE NEED ONLY THE LOWER 64-BITS OF THIS CALCULATION.  THEREFORE THE
* IHI * JHI CALCULATION ISN'T DONE AT ALL AND THE UPPER HALF OF THE JLO * IHI
* AND ILO * JHI CALCULATIONS IS THROWN AWAY.  ALSO, THE ILO * JLO MULTIPLY
* MUST BE UNSIGNED, BUT THE SIGNNESS OF THE OTHER MULTIPLIES DOESN'T MATTER
* SINCE THE DIFFERENCE ALWAYS APPEARS IN THE UPPER 32-BITS.
******************************************************************************
	.global	LL$$MPY

LL$$MPY:	.asmfunc
	PUSH	P		; Push IHI:ILO
	PUSH	ACC		;

	MOVL	XT,JLO		; 
	IMPYL	P, XT, ILO	; 
	MOVL	RLO, P		; RLO = LO32(JLO * ILO)
	QMPYUL	P, XT, ILO	; P   = HI32(JLO * ILO)
	MOVL	XT, JHI		; 
	MOVL	ACC, P		; ACC = HI32(JLO * ILO) 
	IMPYXUL P, XT, ILO	; P   = LO32(JHI * ILO) 
	ADDL    ACC,P		; ACC = HI32(JLO * ILO) + LO32(JHI * ILO)
	MOVL	XT, IHI		; 
	IMPYXUL P, XT, JLO	; P = LO32(IHI * JLO) ==> HI32(RESULT)
	ADDL    ACC,P		; ACC += P
	MOVL    P, RLO   	; P   ==> LO32(RESULT)

	SUBB    SP,#4		; Adjust the stack on return.

******************************************************************************
* RETURN
******************************************************************************
	FFCRET	*XAR7		; return
	.endasmfunc

ll_tofd.asm/    1146129409  0     0     0       705       `
*;*****************************************************************************
*;                                                                            *
*;  LL_TOFD v4.1.3 
*;  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
*;  LL$$TOFD - Convert a signed 64 bit integer into an IEEE 754 format double *
*;             precision floating point number                                *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ll_tofd28.inc"
        .endif

ll_tofd28.inc/  1146129409  0     0     0       6181      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  LL_TOFD v4.1.3 
;*  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
;*  LL$$TOFD  - Convert a signed 32 bit integer into an IEEE 754 format double*
;*              precision floating point number    			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN ACC:P
;*   o RESULT IS RETURNED IN *XAR6
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                             						      *
;*                              		    register file	      *
;*                                                +-------------------+       *
;*                                           AR5  |        | RES_EXP  |       *
;*                                                +-------------------+       *
;*                                          XAR6  | PTR TO RET VALUE  |       *
;*                                                +-------------------+       *
;*                                           AR7  |        | TMP16    |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   LL$$TOFD
        .sect     ".text"

LL$$TOFD	.asmfunc
        .asg      XAR5,    XRES_EXP
        .asg       AR5,    RES_EXP
        .asg       AR7,    TMP16   

        .asg   *+XAR6[3],  RES_SIGN
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Save the sign of the input                                            *
*;    3 Get the absolute value of input                                       *
*;    4 Normalize the value and adjust the exponent                           *
*;*****************************************************************************
*
	CMP64	ACC:P		; Clear V flag
	CMP64	ACC:P		;
	B	RETURN_VALUE,EQ ; Return zero if Input is zero

	MOV	RES_SIGN, AH	; Save the sign

	MOVL	XRES_EXP, #0x43D; Normalize the value and adjust the exponent
	B	$10, GEQ	; 
        SB      1, OV           ; Clear V (overflow)                        
	CLRC	OVM		; Clear OVM to get desired effect on NEG64.
	NEG64	ACC:P		; Take absolute value of input

	B	$10, NOV	; 
	INC	RES_EXP		; Negate overflows when input is 0x8000:0:0:0
				; Account for the overflow by incrementing exp.
$10:
	NORMALIZE64 RES_EXP, TMP16

*
*;*****************************************************************************
*;     Pack the sign, mantissa and exponent into Double precision format      *
*;*****************************************************************************
*
	LSR64   ACC:P  #10	; 
	MOVL	RES_LSW, P	; Store the low 32 bits of the result

	LSR64   ACC:P, #4	; Move the mantissa out of AH. Since we already
				; saved the lower 32 bits to result we are okay.
        MOV     AH, RES_EXP     ; Load exponent and remove implied one 
        LSL64   ACC:P, #4       ; Shift back mantissa and exponent

	AND	RES_SIGN, #0x8000 ; Mask the sign bit
	OR	AH, RES_SIGN	; Set the sign bit
        MOVL    RES_MSW, ACC   ; Load the return value in the return area.
	LRETR
*
RETURN_VALUE:
        MOVL    RES_LSW, P     ;
        MOVL    RES_MSW, ACC   ; Load the return value in the return area.

RETURN:
        LRETR
	.endasmfunc
*


ll_tofs.asm/    1146129409  0     0     0       706       `
*;*****************************************************************************
*;                                                                            *
*;  LL_TOFS v4.1.3 
*;  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
*;  LL$$TOFS - Convert a signed 64 bit integer into an IEEE 754 format        * 
*;             single precision floating point number                         *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ll_tofs28.inc"
        .endif
ll_tofs28.inc/  1146129409  0     0     0       8339      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  LL_TOFS v4.1.3 
;*  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
;*  LL$$TOFS  - Convert a signed 64 bit integer into an IEEE 754 format       *
;*              single precision floating point number			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN ACC:P
;*   o RESULT IS RETURNED IN ACC 
;*
;*       NOTE : POSSIBLE LOSS OF PRECISION SINCE 32-BIT FLOAT HAS ONLY         
;*              24 BITS OF PRECISION                                           
;******************************************************************************
;*                                                                            *
;*  Floating Point Format - Single Precision                                  *
;*                                                                            *
;*                                                                            *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*                                                                            *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*                                                                            *
;*                                                                            *
;*       Single precision floating point format is a 32 bit format            *
;*       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
;*       23 bit mantissa field.  The fields are defined as follows.           *
;*                                                                            *
;*            Sign <S>          : 0 = positive values; 1 = negative values    *
;*                                                                            *
;*            Exponent <E7-E0>  : offset binary format                        *
;*                                00 = special cases (i.e. zero)              *
;*                                01 = exponent value + 127 = -126            *
;*                                FE = exponent value + 127 = +127            *
;*                                FF = special cases (not implemented)        *
;*                                                                            *
;*            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
;*                                1.M22M21...M1M0                             *
;*                                                                            *
;*            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
;*                                +1.0000000 e-126 to +1.9999998 e+127        *
;*                                (where e represents 2 to the power of)      *
;*                                -3.4028236 e+38  to -1.1754944 e-38         *
;*                                +1.1754944 e-38  to +3.4028236 e+38         *
;*                                (where e represents 10 to the power of)     *
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                           AR4  |        | SIGN     |       *
;*                                                +-------------------+       *
;*                                           AR5  |        | EXPONENT |       *
;*                                                +-------------------+       *
;*                                           AR6  |        | TMP16    |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   LL$$TOFS
        .sect     ".text"

LL$$TOFS:	.asmfunc
        .asg      XAR5,    XEXPONENT
        .asg       AR5,    EXPONENT
        .asg       AR6,    TMP16   
        .asg       AR4,    SIGN
*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Save the sign of the input                                            *
*;    3 Get the absolute value of input                                       *
*;    4 Normalize the value and adjust the exponent                           *
*;*****************************************************************************
*
	MOV	SIGN, AH		; Save the sign.
	CMP64	ACC:P			; Clear V flag
	CMP64	ACC:P			;
	B	RETURN, EQ		; Return zero if ACC is zero

	MOVB	XEXPONENT, #0xBD	; Load the initial exponent to 0xBD

	B	$10, GEQ		;
        SB      1, OV                   ; Clear V (overflow)
	CLRC	OVM		        ; Clear OVM to get desired effect on 
	                                ; NEG64.
	NEG64	ACC:P			; Take the absolute value of input 
	B	$10, NOV		; special case 0x80000000:00000000
	INC	EXPONENT		; Negate overflows for 0x8000:0:0:0
					; Account for overflow by ++exp.
$10:
	NORMALIZE64  EXPONENT, TMP16	; Normalize the mantissa 
	
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Shift mantissa   [0000 0000 0MMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0EEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;*****************************************************************************
*
PACK:
        AND     AH, #03FFFh         ; remove implied one and sign bit
	LSR64	ACC:P, #7	    ; shift mantissa to make room for exponent
        MOV     TMP16, AH           ; save AH
        MOV     AH, EXPONENT
        LSL     AH, 7               ; adjust exponent
        OR      AH, TMP16           ; restore AH with exponent
	TBIT    SIGN, #15           ; check sign
	B       RETURN, NTC         ; if positive, return
	TSET    AH, #15             ; Set the sign bit as 1.
*
RETURN:
        LRETR
	.endasmfunc


lldiv.c/        1146129409  0     0     0       520       `
/****************************************************************************/
/*  lldiv    v4.1.3                                                         */
/*  Copyright (c) 2003-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>

lldiv_t lldiv(long long num, long long den)
{
    lldiv_t rv;
    
    rv.quot = num / den;
    rv.rem  = num - (rv.quot * den);

    return rv;
}
localtim.c/     1146129409  0     0     0       3058      `
/****************************************************************************/
/*  localtime v4.1.3                                                        */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <limits.h>

#define SECS_IN_MIN (time_t)60
#define MINS_IN_HR  (time_t)60
#define HRS_IN_DAY  (time_t)24
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR * HRS_IN_DAY)
 
#define LEAPYEAR(y) (    (y+1900) % 4   == 0                               \
			 && ((y+1900) % 100 != 0 || (y+1900) % 400 == 0))

#define DAYS_IN_YR(y) ((time_t)365 + LEAPYEAR(y))
 
_CODE_ACCESS struct tm *localtime(const time_t *timer)
{
    static _DATA_ACCESS struct tm local;
    time_t ltime  = timer ? *timer : 0;
 
    local.tm_sec  = 0;
    local.tm_min  = 0;
    local.tm_hour = 0;
    local.tm_mday = 1;
    local.tm_mon  = 0;
    local.tm_year = 0;
 
    if (timer == 0 || ltime == (time_t)-1) return &local;
 
#if INT_MAX <= 32767
    /*------------------------------------------------------------------*/
    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
    /* REPRESENTED IN SIGNED INTS.                                      */
    /*------------------------------------------------------------------*/
    local.tm_sec   =  ltime % SECS_IN_MIN;
    local.tm_min   = (ltime / SECS_IN_MIN) % MINS_IN_HR;
    local.tm_hour  = (ltime / SECS_IN_HR)  % HRS_IN_DAY;
 
    /*------------------------------------------------------------------*/
    /* CONVERT ltime TO NUMBER OF DAYS                                  */
    /*------------------------------------------------------------------*/
    ltime /= SECS_IN_DAY;
 
    /*------------------------------------------------------------------*/
    /* TO DETERMINE THE YEAR, INSTEAD OF DIVIDING BY 365, DO A SUBTRACT */
    /* LOOP THAT ACCOUNTS FOR LEAP YEARS.                               */
    /*------------------------------------------------------------------*/
    {
	int year = 0;
	while (ltime >= DAYS_IN_YR(year))
	{
	    ltime -= DAYS_IN_YR(year);
	    ++year;
	}
     
	local.tm_year  = year;
	local.tm_mday += ltime;
    }
 
#else
    /*------------------------------------------------------------------*/
    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
    /* REPRESENTED IN SIGNED INTS.                                      */
    /*------------------------------------------------------------------*/
    if ((int)ltime < 0)
    {
	local.tm_sec  = ltime % 60; 
	local.tm_min  = ltime / 60; 
    }
    else local.tm_sec = ltime;
#endif
 
    /*------------------------------------------------------------------*/
    /* MAKE VALUES IN local INTO A VALID TIME.                          */
    /*------------------------------------------------------------------*/
    mktime(&local);
    return &local;
}
log.c/          1146129409  0     0     0       3562      `
/****************************************************************************/
/*  log    v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG() - natural log							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double log(double x)
{
    double a, b, f, r, w, z, znum;
    int n;

    /************************************************************************/
    /* check for errors in domain and range                                 */
    /************************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}
log10.c/        1146129409  0     0     0       3076      `
/****************************************************************************/
/*  log10  v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG10() - Logarithm							    */
/*									    */
/*  result = log10(e) * log(x)						    */
/****************************************************************************/
double log10(double x)
{
    double a, b, f, r, w, z, znum;
    int n;

    /*********************************************************************/
    /* check for domain and range errors                                 */
    /*********************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /*********************************************************************/
    /* f = mantissa(x), n = exponent(x)                                  */
    /*********************************************************************/
    f = frexp(x, &n);

    /*********************************************************************/
    /* for numbers < sqrt(0.5)                                           */
    /*********************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* for numbers > sqrt(0.5)                                           */
    /*********************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /*********************************************************************/
    /* calculate the natural log of (mant x) / 2		         */
    /*********************************************************************/
    r = z + z * w * (a / b);

    /*********************************************************************/
    /* log10(x) = (ln (mant x) + 2 * (exp x)) * log10(e) (but more       */
    /* mathematically stable)	                                         */
    /*********************************************************************/
    return (((n * C4 + r) + n * C3) * LOG10e);
}
lowlev.c/       1146129409  0     0     0       15184     `
/*****************************************************************************/
/*  LOWLEV.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Low level I/O routines                                                    */
/*                                                                           */
/* Functions:                                                                */
/*   getnexfildes()    - Allocate next entry in stream table.                */
/*   tabinit()         - Initialize the stream and device tables.            */
/*   finddevice()      - Search the device table for a device name.          */
/*   getdevice()       - Extract the device name and <find> it.              */
/*   add_device()      - Add a device record to the device table.            */
/*   removedevice()    - Remove the specified device record from the device  */
/*                              table.                                       */
/*   open()            - Open file/device and assign file descriptor.        */
/*   read()            - Read data from an open file/device.                 */
/*   write()           - Write to an open file/device.                       */
/*   lseek()           - Perform lseek on open file/device.                  */
/*   close()           - Close an open file/device.                          */
/*   unlink()          - Perform unlink on file/device.                      */
/*   rename()          - Rename file                                         */
/*****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <_lock.h>
#include <file.h>

typedef struct {
   char           name[9];
   unsigned short flags;
   int 	  	  (*OPEN) (const char *path, unsigned flags, int llv_fd);
   int 	  	  (*CLOSE) (int dev_fd);
   int 	  	  (*READ) (int dev_fd, char *buf, unsigned count);
   int 	  	  (*WRITE) (int dev_fd, const char *buf, unsigned count);
   off_t 	  (*LSEEK) (int dev_fd, off_t offset, int origin);
   int 	  	  (*UNLINK) (const char *path);
   int 	  	  (*RENAME) (const char *old_name, const char *new_name);
} _DEVICE;

extern _CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd),
                        HOSTclose(int dev_fd),
                        HOSTread(int dev_fd, char *buf, unsigned count),
                        HOSTwrite(int dev_fd, const char *buf, unsigned count),
                        HOSTunlink(const char *path),
                        HOSTrename(const char *old_name, const char *new_name);
extern _CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin);

static _CODE_ACCESS void tabinit(void);
static _CODE_ACCESS _DEVICE *finddevice(const char *devname);
static _CODE_ACCESS _DEVICE *getdevice (const char **path);

static _DEVICE  
_device[_NDEVICE] = { { "", _MSA, HOSTopen, HOSTclose, HOSTread,
			HOSTwrite, HOSTlseek, HOSTunlink, HOSTrename } };

#define stdevice (&_device[0]) /* Default device (host) */

static struct stream_info { _DEVICE *dev; int dfd; } 
_stream[_NSTREAM] =  { { stdevice, 0 },  
		       { stdevice, 1 }, 
		       { stdevice, 2 } };

/*****************************************************************************/
/*  TABINIT() - initialize the stream table and the device table             */
/*****************************************************************************/

static _CODE_ACCESS void tabinit(void)
{
   struct stream_info *st;
   _DEVICE            *dt;

   static _DATA_ACCESS int init = 0;

   _lock();

   if (!init)
   {
       /*--------------------------------------------------------------------*/
       /* STEP THROUGH THE TABLES SETTING NAME AND DEVICE ENTRIES TO NULL    */
       /* (SKIP PREDEFINED DEVICE AND STREAMS)				     */
       /*--------------------------------------------------------------------*/
       for (st = &_stream[3]; st != &_stream[_NSTREAM]; (st++)->dev = NULL);
       for (dt = &_device[1]; dt != &_device[_NDEVICE]; *(dt++)->name = '\0');
       init = 1;
   }

   _unlock();
}

/*****************************************************************************/
/*  FINDDEVICE() - find the device record that matches devname in the device */
/*                     table                                                 */
/*****************************************************************************/

static _CODE_ACCESS _DEVICE *finddevice(const char *devname)
{
   _DEVICE *dt;

   if (devname[0] == '\0') return NULL;

   /*------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR THE DEVICE NAME - RETURN NULL IF NOT FOUND */
   /*------------------------------------------------------------------------*/
   for (dt = &_device[1]; dt != &_device[_NDEVICE]; ++dt)
       if (!strcmp(dt->name, devname)) return dt;

   return NULL;
}


/*****************************************************************************/
/*  GETDEVICE() - extract the device name and call finddevice                */
/*****************************************************************************/

static _CODE_ACCESS _DEVICE *getdevice (const char **path)
{
   char devname[9];
   char *colon = strchr(*path, ':');
   _DEVICE *dev;

   if (colon != NULL)
   {
       int devnamlen = colon - *path;
       if (devnamlen > 8) devnamlen = 8;

       strncpy(devname, *path, devnamlen);
       devname[devnamlen] = '\0';
       dev = finddevice(devname);

       if (dev) { *path = colon + 1; return dev; }
   }

   return stdevice; /* the "standard" device - host I/O */
}


/*****************************************************************************/
/*  ADDEVICE() - add a device record to the device table                     */
/*****************************************************************************/

_CODE_ACCESS
int add_device(char     *name,
               unsigned  flags,
               int     (*dopen)  (const char *path, unsigned flags, int llv_fd),
               int     (*dclose) (int dev_fd),
               int     (*dread)  (int dev_fd, char *buf, unsigned count),
               int     (*dwrite) (int dev_fd, const char *buf, unsigned count),
               off_t   (*dlseek) (int dev_fd, off_t offset, int origin),
               int     (*dunlink)(const char *path),
               int     (*drename)(const char *old_name, const char *new_name))
{
   _DEVICE *dt;

   tabinit();

   _lock();

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE DEVICE TABLE FOR AN EMPTY SLOT, RETURN -1 IF NONE FOUND      */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; dt != _device+_NDEVICE && dt->name[0] != '\0'; ++dt);
   if (dt == &_device[_NDEVICE]) { _unlock(); return -1; }

   strncpy(dt->name,name,8);
   dt->name[8] = '\0';
   dt->flags   = flags;
   dt->OPEN    = dopen;
   dt->CLOSE   = dclose;
   dt->READ    = dread;
   dt->WRITE   = dwrite;
   dt->LSEEK   = dlseek;
   dt->UNLINK  = dunlink;
   dt->RENAME  = drename;

   _unlock();

   return 0;
}

/******************************************************************************/
/*  REMOVEDEVICE() - remove the specified device record from the device table */
/******************************************************************************/

_CODE_ACCESS int remove_device(char *name)
{
   _DEVICE *ptr;

   _lock();

   /*------------------------------------------------------------------------*/
   /* FIND RECORD AND SET NAME TO NULL					     */
   /*------------------------------------------------------------------------*/
   if ( !(ptr = finddevice(name)) ) { _unlock(); return -1; }

   ptr->name[0] = '\0';

   _unlock();

   return 0;
}


/*****************************************************************************/
/*  OPEN() - open file/device specified by path and assign file descriptor   */
/*****************************************************************************/

_CODE_ACCESS int open(const char *path, unsigned flags, int mode)
{
   struct stream_info *ptr;
   _DEVICE    	      *dev;
   int        	      dev_fd;
   int        	      llv_fd;

   /*-------------------------------------------------------------------------*/
   /* INITIALIZE STREAM AND DEVICE TABLE FIRST TIME AROUND                    */
   /*-------------------------------------------------------------------------*/
   tabinit();

   _lock();

   /*-------------------------------------------------------------------------*/
   /* GET THE NEXT AVAILABLE FILE DESCRIPTOR - RETURN -1 IF NONE AVAILABLE    */
   /*-------------------------------------------------------------------------*/
   for (ptr = &_stream[3]; ptr != &_stream[_NSTREAM] && ptr->dev; ++ptr);
   if (ptr == &_stream[_NSTREAM]) { _unlock(); return -1; }
   llv_fd = ptr - &_stream[0];

   /*------------------------------------------------------------------------*/
   /* GET DEVICE AND PEFORM OPEN - SET STREAM TABLE ENTRY AND FLAGS          */
   /*------------------------------------------------------------------------*/
   dev    = getdevice(&path);
   dev_fd = (dev->flags & _BUSY) ? -1 : (*(dev->OPEN))(path,flags,llv_fd);

   if (dev_fd < 0) { _unlock(); return dev_fd; }
   
   _stream[llv_fd].dev = dev;
   _stream[llv_fd].dfd = dev_fd;
   if ( !(dev->flags & _MSA) ) dev->flags |= _BUSY;

   _unlock();

   return llv_fd;
}

/*****************************************************************************/
/*  READ() - read data from an open device/file                              */
/*****************************************************************************/

_CODE_ACCESS int read(int llv_fd, char *bufptr, unsigned cnt)
{
   int result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM READ FOR THIS DEVICE/FILE   */
   /*------------------------------------------------------------------------*/
   result = (*(_stream[llv_fd].dev->READ)) (_stream[llv_fd].dfd,bufptr,cnt);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  WRITE() - write data to an open device/file                              */
/*****************************************************************************/

_CODE_ACCESS int write(int llv_fd, const char *bufptr, unsigned cnt)
{
   int result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM WRITE FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   result = (*(_stream[llv_fd].dev->WRITE)) (_stream[llv_fd].dfd,bufptr,cnt);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  LSEEK() - lseek on an open device/file                                   */
/*****************************************************************************/

_CODE_ACCESS off_t lseek(int llv_fd, off_t offset, int origin)
{
   off_t result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM LSEEK FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   result = (*(_stream[llv_fd].dev->LSEEK)) (_stream[llv_fd].dfd,offset,origin);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  CLOSE() - close an open device/file                                      */
/*****************************************************************************/

_CODE_ACCESS int close(int llv_fd)
{
   int result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM CLOSE FOR THIS DEVICE/FILE  */
   /* CLEAR STREAM TABLE ENTRY AND DEVICE FLAGS                              */
   /*------------------------------------------------------------------------*/
   if ( (result = (*(_stream[llv_fd].dev->CLOSE))(_stream[llv_fd].dfd)) != -1 )
   {
      _stream[llv_fd].dev->flags &= ~_BUSY;
      _stream[llv_fd].dev = NULL;
   }

   _unlock();

   return result;
}

/*****************************************************************************/
/*  UNLINK() - unlink an open device/file                                    */
/*****************************************************************************/

_CODE_ACCESS int unlink(const char *path)
{
   _DEVICE *dev;
   int      result;

   _lock();

   dev = getdevice(&path);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM UNLINK FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   result = (*(dev->UNLINK)) (path);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  RENAME() - rename a device/file                                          */
/*****************************************************************************/

_CODE_ACCESS int rename(const char *old_name, const char *new_name)
{
   _DEVICE *old_dev, *new_dev;
   int result;

   _lock();

   old_dev = getdevice(&old_name);
   new_dev = getdevice(&new_name);

   /*------------------------------------------------------------------------*/
   /* IF THE DEVICES ARE NOT THE SAME, RENAME WOULD REQUIRE A FILE COPY.     */
   /*------------------------------------------------------------------------*/
   if (old_dev != new_dev) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM RENAME FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   result = (*(old_dev->RENAME)) (old_name, new_name);

   _unlock();
   
   return result;
}
ltoa.c/         1146129409  0     0     0       772       `
/****************************************************************************/
/*  ltoa v4.1.3								    */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>
#define BUFLEN 20

_CODE_ACCESS int ltoa(long val, char *buffer)
{
    char           tempc[BUFLEN];
    register char *bufptr;
    register int   neg = val < 0;
    register long  uval = neg ? -val : val;

    *(bufptr = &tempc[BUFLEN - 1]) = 0;

    do {*--bufptr = (uval % 10) + '0';}  while(uval /= 10);
    if (neg) *--bufptr = '-';

    memcpy(buffer,bufptr, uval = (tempc + BUFLEN) - bufptr);
    return uval - 1;    /* DON'T COUNT NULL TERMINATION */
}

math.h/         1146129409  0     0     0       2447      `
/*****************************************************************************/
/* math.h     v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _MATH
#define _MATH

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cmath> IS RECOMMENDED OVER <math.h>.  <math.h> IS PROVIDED FOR 
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
#include <cmath>
using std::modf;
using std::asin;
using std::acos;
using std::atan;
using std::atan2;
using std::ceil;
using std::cos;
using std::cosh;
using std::exp;
using std::fabs;
using std::floor;
using std::fmod;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::pow;
using std::sin;
using std::sinh;
using std::tan;
using std::tanh;
using std::sqrt;

#else /* !__cplusplus */

#include <linkage.h>
#include <float.h>
#define HUGE_VAL   DBL_MAX
#define HUGE_VALL  LDBL_MAX

/***************************************************************/
/* FUNCTION DEFINITIONS.                                       */
/***************************************************************/
         double modf(double x, double *y); 
         double far_modf(double x, far double *y); 
         double asin(double x);
         double acos(double x);
         double atan(double x);
         double atan2(double y, double x);
__inline double ceil(double x)  { double y; return (modf(x, &y) > 0 ? y+1:y); }
         double cos(double x);
         double cosh(double x);
         double exp(double x);
         double fabs(double x);
__inline double floor(double x) { double y; return (modf(x, &y) < 0 ? y-1:y); }
         double fmod(double x, double y);
         double frexp(double x, int *exp);
         double far_frexp(double x, far int *exp);
         double ldexp(double x, int exp);
         double log(double x);
         double log10(double x);
         double pow(double x, double y);
         double sin(double x);
         double sinh(double x);
         double tan(double x);
         double tanh(double x);
         double sqrt(double x);

#endif /* __cplusplus */
#endif /* _MATH */

memccpy.c/      1146129409  0     0     0       964       `
/*****************************************************************************/
/*  MEMCCPY.C  v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include "stdlib.h"

extern _CODE_ACCESS char *memccpy(char *dest, const char *src, int ch, int cnt);

/*--------------------------------------------------------------------------*/
/* PERFORM SAME OPERATION AS MEMCPY, ABORT IF "ch" is COPIED.               */
/* RETURN POINTER TO BYTE AFTER ch IS FOUND, OR NULL IF NOT FOUND           */
/*--------------------------------------------------------------------------*/
_CODE_ACCESS char *memccpy(char *dest, const char *src, int ch, int cnt)
{
   if (cnt <= 0) return NULL;
   do
      if ((*dest++ = *src++) == ch) return (dest);
   while (--cnt != 0);

   return NULL;
}
memchr.c/       1146129409  0     0     0       411       `
/****************************************************************************/
/*  memchr v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _MEMCHR

#include <string.h>

memcmp.c/       1146129409  0     0     0       363       `
/****************************************************************************/
/*  memcmp v4.1.3							    */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _MEMCMP

#include <string.h>

memcpy.c/       1146129409  0     0     0       4207      `
/****************************************************************************/
/*  memcpy v4.1.3                                                           */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

void *memcpy(void *to, const void *from, size_t n)
{
   return memcpy(to, from, n);    /* NOTE:  MEMCPY() IS A BUILTIN FUNCTION */
}

void *__memcpy(void *to, const void *from, size_t n)
{
     /***********************************************************************/
     /*  size_t has been changed from unsigned int to unsigned long to      */
     /*  support objects greater than 64K.  However, the 3rd parameter for  */
     /*  memcpy can not be >64K as the from and to pointers are 16 bit      */
     /*  pointers. We can make use of this to optimize this function.       */
     /***********************************************************************/
     register char *rto   = (char *) to;
     register char *rfrom = (char *) from;
     register unsigned int rn;
     register unsigned int nn = (unsigned int)n;

     for (rn = 0; rn < nn; rn++) *rto++ = *rfrom++;
     return (to);
}

void *__memcpy_nf(void *to, const void far *from, size_t n)
{
     /***********************************************************************/
     /*  size_t has been changed from unsigned int to unsigned long to      */
     /*  support objects greater than 64K.  However, the 3rd parameter for  */
     /*  memcpy can not be >64K as the to pointer is 16 bit.                */
     /*  We can make use of this to optimize this function.        	    */
     /***********************************************************************/
     register char *rto   = (char *) to;
     register char far *rfrom = (char far *) from;
     register unsigned int rn;
     register unsigned int nn = (unsigned int)n;

     for (rn = 0; rn < nn; rn++) *rto++ = *rfrom++;
     return (to);
}

void far *__memcpy_fn(void far *to, const void *from, size_t n)
     /***********************************************************************/
     /*  size_t has been changed from unsigned int to unsigned long to      */
     /*  support objects greater than 64K.  However, the 3rd parameter for  */
     /*  memcpy can not be >64K as the from pointer is 16 bit.              */
     /*  We can make use of this to optimize this function.        	    */
     /***********************************************************************/
{
     register char far *rto   = (char far *) to;
     register char *rfrom = (char *) from;
     register unsigned int rn;
     register unsigned int nn = (unsigned int)n;

     for (rn = 0; rn < nn; rn++) *rto++ = *rfrom++;
     return (to);
}

void far *__memcpy_ff(void far *to, const void far *from, size_t n)
{
     register char far *rto   = (char far *) to;
     register char far *rfrom = (char far *) from;
     register unsigned int rn;
     register unsigned int nn = (unsigned int) n;

     /***********************************************************************/
     /*  Assume that the size is < 64K and do the memcpy. At the end compare*/
     /*  the number of chars moved with the size n. If they are equal       */
     /*  return. Else continue to copy the remaining chars.                 */
     /***********************************************************************/
     for (rn = 0; rn < nn; rn++) *rto++ = *rfrom++;
     if (nn == n) return (to);

     /***********************************************************************/
     /*  Write the memcpy of size >64K using nested for loops to make use   */
     /*  of BANZ instrunction.                                              */
     /***********************************************************************/
     {
        register unsigned int upper = (unsigned int)(n >> 16);
        register unsigned int tmp;
        for (tmp = 0; tmp < upper; tmp++)
	{
           for (rn = 0; rn < 65535; rn++) 
		*rto++ = *rfrom++;
	   *rto++ = *rfrom++;
	}
     }

     return (to);
}

memmov.c/       1146129409  0     0     0       702       `
/****************************************************************************/
/*  memmov.c  v4.1.3                                                        */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

void *memmove(void *s1, const void *s2, size_t n)
{
   if (s2 > s1)
      return memcpy(s1, s2, n);
   else
   {
      unsigned char *st1 = (unsigned char *)s1;
      unsigned char *st2 = (unsigned char *)s2;
      size_t         ln;
 
      st1 += n;
      st2 += n;
      for (ln = 0; ln < n; ln++) *--st1 = *--st2;
   }

   return s1;
}

memory.c/       1146129409  0     0     0       23866     `
/****************************************************************************/
/*  memory.c v4.1.3							    */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated		    */
/****************************************************************************/

/*****************************************************************************/
/*									     */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines.  The algorithms used are based on the algorithms    */
/*  described in Knuth's "The Art Of Computer Programming, Vol 1" on pages   */
/*  435-441. Algorithm 2.5A has been modified to improve the resistance to   */
/*  fragmentation.							     */
/*									     */
/*  Knuth gives two reasons for prefering "first fit" over "best fit".	     */
/*   1) The algorithm is significantly faster, since the whole of the free   */
/*	store does not have to be searched for each allocation		     */
/*	(or deallocation).						     */
/*   2) The first fit algorithm is more resistant to overflow during	     */
/*	repeated allocation and deallocation than is the best fit algorithm  */
/*	(See problems 36-43 on page 456).				     */
/*									     */
/*  The following assumptions/rules apply:				     */
/*									     */
/*   1) Packets are allocated a minimum of MINSIZE words	     	     */
/*   2) The heap can be reset at any time by calling the function	     */
/*	"minit"								     */
/*   3) The heap size must be declared in the linker command file using	     */
/*	the -heap option.						     */
/*									     */
/*  The following items are defined in this module :			     */
/*	 minit()    : Function to initialize dynamic memory management	     */
/*	 malloc()   : Function to allocate memory from mem mgmt system.	     */
/*	 calloc()   : Allocate and clear memory from mem mgmt system.	     */
/*	 realloc()  : Reallocate a packet				     */
/*	 free()	    : Function to free allocated memory.		     */
/*									     */
/*	_sys_memory : Array to contain all memory allocate by system.	     */
/*	 sys_free   : Pointer to free list				     */
/*									     */
/*	 free_memory() : Return total amount of available free memory.	     */
/*	 max_free() : Return largest single free memory block in heap.	     */
/*									     */
/*****************************************************************************/

/*****************************************************************************/
/*  DEBUG Support.							     */
/*  When the symbol DEBUG has been #defined, an extra WORD is added to the   */
/*  allocation header, and is set to the value 0xDEAD in every allocated and */
/*  free block of memory.  The integrety of the heap can then be checked by  */
/*  calling the function "void * chkheap()". This function returns zero if   */
/*  all the memory blocks have the correct signature.  Otherwise, it returns */
/*  the offset to the first location of an invalid value in a block header.  */
/*****************************************************************************/

#undef _INLINE				/* DISABLE INLINE EXPANSION	    */

#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <_lock.h>

#ifdef DEBUG
#define GUARDDWORD 0xDEAD
#endif

/*****************************************************************************/
/* Declare the memory pool as a .usect called .sysmem.	The size of the	     */
/* section .sysmem is determined by the linker via the -heap option	     */
/*****************************************************************************/
__asm("__sys_memory   .usect  \".sysmem\",0");
extern int _sys_memory[];

/*****************************************************************************/
/* "PACKET" is the template for a data packet.  "Packet_size" is the number  */
/* of words allocated for the user, excluding the size ("OVERHEAD")	     */
/* required for management of the packet.  When a packet is on the free	     */
/* list, the field "next_free" is a pointer to the next member of the	     */
/* freelist; when the packet is in use (allocated), this field is invalid,   */
/* overwritten by user data (the address of this field is the address	     */
/* returned by malloc).  A negative size indicates a free packet.	     */
/*****************************************************************************/
#if LARGE_MODEL
typedef long memsz_t;
#else
typedef int  memsz_t;
#endif

typedef struct fpack
{
    memsz_t packet_size; /* in words */
#ifdef DEBUG
    int guard;
#endif
    struct fpack *next_free;
} PACKET;

#define LIMIT	((PACKET *) -1)

/*****************************************************************************/
/* OVERHEAD is the space in the packet required to store the packet size.    */
/* This macro is used for two purposes: to compute the size of the	     */
/* allocation, and to ensure the packet is aligned properly.		     */
/*****************************************************************************/
#define OVERHEAD offsetof(PACKET, next_free)

/*****************************************************************************/
/* MINSIZE is the smallest packet we will allocate.  It is required that     */
/* (MINSIZE + OVERHEAD >= sizeof(PACKET)), else the packet won't be large    */
/* enough to store the bookkeeping needed to be placed in the free list.     */
/*****************************************************************************/
#define MINSIZE 2 

/*****************************************************************************/
/* _SYSMEM_SIZE is the symbol that linker defines as the size of heap.	     */
/* Access of that value from 'C' is done by taking the address of this symbol*/
/* The C55x linker sets this symbol to the number of *bytes* in the heap, so */
/* we must convert thus number to words right away.                          */
/*****************************************************************************/
extern int _SYSMEM_SIZE;
#define MEMORY_SIZE ((memsz_t)&_SYSMEM_SIZE)

/*****************************************************************************/
/* The list of free blocks						     */
/*****************************************************************************/
static PACKET *sys_free;

/*****************************************************************************/
/* The start of the heap						     */
/*****************************************************************************/
static PACKET *sys_base;

/*****************************************************************************/
/* The total size of the heap.						     */
/*****************************************************************************/
static memsz_t memsize;

/*****************************************************************************/
/* This flag tells malloc if the heap needs to be initialized	             */
/*****************************************************************************/
static int first_call = 1;

/*****************************************************************************/
/*									     */
/*  MINIT - This function performs the initial setup of the heap, and can    */
/*          be called by the user to completely reset the memory management  */
/*          system.				                             */
/*									     */
/*****************************************************************************/
void minit(void)
{
    _lock();
    memsize = MEMORY_SIZE;

    /*-----------------------------------------------------------------------*/
    /* To initialize the memory system, set up the free list to point to     */
    /* the entire heap, and initialize heap to a single empty packet.	     */
    /*-----------------------------------------------------------------------*/
    /* We may need to adjust the start of the heap to ensure that the	     */
    /* address of the field "next_free" is strictly aligned.		     */
    /*-----------------------------------------------------------------------*/
    if (((memsz_t)_sys_memory ^ OVERHEAD) & 1)
    {
	sys_free = (PACKET *) (_sys_memory + 1);
	--memsize;
    }
    else
    {
	sys_free = (PACKET *) _sys_memory;
    }
    if (memsize & 1) --memsize;

    sys_free->packet_size = -(memsize - OVERHEAD); /* NEGATIVE==FREE */
    sys_free->next_free	  = LIMIT;

#ifdef DEBUG
    sys_free->guard = GUARDDWORD;
#endif
    sys_base = sys_free;

    first_call = 0; /* CLEAR THE FLAG */
    _unlock();
}

/*****************************************************************************/
/*									     */
/*  MALLOC - Allocate a packet of a given size, and return pointer to it.    */
/*									     */
/*****************************************************************************/
void *malloc(size_t size)
{
    memsz_t allocsize = size;
    PACKET *current, *next, *prev;

    if (allocsize == 0) return 0;

    /*-----------------------------------------------------------------------*/
    /* We may need to adjust the size of the allocation request to ensure    */
    /* that the address of the field "next_free" remains strictly aligned    */
    /* in all packets on the free list.					     */
    /*-----------------------------------------------------------------------*/
    if ((allocsize ^ OVERHEAD) & 1) ++allocsize;

    _lock();

    if (first_call) minit();

    current = sys_free;
    prev = 0;

    /*-----------------------------------------------------------------------*/
    /* Find the first block large enough to hold the requested allocation    */
    /*-----------------------------------------------------------------------*/
    while (current != LIMIT && -current->packet_size < allocsize)
    {
	prev = current;
	current = current->next_free;
    }

    if (current == LIMIT)
    {
        /*-------------------------------------------------------------------*/
        /* No block large enough was found, so return NULL.		     */
        /*-------------------------------------------------------------------*/
	_unlock();
	return 0;
    }

    if (-current->packet_size > (allocsize + OVERHEAD + MINSIZE))
    {
        /*-------------------------------------------------------------------*/
        /* The packet is larger than needed; split the block and mark the    */
        /* smaller-addressed block as used.  The smaller-addressed block     */
        /* was chosen as a way to ensure that freed blocks get recycled	     */
        /* before allocations are made from the large original free block.   */
        /* However, this may tend to increase the length of the free list    */
        /* search for a large enough block.				     */
        /*-------------------------------------------------------------------*/
        /* Knuth's algorithm 2.5a instead allocates the larger-addressed     */
        /* block to the user.  This tends to leave the largest free blocks   */
        /* at the beginning of the free list.  Knuth's 2.5a' uses a "rover"  */
        /* pointer to prevent small free blocks from being concentrated in   */
        /* any part of the list.					     */
        /*-------------------------------------------------------------------*/
	next = (PACKET *)((char *)current + allocsize + OVERHEAD);
	next->packet_size=current->packet_size+allocsize+OVERHEAD;/*NEG==FREE*/
#ifdef DEBUG
	next->guard = GUARDDWORD;
#endif
	current->packet_size = allocsize; /* POSITIVE==IN USE */

	if (prev) prev->next_free = next;
	else      sys_free        = next;

	next->next_free = current->next_free;
    }
    else
    {
        /*-------------------------------------------------------------------*/
        /* Allocate the whole block and remove it from the free list.	     */
        /*-------------------------------------------------------------------*/
	if (prev) prev->next_free = current->next_free;
	else      sys_free        = current->next_free;

	current->packet_size = -current->packet_size; /* POSITIVE==IN USE */
    }

    _unlock();
    return &(current->next_free);
}

/*****************************************************************************/
/*									     */
/*  FREE - Return a packet allocated by malloc to free memory pool.	     */
/*									     */
/*****************************************************************************/
void free(void *userptr)
{
    PACKET *sysblock, *next, *prev;

    if (userptr == 0) return; /* HANDLE NULL POINTER */

    _lock();

    next = sys_free;
    prev = 0;
    sysblock = (PACKET *)((char *)userptr - OVERHEAD);
#if 0
#ifdef DEBUG
    /*-----------------------------------------------------------------------*/
    /* In the debug version, we can now check if the packet to be freed has  */
    /* the correct signature, but we must decide how to report the problem   */
    /* to the client code.						     */
    /*-----------------------------------------------------------------------*/
    if (sysblock->guard != GUARDDWORD)
    {
	/* CODE TO REPORT THE ERROR */
    }
#endif
#endif

    /*-----------------------------------------------------------------------*/
    /* Search the free list for the *free* packets physically closest to     */
    /* the packet to be freed.  PREV is the closest free packet with a	     */
    /* smaller address, and NEXT is the closest free packet with a larger    */
    /* address.								     */
    /*-----------------------------------------------------------------------*/
    while (next < sysblock)
    {
	prev = next;
	next = next->next_free;
    }

    /*-----------------------------------------------------------------------*/
    /* Coallesce with next block if possible.				     */
    /*-----------------------------------------------------------------------*/
    if ((char *)sysblock + sysblock->packet_size + OVERHEAD == (char *)next)
    {
	sysblock->next_free = next->next_free;
	sysblock->packet_size += -next->packet_size + OVERHEAD;	/* POS==USED */
#ifdef DEBUG
	next->guard = 0;
#endif
    }
    else sysblock->next_free = next;	/* START TO PUT INTO LIST */

    if (prev)				/* ARE WE THE NEW HEAD OF THE LIST */
    {
        /*-------------------------------------------------------------------*/
        /* sysblock is not the head of the free list; try to coallesce with  */
        /* prev								     */
        /*-------------------------------------------------------------------*/
	if ((char *)prev - prev->packet_size + OVERHEAD == (char *)sysblock)
	{
	    prev->next_free = sysblock->next_free;
	    prev->packet_size += -sysblock->packet_size - OVERHEAD;/*NEG==FREE*/
#ifdef DEBUG
	    sysblock->guard = 0;
#endif
	}
	else
	{
	    prev->next_free = sysblock;
	    sysblock->packet_size = -sysblock->packet_size; /* NEGATIVE==FREE */
	}
    }
    else
    {
	sys_free = sysblock;
	sysblock->packet_size = -sysblock->packet_size; /* NEGATIVE==FREE */
    }
    _unlock();
}

/*****************************************************************************/
/*									     */
/*  REALLOC - Reallocate a packet to a new size.			     */
/*									     */
/*****************************************************************************/
void *realloc(void *userptr, size_t size)
{
    PACKET *next, *prev, *sysblock;
    int     newsize = size;

    /*-----------------------------------------------------------------------*/
    /* Handle special cases						     */
    /*-----------------------------------------------------------------------*/
    if (newsize == 0)
    {
	free(userptr);
	return 0;
    }

    if (userptr == 0) return malloc(newsize);

    /*-----------------------------------------------------------------------*/
    /* We may need to adjust the size of the allocation request to ensure    */
    /* that the address of the field "next_free" remains strictly aligned    */
    /* in all packets on the free list.					     */
    /*-----------------------------------------------------------------------*/
    if ((newsize ^ OVERHEAD) & 1) ++newsize;

    /*-----------------------------------------------------------------------*/
    /* Find the start of the system block containing the old allocation.     */
    /*-----------------------------------------------------------------------*/
    sysblock = (PACKET *)((char *)userptr - OVERHEAD);

    /*-----------------------------------------------------------------------*/
    /* Find the system block physically after SYSBLOCK on the heap.	     */
    /*-----------------------------------------------------------------------*/
    next = (PACKET *)((char *)userptr + sysblock->packet_size);

    /*-----------------------------------------------------------------------*/
    /* If we are growing the packet, check if we must revert to calling      */
    /* malloc and copying the data.  We must do so if:                       */
    /* 	   1) sysblock is the last block in the heap, or		     */
    /* 	   2) the next block is not free, or				     */
    /* 	   3) the next block is free but not big enough.		     */
    /*-----------------------------------------------------------------------*/
    _lock();
    if ((newsize > sysblock->packet_size) && 
	(((char *)next >= (char *)sys_base + memsize) ||
	 (next->packet_size > 0)                      ||	
	 ((next->packet_size < 0) &&
	  (newsize > sysblock->packet_size - next->packet_size + OVERHEAD))))
    {
	void *ptr;
	_unlock();
	ptr = malloc(newsize);
	if (ptr)
	{
	    memcpy(ptr, userptr, sysblock->packet_size);
	    free(userptr);
	}
	return ptr;
    }

    /*-----------------------------------------------------------------------*/
    /* Once we reach here, we know we can realloc in place.		     */
    /*-----------------------------------------------------------------------*/
    /* Search the free list for the *free* packets physically closest to     */
    /* the packet to be freed.  PREV is the closest free packet with a	     */
    /* smaller address, and NEXT is the closest free packet with a larger    */
    /* address.								     */
    /*-----------------------------------------------------------------------*/
    next = sys_free;
    prev = 0;

    while (next < sysblock)
    {
	prev = next;
	next = next->next_free;
    }

    if ((char *)next == (char *)userptr + sysblock->packet_size)
    {
        /*-------------------------------------------------------------------*/
        /* The system block immediately following SYSBLOCK is free.	     */
        /* Coalesce with it, then try to free the unused portion.	     */
        /*-------------------------------------------------------------------*/
#ifdef DEBUG
	next->guard = 0;
#endif
	if (sysblock->packet_size + -next->packet_size - newsize <= MINSIZE)
	{
            /*---------------------------------------------------------------*/
            /* The next block is completely absorbed.			     */
            /*---------------------------------------------------------------*/
	    if (prev) prev->next_free = next->next_free;
	    else      sys_free        = next->next_free;
	    sysblock->packet_size += -next->packet_size + OVERHEAD; /* SGN<0 */
	}
	else
	{
            /*---------------------------------------------------------------*/
            /* The next block has enough space left over to break off a new  */
            /* block and add it to the free list.			     */
            /*---------------------------------------------------------------*/
	    PACKET *nextnext = next->next_free;
	    int nextsize = -next->packet_size + sysblock->packet_size - newsize;

	    PACKET *newnext = (PACKET*)((char *)userptr + newsize);
	    newnext->packet_size = -nextsize; /* NEGATIVE==FREE */
	    newnext->next_free = nextnext;
#ifdef DEBUG
	    newnext->guard = GUARDDWORD;
#endif
	    sysblock->packet_size = newsize; /* POSITIVE==IN USE */
	    if (prev) prev->next_free = newnext;
	    else      sys_free        = newnext;
	}
    }
    else
    {
        /*-------------------------------------------------------------------*/
        /* Shrink in place if there is enough extra to make a free block     */
        /*-------------------------------------------------------------------*/
	if (sysblock->packet_size - newsize >= OVERHEAD + MINSIZE)
	{
	    int nextsize = sysblock->packet_size - newsize - OVERHEAD;

	    PACKET *newnext = (PACKET*)((char *)userptr + newsize);
	    newnext->packet_size = -nextsize; /* NEGATIVE==FREE */
	    newnext->next_free = next;
#ifdef DEBUG
	    newnext->guard = GUARDDWORD;
#endif
	    sysblock->packet_size = newsize; /* POSITIVE==IN USE */
	    if (prev) prev->next_free = newnext;
	    else      sys_free        = newnext;
	}
    }
    _unlock();
    return userptr;
}

/*****************************************************************************/
/*									     */
/*  CALLOC - Allocate a packet of a given size, set the data in the	     */
/*		 packet to nulls, and return a pointer to it.		     */
/*									     */
/*****************************************************************************/
void *calloc(size_t num, size_t size)
{
    int	  i   = size * num;
    void *ret = malloc(i);
    if (ret)
    {
	char *c = ret;
	while (i--) *c++ = 0;
    }
    return ret;
}


/*****************************************************************************/
/*									     */
/*  CHKHEAP - Check the integrety of the memory heap.  If the heap	     */
/*	      is corrupt, returns the address of the corrupt header, else    */
/*	      returns 0.  Always returns 0 in release version.		     */
/*									     */
/*****************************************************************************/
void *chkheap(void)
{
#ifdef DEBUG
    PACKET *pkt, *top;
    _lock();
    /* find the start of the heap */
    pkt = sys_base;
    top = (PACKET *)((char *)sys_base + memsize - sizeof(PACKET));

    while (pkt < top)
    {
	if (pkt->guard != GUARDDWORD)
	{
	    _unlock();
	    return (void *) &pkt->guard;
	}

	if (pkt->packet_size > 0)
	    pkt = (PACKET *)((char *)pkt + pkt->packet_size + OVERHEAD);
	else
	    pkt = (PACKET *)((char *)pkt + -pkt->packet_size + OVERHEAD);
    }
    _unlock();
#endif

    return 0;
}

/*****************************************************************************/
/*									     */
/*  FREE_MEMORY - returns the total amount of free memory available for	     */
/*		  allocation.  The memory may be fragmented		     */
/*									     */
/*****************************************************************************/
int free_memory(void)
{
    struct fpack *ptr;
    int memsz = 0;

    _lock();
    ptr = sys_free;

    if (!first_call)	/* IF MEMORY IS INITIALIZED */
    {
	while (ptr != LIMIT)
	{
	    memsz -= ptr->packet_size;
	    ptr = ptr->next_free;
	}
    }
    _unlock();
    return memsz;
}

/*****************************************************************************/
/*									     */
/*  MAX_FREE - returns the size of the largest single block of memory	     */
/*	       available for allocation.				     */
/*									     */
/*****************************************************************************/
int max_free(void)
{
    struct fpack *ptr;
    int memsz = 0;

    _lock();
    ptr = sys_free;

    if (!first_call)	/* IF MEMORY IS INITIALIZED */
    {
	while (ptr != LIMIT)
	{
	    if (memsz > ptr->packet_size)
		memsz = ptr->packet_size;
	    ptr = ptr->next_free;
	}
    }
    _unlock();
    return -memsz;
}
memset.c/       1146129409  0     0     0       411       `
/****************************************************************************/
/*  memset v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _MEMSET

#include <string.h>

memzero.cpp/    1146129409  0     0     0       2184      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Routine to clear a block of memory.  Used to initialize arrays that
do not have constructors.

*/

#include "basics.h"
#include "runtime.h"
#pragma hdrstop
#include <string.h>

#if __EDG_BSD
/*
Declare the bzero routine because some header files on BSD systems don't
provide a declaration.  Also, the minimal headers provided in the
release include directory don't declare bzero.
*/
EXTERN_C void bzero(void*, int);
#endif /* __EDG_BSD */

EXTERN_C void __memzero(void    *buffer,
                        size_t	size)
/*
Initialize a block of memory.
*/
{
#if __EDG_BSD
  bzero(buffer, size);
#else /* !__EDG_BSD */
  memset(buffer, 0, size);
#endif /* __EDG_BSD */
}  /* __memzero */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

memzero.h/      1146129409  0     0     0       1680      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Declaration for __memzero.

*/

#ifndef MEMZERO_H
#define MEMZERO_H

#include "runtime.h"

EXTERN_C void __memzero(void    *buffer,
                        size_t	size);

#endif /* ifndef MEMZERO_H */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
mktime.c/       1146129409  0     0     0       4933      `
/****************************************************************************/
/*  mktime v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <limits.h>

static _DATA_ACCESS const unsigned int mon_len[] =
	{31,28,31,30,31,30,31,31,30,31,30,31 };
static _DATA_ACCESS const unsigned int mon_day[] =
	{0,31,59,90,120,151,181,212,243,273,304,334};

#define JAN11900    (time_t)1                   
#define DAYS_IN_YR  (time_t)365     
#define SECS_IN_MIN (time_t)60 
#define MINS_IN_HR  (time_t)60 
#define HRS_IN_DAY  (time_t)24 
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR  * HRS_IN_DAY)
#define SECS_IN_YR  (DAYS_IN_YR  * SECS_IN_DAY)

/* THE FOLLOWING MACRO DETERINES IF ADDING k TO x CAUSES OVERFLOW */

#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \
                       ((unsigned)(x)       <= INT_MAX) != \
		       ((unsigned)((x)+(k)) <= INT_MAX))

#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \
                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )

_CODE_ACCESS time_t mktime(register struct tm *tptr)
{
   time_t   result;
   time_t   daycount;
   int      mdays;
   int      adjust;
    
   /*-----------------------------------------------------------------*/
   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 
			       : (tptr->tm_sec / 60);

   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);
   tptr->tm_min += adjust;
   tptr->tm_sec -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 
			       : (tptr->tm_min / 60);

   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);
   tptr->tm_hour += adjust;
   tptr->tm_min  -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 
			        : (tptr->tm_hour / 24);

   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);
   tptr->tm_mday += adjust;
   tptr->tm_hour -= adjust * 24;

   for (;;)
   {
      /*-----------------------------------------------------------------*/
      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */
      /*-----------------------------------------------------------------*/
      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 
				  : (tptr->tm_mon / 12);

      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);
      tptr->tm_year += adjust;
      tptr->tm_mon  -= adjust * 12;

      /*-----------------------------------------------------------------*/
      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */
      /*-----------------------------------------------------------------*/
      if (tptr->tm_mday <= 0)
      { 
	   tptr->tm_mon--;  
           tptr->tm_mday += mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 
		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));
	   continue;
      }

      /*-----------------------------------------------------------------*/
      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */
      /*-----------------------------------------------------------------*/
      mdays = mon_len[tptr->tm_mon] + 
		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );

      if (tptr->tm_mday > mdays) 
	{ tptr->tm_mday -= mdays; tptr->tm_mon++; }
      else break;
   }

   /*--------------------------------------------------------------------*/
   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */
   /*--------------------------------------------------------------------*/
   tptr->tm_yday = mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +
                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );

   daycount      = tptr->tm_year * DAYS_IN_YR  + 
	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;

   result        = daycount      * SECS_IN_DAY + 
	           tptr->tm_hour * SECS_IN_HR  +
	           tptr->tm_min  * SECS_IN_MIN + tptr->tm_sec;

   tptr->tm_wday  = (JAN11900 + daycount) % 7;
   tptr->tm_isdst = _tz.daylight;

   return result;
}


modf.c/         1146129409  0     0     0       2544      `
/****************************************************************************/
/*  modf   v0.11 Beta                                                    */
/*  Copyright (c) 1995-2001 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  MODF() - break into integer and fractional parts                        */
/*                                                                          */
/*  if x < -2 ^ 23 or x > 2 ^ 23, modf will return 0, and x -> memory       */
/*                                                                          */
/*  else result = x - int(x), int(x) -> memory location                     */
/*                                                                          */
/****************************************************************************/
 
 
double modf(double value, double *iptr)
{
    double mid; /* the integral part of x */
 
    /**********************************************************************/
    /* for values >2^(bits in mantissa) or values <-2^(bits in mantissa)  */
    /**********************************************************************/
 
    if (value > TWO23 || value < - TWO23 || value == 0.0)
    {
        *iptr = value;
 
        /******************************************************************/
        /* fraction = 0                                                   */
        /******************************************************************/
 
        return 0.0;
    }
    else
    {
        /******************************************************************/
	/* This will be incorrect for values larger than 32-bits.         */
        /******************************************************************/
        mid = (long) value;     /* since (long) -1.5 = -1.0 */
 
        /******************************************************************/
        /* save the integer part of value where iptr points               */
        /******************************************************************/
 
        *iptr = mid;
 
        /******************************************************************/
        /* return the fractional part of value                            */
        /******************************************************************/
 
        return (value - mid);
    }
}
new/            1146129409  0     0     0       2092      `
/*****************************************************************************/
/* new   v4.1.3                                                              */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _NEW
#define _NEW

#ifdef __EXCEPTIONS
#define THROW(throw_spec) throw(throw_spec)
#define THROW_NOTHING() throw()
#else /* !EXCEPTION_HANDLING */
#define THROW(throw_spec) /* Nothing. */
#define THROW_NOTHING() /* Nothing. */
#endif /* __EXCEPTIONS */

#include <cstdlib>      // for size_t
#include <exception>    // for exception

namespace std
{
   class bad_alloc {};
   struct nothrow_t {};
   extern const nothrow_t nothrow;
   typedef void (*new_handler)();
   new_handler set_new_handler(new_handler new_p) THROW_NOTHING();
}	

void *operator new(std::size_t size)  THROW(std::bad_alloc);
void *operator new(std::size_t size, const std::nothrow_t&)  THROW_NOTHING();
void  operator delete(void *ptr)  THROW_NOTHING();
void  operator delete(void *ptr, const std::nothrow_t&) THROW_NOTHING();
void *operator new[](std::size_t size)  THROW(std::bad_alloc);
void *operator new[](std::size_t size, const std::nothrow_t& nt_arg) THROW_NOTHING();
void  operator delete[](void *ptr) THROW_NOTHING();
void  operator delete[](void *ptr, const std::nothrow_t& nt_arg) THROW_NOTHING();
void *operator new  (std::size_t, void *ptr) THROW_NOTHING();
void *operator new[](std::size_t, void *ptr)  THROW_NOTHING();
void  operator delete  (void *ptr, void*)  THROW_NOTHING();
void  operator delete[](void *ptr, void*)  THROW_NOTHING();

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif
new_.cpp/       1146129409  0     0     0       3293      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator new();

*/

#include "basics.h"
#include "runtime.h"

/* Note that operator new is not in the std namespace. */


extern void *operator new(size_t size) THROW(STD_NAMESPACE::bad_alloc)
/*
Allocate the specified memory size from free store.  If the allocation fails,
call *_new_handler() if defined (non-NULL pointer), and try the allocation
again.  The new_handler is permitted to
	- cause more memory to be available,
	- throw an exception, or
	- call exit or abort.

If the size passed by the caller is zero, it is incremented to one
because the behavior of malloc is unspecified when size is zero.
In C++, a call of operator new(0) must return a value distinct from other
calls of operator new.
*/
{
  void *ptr;

  if (size == 0) size = 1;
  while ((ptr = (void *)malloc(size)) == NULL) {
    /* The allocation failed -- call the current new handler routine.  Use
       the routine pointed to by _new_handler.  If this value is NULL, use
       the default new handler. */
    STD_NAMESPACE::new_handler	new_handler;
    new_handler = _new_handler != NULL ? _new_handler : __default_new_handler;
    (*new_handler) ();
#if !EXCEPTION_HANDLING
    /* A new handler is supposed to make more memory available, or to exit
       via an exception or by calling abort() or exit().  In order to support
       implementations without exception handling, the older protocol of
       returning a NULL value is supported by the default new handler.
       If the default new handler is being used, and exceptions are not
       enabled, return a NULL pointer. */
    if (new_handler == (STD_NAMESPACE::new_handler)__default_new_handler) {
      return (void *)NULL;
    }  /* if */
#endif /* EXCEPTION_HANDLING */
  }  /* while */
  return ptr;
}  /* operator new */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/


newhandler.cpp/ 1146129409  0     0     0       2112      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ default new handler.

*/

#include "basics.h"
#include "runtime.h"

extern void __default_new_handler(void)
/*
The default new handler routine that is called when operator new cannot
allocate memory.  When exceptions are enabled, this routine simply throws
a bad_alloc exception.  When exceptions are not enabled, we simply return
to the caller, which detects that the default new handler is being used
and returns a NULL pointer to the caller.
*/
{
#if EXCEPTION_HANDLING
  throw STD_NAMESPACE::bad_alloc();
#else /* !EXCEPTION_HANDLING */
  return;
#endif /* EXCEPTION_HANDLING */
}  /* __default_new_handler */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/



newnothrow.cpp/ 1146129409  0     0     0       4100      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator new() that does not throw an exception.

*/

#include "basics.h"
#include "runtime.h"

extern "C" STD_NAMESPACE::new_handler _new_handler;

/* Note that operator new is not in the std namespace. */

static a_boolean call_new_handler()
/*
Call the new handler routine.  If exception handling is supported, wrap
the call in a try block to see if the new handler throws a bad_alloc
exception.
*/
{
  a_boolean	done = FALSE;
  /* The allocation failed -- call the current new handler routine.  Use
     the routine pointed to by _new_handler.  If this value is NULL, use
     the default new handler. */
  STD_NAMESPACE::new_handler  new_handler;
  new_handler = _new_handler != NULL ? _new_handler : __default_new_handler;
#if EXCEPTION_HANDLING
  try {
    (*new_handler) ();
  }
  catch (STD_NAMESPACE::bad_alloc) {
    done = TRUE;
  }
#else /* !EXCEPTION_HANDLING */
  (*new_handler) ();
  /* A new handler is supposed to make more memory available, or to exit
     via an exception or by calling abort() or exit().  In order to support
     implementations without exception handling, the older protocol of
     returning a NULL value is supported by the default new handler.
     If the default new handler is being used, and exceptions are not
     enabled, return a NULL pointer. */
  if (new_handler == (STD_NAMESPACE::new_handler)__default_new_handler) {
    done = TRUE;
  }  /* if */
#endif /* EXCEPTION_HANDLING */
  return done;
}  /* call_new_handler */


void *operator new(size_t size, const STD_NAMESPACE::nothrow_t&)
THROW_NOTHING()
/*
Allocate the specified memory size from free store.  If the allocation fails,
call *_new_handler() if defined (non-NULL pointer), and try the allocation
again.  The new_handler is permitted to
	- cause more memory to be available,
	- throw an exception, or
	- call exit or abort.

If the size passed by the caller is zero, it is incremented to one
because the behavior of malloc is unspecified when size is zero.
In C++, a call of operator new(0) must return a value distinct from other
calls of operator new.
*/
{
  void *ptr;

  if (size == 0) size = 1;
  while ((ptr = (void *)malloc(size)) == NULL) {
    if (_new_handler != NULL) {
      /* Call the new handler.  The call_new_handler will return TRUE if
         a NULL pointer should be returned to the caller. */
      if (call_new_handler()) return (void*)NULL;
    } else {
      /* There is no new handler -- Just return a NULL. */
      return (void *)NULL;
    }  /* if */
  }  /* while */
  return ptr;
}  /* operator new */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
perror.c/       1146129409  0     0     0       2043      `
/*****************************************************************************/
/*  PERROR.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PERROR   -  Report any system errors to stderr                         */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>


/*****************************************************************************/
/* PERROR   -  Report any system errors to stderr                            */
/*****************************************************************************/
_CODE_ACCESS void perror(const char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *buf;

   /*------------------------------------------------------------------------*/
   /* If _s is not NULL, prepend it to any error message.                    */
   /*------------------------------------------------------------------------*/
   if (_s && *_s)
   {
      fputs(_s, stderr);
      fputs(": ", stderr);
   }

   switch(errno)
   {
      case 0      :  buf = "No error";                  break;
      case EDOM   :  buf = "Domain error";              break;
      case ERANGE :  buf = "Range error";               break;
      case ENOENT :  buf = "No such file or directory"; break;
      case EFPOS  :  buf = "File positioning error";    break;
      default     :  buf = "Unknown error";             break;
   }

   fputs(buf, stderr);
   fputc('\n', stderr);
}


placedel.cpp/   1146129409  0     0     0       1798      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

/*

C++ operator delete(size_t, void*);

*/

#include "basics.h"
#include "runtime.h"

#if ABI_CHANGES_FOR_PLACEMENT_DELETE

void operator delete(void *, void *) THROW_NOTHING()
/*
Placement operator delete -- does nothing.
*/
{
}  /* operator delete (size_t, void*) */

#endif /* ABI_CHANGES_FOR_PLACEMENT_DELETE */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
placenew.cpp/   1146129409  0     0     0       1815      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ operator new(size_t, void*);

*/

#include "basics.h"
#include "runtime.h"

#if DEFINE_PLACEMENT_NEW_ROUTINES

void *operator new(size_t, void *ptr) THROW_NOTHING()
/*
Return the value of ptr as the address of the new object.
*/
{
  return ptr;
}  /* operator new (size_t, void*) */

#endif /* DEFINE_PLACEMENT_NEW_ROUTINES */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

pow.c/          1146129409  0     0     0       2437      `
/****************************************************************************/
/*  pow    v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

double _log(double x);                 /* Like log() with no error checking */

/****************************************************************************/
/*  POW() - Power							    */
/*									    */
/*  z = mantissa x							    */
/*  log2(z) = c1 * z ^ 9 + c2 * z ^ 7 + c3 * z ^ 5 + c4 * z ^ 3 + c5 * z    */
/*  log2(x) = exponent x + log2(z)					    */
/*  a = y * log2(x)							    */
/*  b = mantissa a							    */
/*  2 ^ b =  (((((d1 * b + d2) * b + d3) * b + d4) * b + d5) * b + d6)	    */
/*									    */
/*  result = 2 ^ exponent a * 2 ^ b					    */
/*	   = 2 ^ (y * log2(x))						    */
/****************************************************************************/
double pow(double x, double y)
{
    int z;

    if (x && y && y != 1.0)
    {
        int sign = 0;
	if (x < 0.0)
	{
	    z = (int) y;

	    /*****************************************************************/
	    /* if y is not an integer, a domain error occurs                 */
	    /*****************************************************************/
	    if (y - z) { errno = EDOM; return 0.0; }

	    /*****************************************************************/
	    /* if x < 0, compute the power of |x|                            */
	    /*****************************************************************/
	    x = -x;

	    /*****************************************************************/
	    /* for odd exponents, negate the answer                          */
	    /*****************************************************************/
	    sign = z % 2; 
	}

	x = exp(_log(x) * y);

	return (sign) ? -x : x;
    }

    if (y == 1.0) return (x);

    /**************************************************************************/
    /* if x = 0 and y < 0, return a domain error                              */
    /**************************************************************************/
    if (x == 0.0 && y <= 0.0) { errno = EDOM; return (0.0); }

    return (y == 0.0) ? 1.0 : 0.0;
}

printf.c/       1146129409  0     0     0       2875      `
/*****************************************************************************/
/*  PRINTF.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PRINTF   -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 

/*****************************************************************************/
/* PRINTF   -  Print formatted output to stdio                               */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int printf(const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)stdout, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


prolog.asm/     1146129409  0     0     0       618       `
;******************************************************************************
;* PROLOG  v4.1.3                                                              *
;* Copyright (c) 2001-2006 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* PROLOG28.ASM
;****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "prolog28.inc"
        .endif
prolog28.inc/   1146129409  0     0     0       2436      `
;*****************************************************************************
;* PROLOG CODE FOR C28X v4.1.3                                                *
;* Copyright (c) 2001-2006 Texas Instruments Incorporated                    *
;*****************************************************************************

;*****************************************************************************
;* PROLOG CODE IF NO FRAME IS NEEDED                                         *
;* 1. PUSH SOE REGISTERS                                                     *
;* 2. RETURN                                                                 *
;*****************************************************************************
	.sect	".text"
	.global	_prolog_c28x_1

_prolog_c28x_1:	.asmfunc
	MOVL	*SP++,XAR1
	MOVL	*SP++,XAR2
	MOVL	*SP++,XAR3
	FFCRET	*XAR7
	.endasmfunc

;*****************************************************************************
;* PROLOG CODE IF FRAME IS NEEDED                                            *
;* 1. PUSH SOE REGISTERS                                                     *
;* 2. ADD FRAME TO SP                                                        *
;* 3. RETURN                                                                 *
;*****************************************************************************
	.sect	".text"
	.global	_prolog_c28x_2

_prolog_c28x_2:	.asmfunc
	MOVL	*SP++,XAR1
	MOVL	*SP++,XAR2
	MOVL	*SP++,XAR3
	MOV	PL,SP
	ADDUL	P,XAR0
	MOV	SP,P
	FFCRET	*XAR7
	.endasmfunc

;*****************************************************************************
;* PROLOG CODE IF FRAME IS NEEDED AND FRAME POINTER (XAR2)                   *
;* 1. PUSH SOE REGISTERS                                                     *
;* 2. SAVE SP TO FP                                                          *
;* 3. ADD FRAME TO SP                                                        *
;* 4. SUBTRACT OFFSET FROM FP                                                *
;* 5. RETURN                                                                 *
;*****************************************************************************
	.sect	".text"
	.global	_prolog_c28x_3

_prolog_c28x_3:	.asmfunc
	MOVL	*SP++,XAR1
	MOVL	*SP++,XAR2
	MOVL	*SP++,XAR3
	MOVZ	AR2,SP
	MOV	PL,SP
	ADDUL	P,XAR0
	MOV	SP,P
	MOVL	P,XAR2
	SUBUL	P,XAR6
	MOVL	XAR2,P
	FFCRET	*XAR7
	.endasmfunc
pure_virt.cpp/  1146129409  0     0     0       2154      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ runtime routine __pure_virtual_called() -- called when the user
calls a pure virtual function.  This function simply aborts the program.

*/

#include "basics.h"
#include "runtime.h"

#ifdef __EDG_IA64_ABI
#define PURE_VIRTUAL_FUNCTION_NAME __cxa_pure_virtual
#else /* !defined(__EDG_IA64_ABI) */
#define PURE_VIRTUAL_FUNCTION_NAME __pure_virtual_called
#endif /* !defined(__EDG_IA64_ABI) */

extern "C" {
	void PURE_VIRTUAL_FUNCTION_NAME(void);
}


void PURE_VIRTUAL_FUNCTION_NAME(void)
/*
Notify the user that a call to a pure virtual function has been made and
abort the program.
*/
{
  __abort_execution(ec_pure_virtual_called);
}  /* __pure_virtual */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
qsort.c/        1146129409  0     0     0       1830      `
/****************************************************************************/
/*  qsort v4.1.3                                                            */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>

static void swap_item(register char *src, 
                      register char *dest, 
                      register size_t size);

_CODE_ACCESS void qsort(void *base, size_t nmemb, size_t size, 
			int (*compar)(const void *, const void *))
{
   register char     *basep  = base;         /* POINTER TO ARRAY OF ELEMENTS */
   register unsigned  i      = 0;            /* left scan index  */
   register unsigned  j      = nmemb - 1;    /* right scan index */
   register unsigned  pivot  = (nmemb / 2);
   register char     *pivp   = basep + (pivot * size);

   if (nmemb <= 1) return;

   while( i < j )
   {
      while( (*compar) (basep + (i * size), pivp) < 0 ) ++i;
      while( (*compar) (basep + (j * size), pivp) > 0 ) --j;
      if( i < j )
      {
	 swap_item(basep + (i * size), basep + (j * size), size);
	 if     ( pivot == i ) { pivot = j; pivp = basep + (pivot * size); }
	 else if( pivot == j ) { pivot = i; pivp = basep + (pivot * size); } 
	 ++i; --j;
      }
      else if ( i == j ) { ++i; --j;  break; }
   }

   if( j > 0)       qsort(basep, j + 1, size, compar);
   if( i < nmemb-1) qsort(basep + (i * size), nmemb - i, size, compar);
}


static void swap_item(register char *src, 
                      register char *dest, 
                      register size_t size)
{
    while (size--)
    {
        register int temp = *src;       
        *src++            = *dest;
        *dest++           = temp;
    }
}

rand.c/         1146129409  0     0     0       928       `
/****************************************************************************/
/*  rand.c v4.1.3							    */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <_lock.h>

/***************************************************************/
/* THIS IS AN IMPLEMENTATION WHICH IS INTENDED TO BE PORTABLE, */
/* AS PER THE ANSI STANDARD C SPECIFICATION                    */
/***************************************************************/
static _DATA_ACCESS unsigned long next = 1;

_CODE_ACCESS int rand(void)
{
     int r;
     _lock();
     next = next * 1103515245 + 12345;
     r = (int)((next/65536) % ((unsigned long)RAND_MAX + 1));
     _unlock();
     return r;
}

_CODE_ACCESS void srand(unsigned seed)
{
     _lock();
     next = seed;
     _unlock();
}
remove.c/       1146129409  0     0     0       1012      `
/*****************************************************************************/
/*  REMOVE.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REMOVE   -  Erase a file                                               */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"


/*****************************************************************************/
/* REMOVE   -  Erase a file                                                  */
/*****************************************************************************/
_CODE_ACCESS int remove(const char *_file) { return (_remove(_file)); }

rewind.c/       1146129409  0     0     0       1080      `
/*****************************************************************************/
/*  REWIND.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REWIND   -  Position a stream's file pointer to the beginning of a     */
/*                file                                                       */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* REWIND   -  Position a stream's file pointer to the beginning of a file   */
/*****************************************************************************/
_CODE_ACCESS void  rewind(register FILE *_fp) { fseek(_fp, 0L, SEEK_SET); }


rtti.cpp/       1146129409  0     0     0       34218     `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Run-time type identification.

*/

#include "basics.h"
#include "runtime.h"
#pragma hdrstop
#include "rtti.h"

#if ABI_CHANGES_FOR_RTTI
#include <typeinfo>
#include "vtbl.h"
#endif /* ABI_CHANGES_FOR_RTTI */
#include "stdint.h"
/* Forward declaration. */
EXTERN_C void __db_type_info(const STD_NAMESPACE::type_info& info);

#ifdef __EDG_IA64_ABI

/*
Macro to extract the offset value from the combined offset/flags field.
*/
#define get_offset(bcsp) ((bcsp)->__offset_flags >>			\
                                  abi::__base_class_type_info::__offset_shift)

/*
Macros used to test for flags from the __vmi_class_tyupe_info.
*/
#define diamond_shaped(flags) \
  ((flags & abi::__vmi_class_type_info::__diamond_shaped_mask) != 0)
#define non_diamond_repeat(flags) \
  ((flags & abi::__vmi_class_type_info::__non_diamond_repeat_mask) != 0)


static a_boolean derived_to_base_conversion_r(
				void			*ptr,
				void			**p_new_ptr,
				a_type_info_impl_ptr	class_info,
				a_type_info_impl_ptr	base_info,
				unsigned int		vmi_flags,
				a_boolean		*p_is_ambiguous,
				a_boolean		is_accessible,
				a_boolean		*result_is_accessible)
/* 
Perform a derived to base conversion from ptr (the derived object, whose type
is given by class_info) to the base indicated by base_info.  If the base is
unambiguous, the address of the base is stored in *p_new_ptr, and TRUE is
returned.  On entry *p_new_ptr should be NULL, or the address of the base if
it has already been found.  is_accessible is TRUE if the current class is
accessible.  result_is_accessible is set to indicate whether the base class
that is found (if any) is accessible from the ultimately derived object.
If the base is ambiguous,  *p_is_ambiguous i set to TRUE, and FALSE is
returned.  If the base is unambiguous, but inaccessible, TRUE is returned but
result_is_accessible is set to FALSE.  vmi_flags is a bit set of flags that
are used to optimize the base class search.  These flags are passed by
the initial caller of this routine and are passed down when the routine
is called recursively.
*/
{
  a_boolean result = FALSE;

#if DEBUG
  if (__debug_level >= 4) {
    fprintf(__f_debug, "derived_to_base_conversion_r:\n");
    fprintf(__f_debug, "  conversion from:\n");
    __db_type_info(*class_info);
    fprintf(__f_debug, "  conversion to:\n");
    __db_type_info(*base_info);
  }  /* if */
#endif /* DEBUG */
  if (typeid(*class_info) == typeid(abi::__si_class_type_info)) {
    /* Single, non-virtual, public inheritance. */
    abi::__si_class_type_info *si_obj_info = 
                                       (abi::__si_class_type_info *)class_info;
    if (matching_type_info(si_obj_info->__base_type, base_info)) {
      if ((*p_new_ptr != NULL && *p_new_ptr != ptr) ||
          *p_is_ambiguous) {
        /* The base class is ambiguous. */
        *p_is_ambiguous = TRUE;
        *p_new_ptr = NULL;
        result = FALSE;
      } else {
        *result_is_accessible = is_accessible;
        *p_new_ptr = ptr;
        result = TRUE;
      }  /* if */
    } else if (derived_to_base_conversion_r(ptr, p_new_ptr,
                                            si_obj_info->__base_type,
                                            base_info, vmi_flags,
                                            p_is_ambiguous, is_accessible,
					    result_is_accessible) ||
               *p_is_ambiguous) {
      if ((*p_is_ambiguous)) {
        result = FALSE;
      } else {
        result = TRUE;
      }  /* if */
    }  /* if */
  } else if (typeid(*class_info) == typeid(abi::__vmi_class_type_info)) {
    /* Complex inheritance. */
    abi::__vmi_class_type_info *vmi_obj_info = 
                                      (abi::__vmi_class_type_info *)class_info;
    a_base_class_spec_ptr      bcsp;
    void                       *base_ptr;
    /* Loop over all of the base classes. */
    for (bcsp = vmi_obj_info->__base_info;
         bcsp < vmi_obj_info->__base_info + vmi_obj_info->__base_count;
         bcsp++) {
      a_boolean base_is_accessible;
      a_boolean	is_virtual = (bcsp->__offset_flags & BCS_VIRTUAL) != 0;
      if (ptr == NULL) {
        /* Don't try to add an offset to a NULL pointer. */
        base_ptr = NULL;
      } else if (is_virtual) {
        a_vtbl_entry_ptr vtbl, vbase_offset;
        vtbl = *((a_vtbl_entry_ptr *)ptr);
        vbase_offset = (a_vtbl_entry_ptr)(((char *)vtbl) + get_offset(bcsp));
        base_ptr = (void *)(((char *)ptr) + *vbase_offset);
      } else {
        base_ptr = (void *)(((char *)ptr) + get_offset(bcsp));
      }  /* if */
      base_is_accessible = is_accessible &&
                           (bcsp->__offset_flags & BCS_PUBLIC);
      if (matching_type_info(bcsp->__base_type, base_info)) {
        /* We found the base for which we were looking. */
        if ((*p_new_ptr != NULL && base_ptr != *p_new_ptr) || 
            *p_is_ambiguous) {
          /* The base class is ambiguous. */
          *p_is_ambiguous = TRUE;
          *p_new_ptr = NULL;
          result = FALSE;
          break;
        } else {
          /* The base class is unambiguous -- at least so far. */
          *result_is_accessible = base_is_accessible;
          *p_new_ptr = base_ptr;
          result = TRUE;
          /* We can stop searching if the vmi_flags indicate that this
             base class is known to be unique. */
          if (*result_is_accessible) {
            if (is_virtual ? !diamond_shaped(vmi_flags)
                           : !non_diamond_repeat(vmi_flags)) {
              break;
            }  /* if */
          }  /* if */
        }  /* if */
      } else if (derived_to_base_conversion_r(base_ptr, p_new_ptr,
                                              bcsp->__base_type,
                                              base_info, vmi_flags,
                                              p_is_ambiguous,
                                              base_is_accessible,
                                              result_is_accessible) ||
                 *p_is_ambiguous) {
        if ((*p_is_ambiguous)) {
          result = FALSE;
          break;
        } else {
          result = TRUE;
          /* We can stop searching if the vmi_flags indicate that this
             base class is known to be unique. */
          if (*result_is_accessible) {
            if (is_virtual ? !diamond_shaped(vmi_flags)
                           : !non_diamond_repeat(vmi_flags)) {
              break;
            }  /* if */
          }  /* if */
        } /* if */
      } /* if */
    }  /* for */
  }  /* if */
  return result;
}  /* derived_to_base_conversion_r */

#endif /* ifdef __EDG_IA64_ABI */

#ifdef __EDG_IA64_ABI
/*ARGSUSED*/ /* <-- access_flags and use_access_flags are unused in that
                    case. */
#endif /* ifdef __EDG_IA64_ABI */
EXTERN_C
a_boolean __derived_to_base_conversion(void**		     p_ptr,
		  		       void**                p_new_ptr,
				       a_type_info_impl_ptr  class_info,
				       a_type_info_impl_ptr  base_info,
				       an_access_flag_string *access_flags,
				       a_boolean             use_access_flags)
/*
Converts p_ptr from a pointer to a derived class (described by class_info)
to a pointer to a base class (described by base_info) and stores
the resulting pointer in p_new_ptr.  Returns TRUE if the base class was
found and the conversion was done; otherwise returns FALSE. 

p_ptr may be NULL when this routine is called simply to determine whether
the conversion is possible.  This is the case when exception specifications
are being tested.

The access_flags string contains one byte for each base class.  The
byte contains either "Y" (the base class is accessible) or "N" (the
base class is not accessible).  The base class may be inaccessible
either because of access protection or because the base class
is ambiguous.

use_access_flags indicates whether the access_flags string should be used
when checking for accessible (and unambiguous) bases.  If use_access_flags
is FALSE, the BCS_PUBLIC and BCS_AMBIGUOUS flags in the base class entry
are used.  These flags were added when RTTI was implemented in version 2.29.
The access_flags string was retained for backward compatibility.
*/
{
  a_boolean		result = FALSE;
  void                  *ptr;
  a_boolean		is_ambiguous = FALSE;
#ifdef __EDG_IA64_ABI
  a_boolean             result_is_accessible = TRUE;
#else /* !defined(__EDG_IA64_ABI) */
  a_base_class_spec_ptr	bcsp;
#endif /* !defined(__EDG_IA64_ABI) */
  /* Get the actual derived class pointer.  If no pointer was provided,
     use NULL. */
  ptr = p_ptr == NULL ? NULL : *p_ptr;
  *p_new_ptr = NULL;
#ifndef __EDG_IA64_ABI
  bcsp = class_info->base_class_entries;
  if (bcsp != NULL) {
    /* A base class list is present. */
    a_boolean	done = FALSE;
    /* Loop through the direct base classes and look for one that matches
       the specified base class.  We look through all of the direct bases
       first because the direct base list also includes any virtual bases.
       We want to make sure that we find the virtual base classes at
       the top level when possible. */
    do {
      void*		   new_ptr = NULL;
      a_type_info_impl_ptr test_info = bcsp->type_info;
      a_boolean            is_accessible;
      if (ptr != NULL) {
        /* Adjust the pointer by the offset provided in the base class
           specification. */
        new_ptr = (void*) (((char *) ptr) + bcsp->offset);
      }  /* if */
      if (use_access_flags) {
        /* See if this base class is accessible.  *access_flags either points
           to a string of characters associated with each base class in the
  	   tree, or is NULL if none of the base classes are accessible. */
        if (*access_flags != NULL) {
          is_accessible = **access_flags == BASE_ACCESSIBLE;
          (*access_flags)++;
        } else {
          is_accessible = FALSE;
        }  /* if */
      } else {
        /* The base is accessible if it is public and not ambiguous. */
        is_accessible = ((bcsp->flags & BCS_PUBLIC) != 0);
      }  /* if */
      if (matching_type_info(test_info, base_info)) {
        /* If the base class is ambiguous, stop the search but don't
           consider the conversion "successful".  The BCS_AMBIGUOUS flag is
           only used with ABI versions >= 2.29.  In previous versions of
           the ABI, ambiguous bases were indicated by marking all
           instances of the base as inaccessible in the access
           string. */
        is_ambiguous = ((bcsp->flags & BCS_AMBIGUOUS) != 0);
        if (!is_ambiguous && is_accessible) {
          result = TRUE;
          if (ptr != NULL) {
            if (bcsp->flags & BCS_VIRTUAL) {
              /* If this is a virtual base class then the offset provides the
                 location of a pointer to the base class.  Dereference the
                 pointer and return that value. */
              *p_new_ptr = *((void **)new_ptr);
            } else {
              /* A nonvirtual base class.  new_ptr has already been
                 adjusted to point to the start of the base class.
                 Return this value to the caller. */
              *p_new_ptr = new_ptr;
            }  /* if */
          }  /* if */
        }  /* if */
      }  /* if */
      /* The last entry in the array will have the BCS_LAST flag set. */
      done = bcsp->flags & BCS_LAST || result || is_ambiguous;
      /* Advance the pointer to the next element in the array of base
         class specifications. */
      bcsp++;
    } while (!done);
    if (!result && !is_ambiguous) {
      /* The specified base class is not one of the direct or virtual bases.
         Search the indirect base classes. */
      bcsp = class_info->base_class_entries;
      do {
        void*		     new_ptr = NULL;
        a_type_info_impl_ptr test_info = bcsp->type_info;
	a_boolean            is_accessible;
	if (ptr != NULL) {
	  /* Adjust the pointer by the offset provided in the base class
	     specification. */
	  new_ptr = (void*) (((char *) ptr) + bcsp->offset);
          if (bcsp->flags & BCS_VIRTUAL) {
            /* If this is a virtual base class then the offset provides the
               location of a pointer to the base class.  Dereference the
               pointer and use that value. */
            new_ptr = *((void **)new_ptr);
          }  /* if */
	}  /* if */
        /* This is not the base class we are looking for.  Look at the
           base classes of this base class. */
        if (use_access_flags) {
          /* When using access strings, a base class further up in the
             derivation tree may be accessible even if this class is not.
             Always call the derived_to_base_conversion routine and let
             it check the access flag.  This is done by setting the
	     is_accessible flag to TRUE at this level. */
          is_accessible = TRUE;
        } else {
          /* When using the newer access flags in the base class entry
             (instead of the access flag string) don't look into 
             inaccessible or ambiguous bases. */
          is_accessible = ((bcsp->flags & BCS_PUBLIC) != 0) &&
                          ((bcsp->flags & BCS_AMBIGUOUS) == 0);
        }  /* if */
        if (test_info->base_class_entries != NULL && is_accessible) {
          /* This base class has its own bases.  Call this routine
             recursively. */
	  void* local_new_ptr;
          if (__derived_to_base_conversion(&new_ptr, &local_new_ptr, test_info,
					   base_info, access_flags,
                                           use_access_flags)) {
	    if (ptr != NULL) {
	      /* We have found a match.  Update the pointer passed to us
		 to reflect the value found by the recursive call. */
	      *p_new_ptr = local_new_ptr;
	    }  /* if */
            result = TRUE;
            break;
          }  /* if */
        }  /* if */
        /* The last entry in the array will have the BCS_LAST flag set. */
        done = (bcsp->flags & BCS_LAST) != 0;
        /* Advance the pointer to the next element in the array of base
           class specifications. */
        bcsp++;
      } while (!done);
    }  /* if */
  }  /* if */
#else /* defined(__EDG_IA64_ABI) */
  {
    int	vmi_flags;
    /* If the type information is represented by the VMI form of type_info,
       get the flags that are used to optimize the base class search.
       Otherwise, use the safe value of having both flags set. */
    if (typeid(*class_info) == typeid(abi::__vmi_class_type_info)) {
      abi::__vmi_class_type_info *vmi_obj_info = 
                                      (abi::__vmi_class_type_info *)class_info;
      vmi_flags = vmi_obj_info->__flags;
    } else {
      vmi_flags = abi::__vmi_class_type_info::__non_diamond_repeat_mask |
                  abi::__vmi_class_type_info::__diamond_shaped_mask;
    }  /* if */
    if (derived_to_base_conversion_r(ptr, p_new_ptr, class_info, base_info,
                                     vmi_flags, &is_ambiguous,
                                     /*is_accessible=*/TRUE,
                                     &result_is_accessible) &&
        result_is_accessible) {
      result = TRUE;
    }  /* if */
  }
#endif /* defined(__EDG_IA64_ABI) */
  return result;
}  /* __derived_to_base_conversion */


static a_base_class_spec_ptr find_base_class_at_addr(
					void			*obj_ptr,
					void			*base_ptr,
					a_type_info_impl_ptr	obj_info,
					a_type_info_impl_ptr	base_info,
                                        a_boolean               *found)
/*
Find the base class specification entry that corresponds to the base
class pointed to by "base_ptr", whose type is specified by "base_info"
in the object pointed to by "obj_ptr".  The base class must be accessible,
but need not be unambiguous.  *found should be initialized to FALSE before
this function is called; it is set to TRUE If the base class is found.
*/
{
  a_base_class_spec_ptr	bcsp;
  void                  *ptr;
  void                  *new_ptr;
  a_base_class_spec_ptr	result = NULL;
#ifndef __EDG_IA64_ABI
  a_boolean		done;
#endif /* ifndef __EDG_IA64_ABI */

  ptr = obj_ptr;
#ifdef __EDG_IA64_ABI
#if DEBUG
  if (__debug_level >= 4) {
    fprintf(__f_debug, "find_base_class_at_addr:\n");
    fprintf(__f_debug, "  looking in:\n");
    __db_type_info(*obj_info);
    fprintf(__f_debug, "  for base class:\n");
    __db_type_info(*base_info);
  }  /* if */
#endif /* DEBUG */
  if (typeid(*obj_info) == typeid(abi::__si_class_type_info)) {
    abi::__si_class_type_info *si_obj_info = 
                                      (abi::__si_class_type_info *)obj_info;
    if (ptr == base_ptr && 
        matching_type_info(si_obj_info->__base_type, base_info)) {
      /* The current class is the one we are looking for. */
      *found = TRUE;
    } else {
      /* The current class is not the one we are looking for.  Check its
         base class. */
      result = find_base_class_at_addr(ptr, base_ptr,
                                       si_obj_info->__base_type,
                                       base_info, found);
    }  /* if */
  } else if (typeid(*obj_info) == typeid(abi::__vmi_class_type_info)) {
    abi::__vmi_class_type_info *vmi_obj_info = 
                                     (abi::__vmi_class_type_info *)obj_info;
    for (bcsp = vmi_obj_info->__base_info;
         bcsp < vmi_obj_info->__base_info + vmi_obj_info->__base_count;
         bcsp++) {
      if (bcsp->__offset_flags & BCS_VIRTUAL) {
        a_vtbl_entry_ptr vtbl, vbase_offset;
        vtbl = *((a_vtbl_entry_ptr *)ptr);
        vbase_offset = (a_vtbl_entry_ptr)(((char *)vtbl) + get_offset(bcsp));
        new_ptr = (void *)(((char *)ptr) + *vbase_offset);
      } else {
        new_ptr = (void *)(((char *)ptr) + get_offset(bcsp));
      }  /* if */
      if (new_ptr == base_ptr &&
          matching_type_info(bcsp->__base_type, base_info)) {
        /* We found a match.  Note that both the address and type must match
           because base classes can share an address. */
        result = bcsp;
        if (bcsp->__offset_flags & BCS_PUBLIC) *found = TRUE;
        break;
      }  /* if */
      if ((bcsp->__offset_flags & BCS_PUBLIC) != 0) {
        /* No match, check the base classes of this base class. */
        result = find_base_class_at_addr(new_ptr, base_ptr,
                                         bcsp->__base_type, base_info,
                                         found);
        /* Exit if the recursive call found a match. */
        if (*found) break;
      }  /* if */
    }  /* for */
  }  /* for */
#else /* !defined(__EDG_IA64_ABI) */
  for (done = FALSE, bcsp = obj_info->base_class_entries;
       bcsp != NULL && !done; done = (bcsp->flags & BCS_LAST) != 0, bcsp++) {
    /* Adjust the pointer by the offset provided in the base class
       specification. */
    new_ptr = (void*) (((char *) ptr) + bcsp->offset);
    if (bcsp->flags & BCS_VIRTUAL) {
      /* If this is a virtual base class then the offset provides the
         location of a pointer to the base class.  Dereference the
         pointer and use that value. */
      new_ptr = *((void **)new_ptr);
    }  /* if */
    if (new_ptr == base_ptr &&
        matching_type_info(bcsp->type_info, base_info)) {
      /* We found a match.  Note that both the address and type must match
         because base classes can share an address. */
      result = bcsp;
      if (bcsp->flags & BCS_PUBLIC) *found = TRUE;
      break;
    }  /* if */
    if ((bcsp->flags & BCS_PUBLIC) != 0) {
      /* No match, check the base classes of this base class. */
      result = find_base_class_at_addr(new_ptr, base_ptr,
                                       bcsp->type_info, base_info,
                                       found);
      /* Exit if the recursive call found a match. */
      if (result != NULL) break;
    }  /* if */
  }  /* for */
#endif /* !defined(__EDG_IA64_ABI) */
  return result;
}  /* find_base_class_at_addr */

#if ABI_CHANGES_FOR_RTTI

#ifdef __EDG_IA64_ABI
/*ARGSUSED*/ /* <-- hint is not used in that case. */
#endif /* __EDG_IA64_ABI */
EXTERN_C void *__dynamic_cast(void			*class_ptr,
#ifndef __EDG_IA64_ABI
			      a_vtbl_entry_ptr		vtbl_ptr,
		              a_type_info_impl_ptr	tiip
#if ABI_COMPATIBILITY_VERSION >= 241
			    , void			*source_ptr,
			      a_type_info_impl_ptr	source_tiip
#endif /* ABI_COMPATIBILITY_VERSION >= 241 */
#else /* defined(__EDG_IA64_ABI) */
                              a_type_info_impl_ptr      source_tiip,
                              a_type_info_impl_ptr      tiip,
                              __EDG_DELTA_TYPE          hint
#endif /* defined(__EDG_IA64_ABI) */
                              )
/*
Runtime support for dynamic_cast operations.  This routine handles

  - casts of a polymorphic objects type to void*, which is defined as
    returning a pointer to the complete object type

  - polymorphic base to derived casts

  - polymorphic cross casts

class_ptr is the source operand of the cast.  If the source is
an object (and not a pointer) then a pointer to the source operand
is used.  vtbl_ptr is a pointer to the virtual function table from
the source operand.  tiip is a pointer to the type_info_impl
structure associated with the destination type.  If the source
operand is being cast to void*, tiip will be NULL.

source_ptr is the original pointer being cast.  It is different from
class_ptr if the original type did not have a virtual function table
associated with it.  source_tiip is the type info pointer for the static
type of the pointer being cast.  These parameters are used to check the
access of the base class associated with the pointer being cast.

The information about the dynamic type of the source object is obtained
from entry zero of the virtual function table.

Entry zero of the virtual function table is organized differently than the
other table entries.  The information in that entry is provided to support
the dynamic_cast and typeinfo operations.  Entry zero contains the
following information:

	delta:		The offset from the complete object pointer to
			class_ptr (i.e., the value to be subtracted from
			class_ptr to get the complete object pointer.

	index:		Unused.

	function:	Pointer to the typeinfo_impl structure that
		        for the dynamic type of class_ptr.
*/
{
  void			*complete_object_ptr;
#ifndef __EDG_IA64_ABI
  size_t		offset_to_complete_object;
#else /* defined(__EDG_IA64_ABI) */
  void                  *source_ptr = class_ptr;
#endif /* defined(__EDG_IA64_ABI) */
  a_type_info_impl_ptr	object_tiip;
  void			*result = NULL;

  /* Get a pointer to the complete object. */
#ifndef __EDG_IA64_ABI
  offset_to_complete_object = vtbl_ptr->delta;
  complete_object_ptr =
                     (void*)(((char *)class_ptr) - offset_to_complete_object);
#else /* defined(__EDG_IA64_ABI) */
  complete_object_ptr = 
    (void *)(((char *)class_ptr) + (*((a_vtbl_entry_ptr *)class_ptr))[-2]);
#endif /* defined(__EDG_IA64_ABI) */
#if DEBUG
  if (__debug_level >= 3) {
    fprintf(__f_debug, "dynamic_cast: orig ptr=%p, complete obj=%p\n",
            class_ptr, complete_object_ptr);
  }  /* if */
#endif /* DEBUG */
  /* Get the pointer to the type_info associated with the source object.  */
#ifndef __EDG_IA64_ABI
  /* This is stored in the function pointer field of the vtbl entry. */
#if 1
  object_tiip = (a_type_info_impl_ptr) (intptr_t) vtbl_ptr->func;
#else
  object_tiip = (a_type_info_impl_ptr) vtbl_ptr->function.type_info_impl;
#endif
#else /* defined(__EDG_IA64_ABI) */
   /* In the IA-64 ABI, this is stored in the -1 entry of the vtable. */
  object_tiip = (a_type_info_impl_ptr)((*((a_vtbl_entry_ptr *)class_ptr))[-1]);
#endif /* defined(__EDG_IA64_ABI) */
  if (tiip == NULL) {
    /* When tiip is NULL, the pointer is being cast to void*.  This
       means that class_ptr is to be converted to a pointer to the
       complete object type. */
    result = complete_object_ptr;
  } else {
    a_boolean	access_okay = TRUE;
#if ABI_COMPATIBILITY_VERSION >= 241
    /* Before doing the conversion, find the base class pointed to by the
       source pointer.  Make sure this points to an accessible base class.
       find_base_class_at_addr will return NULL if the base class is an
       indirect base class of a private base class.  It will return a pointer
       to the base class entry if it is a base class of an accessible
       base class (or if it is a direct base class).  Check the returned base
       class entry to make sure the base class is public.  The conversions
       that follow are done only if the source class is a public base class. */
    if (object_tiip == source_tiip) {
      /* The static type of the source is the same as the dynamic type. */
      access_okay = TRUE;
    } else {
      access_okay = FALSE;
      (void)find_base_class_at_addr(complete_object_ptr, source_ptr,
                                    object_tiip, source_tiip, &access_okay);
    }  /* if */
#endif /* ABI_COMPATIBILITY_VERSION >= 241 */
    if (access_okay) {
      if (matching_type_info(object_tiip, tiip)) {
        /* The object is being cast to the type it actually is.  For example,
           a Base* that actually points to a Derived is being cast to a
           Derived*.  Simply return the complete object pointer. */
        result = complete_object_ptr;
      } else {
        /* The object is being cast to one of its base classes. */
        a_boolean	conversion_done;
        void		*new_ptr = NULL;
        conversion_done = __derived_to_base_conversion(
                               &complete_object_ptr, &new_ptr,
			       object_tiip, tiip,
			       (an_access_flag_string*)NULL,
			       /*use_access_flags=*/FALSE);
        if (conversion_done) result = new_ptr;
      }  /* if */
    }  /* if */
  }  /* if */
  return result;
}  /* __dynamic_cast */

#ifdef __EDG_IA64_ABI
#define BAD_CAST_ROUTINE_NAME ABI_NAMESPACE::__cxa_bad_cast
#define BAD_CAST_ROUTINE_LINKAGE /*extern*/
#else /* !defined(__EDG_IA64_ABI) */
#define BAD_CAST_ROUTINE_NAME __throw_bad_cast
#define BAD_CAST_ROUTINE_LINKAGE static
#endif /* !defined(__EDG_IA64_ABI) */ 

BAD_CAST_ROUTINE_LINKAGE
void BAD_CAST_ROUTINE_NAME(void)
/*
Throw a bad cast exception.  If exception handling is not supported in
this version of the runtime, then simply abort.
*/
{
#if EXCEPTION_HANDLING
  throw STD_NAMESPACE::bad_cast();
#else /* !EXCEPTION_HANDLING */
  __abort_execution(ec_bad_cast);
#endif /* EXCEPTION_HANDLING */
}  /* BAD_CAST_ROUTINE_NAME */


#ifdef __EDG_IA64_ABI
#define BAD_TYPEID_ROUTINE_NAME ABI_NAMESPACE::__cxa_bad_typeid
#else /* !defined(__EDG_IA64_ABI) */
#define BAD_TYPEID_ROUTINE_NAME __throw_bad_typeid
#endif /* !defined(__EDG_IA64_ABI) */

EXTERN_C void BAD_TYPEID_ROUTINE_NAME(void)
/*
Throw a bad typeid exception.  If exception handling is not supported in
this version of the runtime, then simply abort.
*/
{
#if EXCEPTION_HANDLING
  throw STD_NAMESPACE::bad_typeid();
#else /* !EXCEPTION_HANDLING */
  __abort_execution(ec_bad_typeid);
#endif /* EXCEPTION_HANDLING */
}  /* BAD_TYPEID_ROUTINE_NAME */

#ifndef __EDG_IA64_ABI

EXTERN_C void *__dynamic_cast_ref(void                  *class_ptr,
			          a_vtbl_entry_ptr      vtbl_ptr,
			          a_type_info_impl_ptr  tiip
#if ABI_COMPATIBILITY_VERSION >= 241
			        , void			*source_ptr,
			          a_type_info_impl_ptr	source_tiip
#endif /* ABI_COMPATIBILITY_VERSION >= 241 */
                                  )
/*
Interface to __dynamic_cast used when casting references.  This calls
__dynamic_cast and throws an exception if the cast failed.
*/
{
  void*		result;

  result = __dynamic_cast(class_ptr, vtbl_ptr, tiip
#if ABI_COMPATIBILITY_VERSION >= 241
                          , source_ptr, source_tiip
#endif /* ABI_COMPATIBILITY_VERSION >= 241 */
                         );
  if (result == NULL) {
    __throw_bad_cast();
  }  /* if */
  return result;
}  /* __dynamic_cast_ref */


EXTERN_C void *__get_typeid(a_vtbl_entry_ptr	vtbl_ptr)
/*
Return the user type_info pointer from the specified virtual function
table.  If the pointer to the vtable is NULL, throw a bad_typeid
exception.
*/
{
  a_type_info_impl_ptr	tiip;

  if (vtbl_ptr == NULL) __throw_bad_typeid();
  /* Get the pointer to the type_info_impl associated with the source object. 
     This is stored in the function pointer field of the vtbl entry. */
#if 1
  tiip = (a_type_info_impl_ptr)(intptr_t)vtbl_ptr->func;
#else
  tiip = (a_type_info_impl_ptr)vtbl_ptr->function.type_info_impl;
#endif
  /* Return the address of the user type_info. */
  return (void*)&tiip->user_type_info;
}  /* __get_typeid */


#if DEBUG
EXTERN_C void __r_db_type_info(const STD_NAMESPACE::type_info&	info,
                               int				indent)
/*
Display debugging information about type information (non-IA-64 version).
*/
{
/* Define a macro used to indent the output lines. */
#define do_indent() fprintf(__f_debug, "%*s", indent, " ")
  /* Convert the user type_info pointer to a_info_impl_ptr. */
  a_type_info_impl_ptr	tiip = (a_type_info_impl_ptr)&info;
  if (indent != 0) fprintf(__f_debug, "\n");
  do_indent();
  fprintf(__f_debug, "Type information for: %s\n",
          tiip->name == NULL ? "<NULL>" : tiip->name);
  do_indent();
  fprintf(__f_debug, "  unique_id: %p\n", (void*)tiip->unique_id);
#if ABI_COMPATIBILITY_VERSION <= 237
  do_indent();
  fprintf(__f_debug, "  dtor addr: %p\n", (void*)tiip->destructor);
#endif /* ABI_COMPATIBILITY_VERSION <= 237 */
  if (tiip->base_class_entries != NULL) {
    a_base_class_spec_ptr	bcsp;
    do_indent();
    fprintf(__f_debug, "  base classes:\n");
    for (bcsp = tiip->base_class_entries;; bcsp++) {
      const char	*name = bcsp->type_info->name;
      do_indent();
      fprintf(__f_debug, "    name=%s\n", name == NULL ? "<NULL>" : name);
      do_indent();
      fprintf(__f_debug, "    offset=%0ld\n", (long)bcsp->offset);
      do_indent();
      fprintf(__f_debug, "    flags:");
      if (bcsp->flags & BCS_VIRTUAL) fprintf(__f_debug, " virtual");
      if (bcsp->flags & BCS_LAST) fprintf(__f_debug, " last");
      if (bcsp->flags & BCS_PUBLIC) fprintf(__f_debug, " public");
      if (bcsp->flags & BCS_AMBIGUOUS) fprintf(__f_debug, " ambiguous");
      if (bcsp->flags & BCS_DIRECT) fprintf(__f_debug, " direct");
      fprintf(__f_debug, "\n");
      if (bcsp->flags & BCS_LAST) break;
    }  /* for */
    /* Now display the full type information for the base classes. */
    for (bcsp = tiip->base_class_entries;; bcsp++) {
      __r_db_type_info(bcsp->type_info->user_type_info, indent + 2);
      if (bcsp->flags & BCS_LAST) break;
    }  /* for */
  }  /* if */
#undef do_indent
}  /* __r_db_type_info */


EXTERN_C void __db_type_info(const STD_NAMESPACE::type_info& info)
/*
Display debugging information about type information.  This routine
calls __r_db_type_info and supplies a zero indent value.
*/
{
  __r_db_type_info(info, 0);
  fprintf(__f_debug, "\n");
}  /* __db_type_info */
#endif /* DEBUG */

#else /* ifdef IA64_ABI */

#if DEBUG
EXTERN_C void __r_db_type_info(const STD_NAMESPACE::type_info&	info,
                               int				indent)
/*
Display debugging information about type information (IA-64 version).
*/
{
/* Define a macro used to indent the output lines. */
#define do_indent() fprintf(__f_debug, "%*s", indent, " ")
  if (indent != 0) fprintf(__f_debug, "\n");
  do_indent();
  fprintf(__f_debug, "Type information for: %s\n", info.name());
#undef do_indent
}  /* __r_db_type_info */


EXTERN_C void __db_type_info(const STD_NAMESPACE::type_info& info)
/*
Display debugging information about type information.  This routine
calls __r_db_type_info and supplies a zero indent value.
*/
{
  __r_db_type_info(info, 0);
  fprintf(__f_debug, "\n");
}  /* __db_type_info */
#endif /* DEBUG */

#endif /* ifndef IA64_ABI */

#endif /* ABI_CHANGES_FOR_RTTI */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
rtti.h/         1146129409  0     0     0       7785      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Declarations for run-time type identification used by RTTI and
exception handling.

*/

#ifndef _RTTI_H
#define _RTTI_H

#include <typeinfo>

#ifndef NULL
#define NULL (0)
#endif /* NULL */

typedef void (*a_function_ptr)();
			/* A pointer type that can be used to store a
                           pointer to a destructor or an operator delete
			   function. */

typedef a_byte a_unique_id;
			/* The thing pointed to by the unique ID in a
			   type_info record. */

typedef a_unique_id *a_unique_id_ptr;
			/* A pointer to a unique ID. */

typedef __EDG_DELTA_TYPE an_object_offset;
			/* Type used to store an offset into an object. */

/* Definitions of the values in the flags field of the base class
   specification entry. */
#ifndef __EDG_IA64_ABI
typedef a_byte a_base_class_spec_flag_set;
#else /* defined(__EDG_IA64_ABI) */
typedef unsigned int a_base_class_spec_flag_set;
#endif /* defined(__EDG_IA64_ABI) */

#define BCS_NO_FLAGS	0x00
			/* Value when no flags are set. */
#define BCS_VIRTUAL	0x01
			/* The offset provides the position of a pointer
			   to the base class.  Used for virtual base
			   classes. */
#ifndef __EDG_IA64_ABI
#define BCS_LAST	0x02
			/* TRUE if this is the last base class specifier
			   in the array. */
#endif /* ifndef __EDG_IA64_ABI */

#ifndef __EDG_IA64_ABI
#define BCS_PUBLIC      0x04
#else /* !defined(__EDG_IA64_ABI) */
#define BCS_PUBLIC      0x02
#endif /* !defined(__EDG_IA64_ABI) */
			/* TRUE if the base class is public.  For non-direct
			   base classes, TRUE if the cumulative access across
			   the all derivation steps gives public access. */

#ifndef __EDG_IA64_ABI
#define BCS_AMBIGUOUS	0x08
			/* TRUE if this base class is ambiguous. */

#define BCS_DIRECT	0x10
			/* TRUE if this is a direct base class.  Ambiguous
			   base classes are always put out at the top level.
			   This flag can be used to determine which ones
			   are really top level bases. */
#endif /* ifndef __EDG_IA64_ABI */

#ifndef __EDG_IA64_ABI

/* Forward declaration of a type_info pointer. */
typedef 
/*** START TI ADD ***/
const 
/*** END TI ADD ***/
struct a_type_info_impl *a_type_info_impl_ptr;

#else /* defined(__EDG_IA64_ABI) */

/* Declare a_type_info_impl_ptr -- even though there is no separate
   implementation type -- to make it possible to use the same code in various
   places in the library. */
typedef const
#if __EDG_RUNTIME_USES_NAMESPACES
              std::
#endif /* __EDG_RUNTIME_USES_NAMESPACES */
                   type_info *a_type_info_impl_ptr;

#endif /* defined(__EDG_IA64_ABI) */

#ifndef __EDG_IA64_ABI

/* Describes the base classes of a class.  Pointed to by the type_info
   of the class. */
typedef 
/*** START TI ADD ***/
const 
/*** END TI ADD ***/ 
struct a_base_class_spec *a_base_class_spec_ptr;

typedef struct a_base_class_spec {
  a_type_info_impl_ptr		 
                type_info;
			/* The type_info for the base class. */
  an_object_offset
		offset;
			/* The offset of the base class in the derived
			   class. */
  a_base_class_spec_flag_set
		flags;
			/* A collection of bits that specify how the
			   base class specification entry is to be used.
			   See the descriptions of the BCS flags above. */
} a_base_class_spec;

/* Type description information for objects that are thrown or
   caught. */
typedef struct a_type_info_impl {
#if ABI_CHANGES_FOR_RTTI
  STD_NAMESPACE::type_info
		user_type_info;
			/* This is the user visible type_info object,
			   a reference to which is returned by the
			   typeid runtime routine.  The runtime assumes
			   that this is the first field in a_type_info_impl. */
  const char
                *name;
                       /* Pointer to a null-terminated character string
			  containing the name of the type. */
#endif /* ABI_CHANGES_FOR_RTTI */
  a_unique_id_ptr
		unique_id;
			/* When this field is non-NULL two type_info
			   structures describe the same type if their
			   unique IDs are the same. */
/*** START TI ADD ***/
   unsigned int            flags;             /* Flags                     */
/*** END TI ADD ***/
#if ABI_COMPATIBILITY_VERSION <= 237
  a_destructor_ptr
		destructor;
			/* Pointer to the destructor for the object.  This is
			   only present in ABI versions up to and including
			   2.37. */
#endif /* ABI_COMPATIBILITY_VERSION <= 237 */
/*** START TI ADD ***/
  const struct 
/*** END TI ADD ***/
  a_base_class_spec
		*base_class_entries;
			/* Pointer to an array of type_info entries for
			   direct base classes of a class. */
} a_type_info_impl;



/* Determine whether two type_info entries refer to the same type.  They
   match if their pointers are the same or if the unique ID pointed to
   by the entries is the same (and nonzero). */
#define matching_type_info(type1, type2)				\
  ((type1) == (type2) || (((type1)->unique_id == (type2)->unique_id) &&  \
                          (type1)->unique_id != 0))

#else /* defined(__EDG_IA64_ABI) */

/* Determine whether two type_info entries refer to the same type.  They
   match if their name pointers are the same. */
#define matching_type_info(type1, type2)				\
  ((type1) == (type2) || ((type1)->name() == (type2)->name()))

typedef abi::__base_class_type_info *a_base_class_spec_ptr;

#endif /* defined(__EDG_IA64_ABI) */

typedef char*	an_access_flag_string;
			/* Type of the string used to specify the access
			   of base classes of the throw object. */

/*
Values used in an access string to specify whether a given base class
is accessible or not.
*/

#define BASE_ACCESSIBLE     'Y'
			/* Value in an access list if the class is
			   accessible. */
#define BASE_NOT_ACCESSIBLE 'N'
			/* Value in an access list if the class is
			   not accessible.  Could be caused by a base
                           being ambiguous. */

EXTERN_C
a_boolean __derived_to_base_conversion(void**		   p_ptr,
				       void**                p_new_ptr,
				       a_type_info_impl_ptr  class_info,
				       a_type_info_impl_ptr  base_info,
				       an_access_flag_string *access_flags,
				       a_boolean             use_access_flags);
#endif /* ifndef _RTTI_H */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

runtime.h/      1146129409  0     0     0       7394      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

/*

Miscellaneous declarations for all runtime routines.

*/

#ifndef RUNTIME_H
#define RUNTIME_H 1

#include "config.h"
#include <stdlib.h>
#include <stdio.h>
#include <new>
#include "error.h"
#ifdef __EDG_IA64_ABI
#include "cxxabi.h"
#endif /* ifdef __EDG_IA64_ABI */

#ifdef __linux__
/* Linux improperly defined NULL as "(void*)0".  Undefine it if it has
   already been defined, and define it to the proper value. */
#ifdef NULL
#undef NULL
#endif /* ifdef NULL */
#define NULL 0
#endif /* ifdef __linux__ */

#ifndef DEBUG
/* Include debugging code. */
#define DEBUG 0
#endif /* ifndef DEBUG */
#if DEBUG
EXTERN int	__debug_level /* = 0 */;
			/* Debug level.  0 means no debug output, 1 - 5
                            means increasing amounts. */
#endif /* DEBUG */
#if DEBUG || CHECKING
#define __f_debug stderr
			/* Debug output file.  This is a macro and not a
			   variable because the initialization of a variable
			   with the value "stderr" cannot be done as a static
			   initialization on some systems. */
#endif /* DEBUG || CHECKING */

/*
Error routines.
*/
#if CHECKING
/* Macro to test an assertion and generate an internal error if
   the condition is not TRUE.  The macro expands to nothing when checking
   code is not being used. */
#define assert_msg() \
  {									\
    (void)fprintf(__f_debug, "Assertion failed in file \"%s\", line %d\n", \
                  __FILE__, __LINE__);				\
    abort();								\
  }

#define check_assertion(test)						\
  if (!(test)) {							\
    assert_msg()							\
  }
#define unexpected_condition()						\
  assert_msg()
#else /* !CHECKING */
#define check_assertion(test) /* Nothing */
#define unexpected_condition()    /* Nothing */
#endif /* CHECKING */

/*
Define the qualifier that should be used to access something defined
in the namespace of the runtime.  This is "std" if the runtime
uses namespaces or "" otherwise.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
#define STD_NAMESPACE std
#ifdef __EDG_IA64_ABI
#define ABI_NAMESPACE abi
#endif /* ifdef __EDG_IA64_ABI */
#else /* ifndef __EDG_RUNTIME_USES_NAMESPACES */
#define STD_NAMESPACE /* nothing */
#ifdef __EDG_IA64_ABI
#define ABI_NAMESPACE /* nothing */
#endif /* ifdef __EDG_IA64_ABI */
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

/*
a_size_of_t is used as a synonym for size_t by the runtime.
*/
#if 0
This should probably use some other kind of test.
#endif /* 0 */
#if __cplusplus
typedef size_t a_sizeof_t;
#else /* __cplusplus */
typedef unsigned int a_sizeof_t;
#endif /* __cplusplus */

/*
If bool is not supported, use a typedef for bool.
*/
#ifdef _BOOL
typedef bool __bool;
#else /* ifndef _BOOL */
typedef int __bool;
#endif /* ifdef _BOOL */

typedef void (*a_void_function_ptr)();
			/* Type used to store a generic function pointer. */

#ifndef __EDG_IA64_ABI
typedef void (*a_destructor_ptr)(void*, int);
#else /* defined(__EDG_IA64_ABI) */
/* Explicit "C" linkage is required for compatibility with the declaration in
   cxxabi.h. */
EXTERN_C typedef void (*a_destructor_ptr)(void*);
#endif /* defined(__EDG_IA64_ABI) */
			/* Type used to store a pointer a destructor. */

typedef void (*a_destructor_with_vtable_param_ptr)(void*, void*);
			/* Type used for the kind of destructor that is used
			   to when information about the construction vtable
			   to be used must be provided. */

#ifdef __EDG_IA64_ABI
/* Explicit "C" linkage is required for compatibility with the declaration in
   cxxabi.h. */
EXTERN_C
#endif /* ifdef __EDG_IA64_ABI */
typedef void* (*a_new_ptr)(size_t);
			/* Type used to store a pointer to an operator new
			   routine. */

#ifdef __EDG_IA64_ABI
/* Explicit "C" linkage is required for compatibility with the declaration in
   cxxabi.h. */
EXTERN_C
#endif /* ifdef __EDG_IA64_ABI */
typedef void (*a_delete_ptr)(void*);
			/* Type used to store a pointer to an operator delete
			   routine. */

#ifdef __EDG_IA64_ABI
/* Explicit "C" linkage is required for compatibility with the declaration in
   cxxabi.h. */
EXTERN_C
#endif /* ifdef __EDG_IA64_ABI */
typedef void (*a_two_operand_delete_ptr)(void *, a_sizeof_t);
			/* Type used to store a pointer to a two operand
			   operator delete routine. */

#if CFRONT_COMPATIBILITY_MODE
typedef void (*a_cfront_constructor_ptr)(void*, void* b1, void* b2, void*b3,
                                         void* b4, void* b5, void* b6,
					 void* b7, void* b8);
			/* Type of a constructor called from vec_new in
			   cfront mode. */
#endif /* CFRONT_COMPATIBILITY_MODE */

/*
In the Cfront ABI, constructors return an object pointer.  In the
IA-64 ABI, they return void.
*/
#ifdef __EDG_IA64_ABI
typedef void a_ctor_return_type;
#else /* ifndef __EDG_IA64_ABI */
typedef void *a_ctor_return_type;
#endif /* ifdef __EDG_IA64_ABI */

#ifdef __EDG_IA64_ABI
/* Explicit "C" linkage is required for compatibility with the declaration in
   cxxabi.h. */
EXTERN_C
#endif /* ifdef __EDG_IA64_ABI */
typedef a_ctor_return_type (*a_constructor_ptr)(void*);
			/* Type of a default constructor called from
			   vec_new. */
#ifdef __EDG_IA64_ABI
/* Explicit "C" linkage is required for compatibility with the declaration in
   cxxabi.h. */
EXTERN_C
#endif /* ifdef __EDG_IA64_ABI */
typedef a_ctor_return_type (*a_copy_constructor_ptr)(void*, void*);
			/* Type of a copy constructor called from
			   vec_cctor. */

extern void __default_new_handler(void);
			/* The default new handler routine. */

EXTERN_C STD_NAMESPACE::new_handler
		_new_handler
		  initial_value((a_void_function_ptr)NULL);
			/* Pointer to the new handler routine to be called. */

#ifdef __EDG_IA64_ABI
typedef void *a_dso_handle;
			/* Type of a DSO handle. */
#endif /* defined(__EDG_IA64_ABI) */

#endif /* RUNTIME_H */



/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
set_new.cpp/    1146129409  0     0     0       2405      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

set_new_handler routine to allow the user to affect the behavior of the
default operator new() when memory cannot be allocated.

*/

#include "basics.h"
#include "runtime.h"
#pragma hdrstop

#ifndef NULL
#define NULL 0
#endif /* ifndef NULL */

/*
If the runtime should be defined in the std namespace, open
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace std {
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

new_handler set_new_handler(new_handler handler) THROW_NOTHING()
/*
Set _new_handler to the new function pointer provided and return the
previous value of _new_handler.
*/
{
  new_handler rr = _new_handler;
  _new_handler = handler;
  return rr;
}  /* set_new_handler */

/*
If the runtime should be defined in the std namespace, close
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace std */
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

setbuf.c/       1146129409  0     0     0       1380      `
/*****************************************************************************/
/*  SETVBUF.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETBUF   -  Set the default buffering mode for a stream                */
/*****************************************************************************/
#include <stdio.h>
 

/*****************************************************************************/
/* SETBUF   -  Set the default buffering mode for a stream                   */
/*                                                                           */
/*    This function calls SETVBUF, and sets the buffering mode to non-       */
/*    buffered if _BUF is NULL, or fully-buffered if _BUF is not NULL.       */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS void setbuf(register FILE *_fp, char *_buf)
{
   setvbuf(_fp, _buf, _buf ? _IOFBF : _IONBF, BUFSIZ);
   return;
}
 

setjmp.asm/     1146129409  0     0     0       431       `
****************************************************************************
* setjmp longjmp v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "setjmp27.inc"
        .elseif .TMS320C2800
                .include "setjmp28.inc"
        .endif

setjmp.h/       1146129409  0     0     0       1896      `
/*****************************************************************************/
/* setjmp.h   v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _SETJMP
#define _SETJMP

#include <linkage.h>

#ifdef __cplusplus
extern "C" namespace std {
#endif

#define setjmp(x) _setjmp(x)

#if defined(__TMS320C27X__)
typedef int jmp_buf[6];
#if defined(__EDG_JMP_BUF_NUM_ELEMENTS) && __EDG_JMP_BUF_NUM_ELEMENTS !=6
   #error "Front end and runtime disagree on size of jmp_buf"
#endif
#elif defined(__TMS320C28X__)
typedef int jmp_buf[9];
#if defined(__EDG_JMP_BUF_NUM_ELEMENTS) && __EDG_JMP_BUF_NUM_ELEMENTS !=9
   #error "Front end and runtime disagree on size of jmp_buf"
#endif
#endif

_CODE_ACCESS int  _setjmp(jmp_buf env); 
_CODE_ACCESS void longjmp(jmp_buf env, int val);

/*****************************************************************************/
/*	DEFINE THE FAR VERSION OF THE SETJMP.				     */
/*****************************************************************************/
#define far_setjmp(x) _far_setjmp(x)

#if defined(__TMS320C27X__)
typedef far int far_jmp_buf[6];
#elif defined(__TMS320C28X__)
typedef far int far_jmp_buf[9];
#endif

_CODE_ACCESS int  _far_setjmp(far_jmp_buf env); 
_CODE_ACCESS void far_longjmp(far_jmp_buf env, int val);

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::jmp_buf;
using std::_setjmp;
using std::longjmp;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::jmp_buf;
using std::_setjmp;
using std::longjmp;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* _SETJMP */
setjmp27.inc/   1146129409  0     0     0       3790      `
****************************************************************************
* setjmp longjmp v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
****************************************************************************
*    C syntax:       int setjmp(jmp_buf env)
*
*    Description:    Save caller's current environment for a subsequent
*                    call to longjmp.  Return 0.
*    Return:         Always returns 0.                    
****************************************************************************
        .global  _setjmp, __setjmp, _longjmp

****************************************************************************
*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro. 
*         In our implementation, the setjmp macro calls a function "_setjmp".
*         However, since the user may not include "setjmp.h", we provide
*         two entry-points to this function.
****************************************************************************
__setjmp:	.asmfunc
_setjmp:
        .if __LARGE_MODEL
        MOV     AL,SP           ; save SP, upon entry env is pointed at by AR4
        MOV     *XAR6++,AL
 
        MOVL    ACC,*-SP[2]     ; save return address
        MOV     *XAR6++,AL      ; store 1 word at a time since alignment of
        MOV     *XAR6++,AH      ; jmp_buf is unknown
 
        MOV     *XAR6++,AR1     ; save registers compiler convention requires
        MOV     *XAR6++,AR2     ; to be saved on function entry
        MOV     *XAR6,AR3
 
        MOVB    AL,#0           ; set return value to 0

        .else
	MOV	AL,SP		; save SP, upon entry env is pointed at by AR4
	MOV	*AR4++,AL	

	MOVL	ACC,*-SP[2]	; save return address
	MOV	*AR4++,AL	; store 1 word at a time since alignment of
	MOV	*AR4++,AH	; jmp_buf is unknown

	MOV	*AR4++,AR1	; save registers compiler convention requires
	MOV	*AR4++,AR2	; to be saved on function entry
	MOV	*AR4,AR3

	MOVB	AL,#0		; set return value to 0	
        .endif

	RET			; return
	.endasmfunc

        .page
****************************************************************************
*    C syntax:    void longjmp(jmp_buf env, int returnvalue)
*
*    Description: Restore the context contained in the jump buffer.
*                 This causes an apparent "2nd return" from the
*                 setjmp invocation which built the "env" buffer.
*
*    Return:      This return appears to return "returnvalue", which must 
*                 be non-zero.
*
****************************************************************************
_longjmp:	.asmfunc
        .if __LARGE_MODEL
        CMPB    AL,#0           ; ensure that returnvalue will be non-zero
        B       L1,NEQ          ; if (returnvalue == 0) return 1
        MOVB    AL,#1           ;
L1:
        MOV     AR1,*XAR6++     ; set SP to value stored in env
        MOV     SP,AR1
        MOV     AR1,*XAR6++     ; put new return address on stack
        MOV     *-SP[2],AR1
        MOV     AR1,*XAR6++
        MOV     *-SP[1],AR1
 
        MOV     AR1,*XAR6++     ; restore registers that compiler conventions
        MOV     AR2,*XAR6++      ; require to be restored on function return
        MOV     AR3,*XAR6

        .else
	CMPB	AL,#0		; ensure that returnvalue will be non-zero
	B	L1,NEQ		; if (returnvalue == 0) return 1
	MOVB	AL,#1		; 
L1:
	MOV	AR1,*AR4++	; set SP to value stored in env
	MOV	SP,AR1
	MOV	AR1,*AR4++	; put new return address on stack
	MOV	*-SP[2],AR1     
	MOV	AR1,*AR4++	
	MOV	*-SP[1],AR1

	MOV	AR1,*AR4++	; restore registers that compiler conventions
	MOV	AR2,*AR4++      ; require to be restored on function return
	MOV	AR3,*AR4
        .endif

	RET			; return
	.endasmfunc
setjmp28.inc/   1146129409  0     0     0       3002      `
****************************************************************************
* setjmp longjmp v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
****************************************************************************
*    C syntax:       int setjmp(jmp_buf env)
*
*    Description:    Save caller's current environment for a subsequent
*                    call to longjmp.  Return 0.
*    Return:         Always returns 0.                    
****************************************************************************
	.global  _setjmp, __setjmp, _longjmp

****************************************************************************
*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro. 
*         In our implementation, the setjmp macro calls a function "_setjmp".
*         However, since the user may not include "setjmp.h", we provide
*         two entry-points to this function.
****************************************************************************
__setjmp:	.asmfunc
_setjmp:
	PUSH	RPC             ; save return address
	MOVL	ACC,*--SP
	MOV	*XAR4++,AL	; store 1 word at a time since alignment of
	MOV	*XAR4++,AH	; jmp_buf is unknown

	MOV	AL,SP		; save SP, upon entry env is pointed at by AR4
	MOV	*XAR4++,AL	

	MOVL    ACC,XAR1        ; save registers compiler convention requires
        MOV     *XAR4++,AL      ; to be saved on function entry
        MOV     *XAR4++,AH      ; store 1 word at a time
        MOVL    ACC,XAR2
        MOV     *XAR4++,AL
        MOV     *XAR4++,AH
        MOVL    ACC,XAR3
        MOV     *XAR4++,AL
        MOV     *XAR4,AH

	MOVB	AL,#0		; set return value to 0	

	LRETR			; return
	.endasmfunc

        .page
****************************************************************************
*    C++ syntax:    void longjmp(jmp_buf env, int returnvalue)
*
*    Description: Restore the context contained in the jump buffer.
*                 This causes an apparent "2nd return" from the
*                 setjmp invocation which built the "env" buffer.
*
*    Return:      This return appears to return "returnvalue", which must 
*                 be non-zero.
*
****************************************************************************
_longjmp:	.asmfunc
	CMPB	AL,#0		; ensure that returnvalue will be non-zero
	B	L1,NEQ		; if (returnvalue == 0) return 1
	MOVB	AL,#1		; 
L1:
	MOVZ	AR1,*XAR4++	; put new return address on stack
	PUSH	AR1
	MOVZ	AR1,*XAR4++	
	PUSH	AR1
	POP	RPC             ; pop new return address

	MOVZ	AR1,*XAR4++	; set SP to value stored in env
	MOV	SP,AR1

	MOV     PL,*XAR4++      ; restore register that compiler conventions
        MOV     PH,*XAR4++      ; require to be restored on function return
        MOVL    XAR1,P
        MOV     PL,*XAR4++
        MOV     PH,*XAR4++
        MOVL    XAR2,P
        MOV     PL,*XAR4++
        MOV     PH,*XAR4
        MOVL    XAR3,P

	LRETR			; return
	.endasmfunc
setvbuf.c/      1146129409  0     0     0       4134      `
/*****************************************************************************/
/*  SETVBUF.C  v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETVBUF  -  Set the buffering mode for a stream                        */
/*****************************************************************************/
#include <stdio.h>
#include <stdlib.h>

extern void   _cleanup();
extern _DATA_ACCESS void (*_cleanup_ptr)(void);


/*****************************************************************************/
/* SETVBUF  -  Set the buffering mode for a stream                           */
/*                                                                           */
/*    This function sets the buffering mode for a stream, and allocates a    */
/*    buffer for it if necessary.                                            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int setvbuf(register FILE *_fp, register char *_buf,
			 register int _type, register size_t _size)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1 || (_type != _IONBF && _size <= 0)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If a buffer already exists, free it if it was malloc'd, and reset all  */
   /* of the stream's buffer pointers.                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->buf)
   {
      if(_STCHK(_fp, _BUFFALOC)) free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
      _fp->buf = NULL;
      _fp->pos = NULL;
      _fp->bufend = NULL;
      _fp->buff_stop = NULL;
   }

   /*------------------------------------------------------------------------*/
   /* If NULL was used for the buffering mode, default to fully-buffered.    */
   /*------------------------------------------------------------------------*/
   if(! _type) _type = _IOFBF;

   /*------------------------------------------------------------------------*/
   /* Clear any previous buffering flags, and set the new one.               */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, (_IOLBF | _IOFBF | _IONBF));
   _SET(_fp, _type);

   /*------------------------------------------------------------------------*/
   /* If a buffer was provided, but its size is only one byte, allocate a    */
   /* different one.  Also, do not allow a buffer size greater than BUFSIZ.  */
   /* The buffer will always have one space at the beginning that is         */
   /* for UNGETC, in the event that an UNGETC is performed on an empty file, */
   /* or when the buffer is full, but unread.                                */
  /*------------------------------------------------------------------------*/
   if(_size == 1) _buf = NULL;
   if(_size > BUFSIZ-1) _size = BUFSIZ -1;
   _size++;

   if (_buf) _fp->pos = _fp->buf = (unsigned char*)_buf+1;
   else
   {
      if (! (_fp->pos = _fp->buf = (unsigned char*)malloc(_size))) return (EOF);
      _fp->pos++;
      _fp->buf++;
      _SET(_fp, _BUFFALOC);
   }

   _fp->bufend = _fp->buf + _size -1;

   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO ALL BUFFERS WILL BE FLUSHED AT EXIT.             */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;

   return (0);
}

sin.c/          1146129409  0     0     0       2529      `
/****************************************************************************/
/*  sin    v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  SIN() - sine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI)							    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expansion 						    */
/*									    */
/*  result = f + f * R							    */
/*									    */
/*  if x < 0, result = - result 					    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double sin(double x)
{
    double xn, f, g, rg, result;
    int    sign = (x < 0); 
    int    n;

    x  = fabs(x);
    n  = (int) ((x * INVSPI) + 0.5);
    xn = (double) n;

    /*************************************************************************/
    /* if n is odd, negate the sign                                          */
    /*************************************************************************/
    sign ^= n % 2; 

    /*************************************************************************/
    /* f = x - xn * PI (but mathematically more stable)                      */
    /*************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

#if BITS<=24
    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=25 && BITS<=32
    rg = ((((R5 * g + R4) * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=33 && BITS<=50
    rg = ((((((R7*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#else
    rg = (((((((R8*g+R7)*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#endif

    result = f + f * rg;
    return sign ? -result : result; 
}

sinh.c/         1146129409  0     0     0       4459      `
/****************************************************************************/
/*  sinh   v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  SINH() - Hyberbolic Sine						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 12.             */
/*									    */
/*  result = (exp(x) - 1 / exp(x)) / 2					    */
/*  if x < 0, result = - result 					    */
/*  if abs(x) <=1, R = polynomial expansion; result = x + x^3 * R           */
/*  if abs(x) >1, result = (exp(x) - 1/exp(x))/2                            */
/****************************************************************************/
double sinh(double x)
{
    double g, z, q, p, r, a, b, result;
    int sign = x < 0;
    int    n;

    if ((x = fabs(x)) <= 1.0)
    {
      g = x * x;

      /************************************************************************/
      /* determine polynomial expression                                      */
      /************************************************************************/
#if BITS<=24
      p = SHP1 * g + SHP0;
      q = g + SHQ0;
#elif BITS>=25 && BITS<=40
      p = (SHP2 * g + SHP1) * g + SHP0;
      q = (g + SHQ1) * g + SHQ0;
#elif BITS>=41 && BITS<=50
      p = ((SHP3 * g + SHP2) * g + SHP1) * g + SHP0;
      q = (g + SHQ1) * g + SHQ0;
#else
      p = ((SHP3 * g + SHP2) * g + SHP1) * g + SHP0;
      q = ((g + SHQ2) * g + SHQ1) * g + SHQ0;
#endif

      result = x + x * g * (p / q);
      return sign ? -result : result; 
    }

    /**************************************************************************/
    /* check to see if overflow would occur                                   */
    /**************************************************************************/
    if (x > MAXH) { errno = ERANGE; return (sign ? -HUGE_VAL : HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);   /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /**************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                     */
    /**************************************************************************/
    g = (x - n * C3) - n * C4;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    z = g * g;

#if BITS <=29
    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
    p = (EXP1 * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

    /**************************************************************************/
    /* calculate exp(g)                                                       */
    /**************************************************************************/
    r = 0.5 + p / (q - p);

    /**************************************************************************/
    /* exp(x)/2 = exp(g) * 2 ^ n                                              */
    /**************************************************************************/
    a = ldexp(r, n);

    /**************************************************************************/
    /* exp(-x)*2 = 1 / (exp(x)/2)                                             */
    /**************************************************************************/
    b = 1.0 / a;

    /**************************************************************************/
    /* sinh(x) = (exp(x)/2 - (exp(-x)*2)/4) * sign(x)                         */
    /**************************************************************************/
    result = a - b * 0.25;
    return sign ? -result : result; 
}

sinit.c/        1146129409  0     0     0       3351      `
/****************************************************************************/
/*  sinit     v4.1.3                                                        */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

extern void _DATA_ACCESS (*_dtors_ptr)(void);

/*************************************************************************/
/* LIST OF REQUIRED STATIC DESTRUCTIONS.  object POINTS TO THE OBJECT    */
/* TO BE DESTROYED, OR NULL IF THERE ARE SEVERAL.  dtor IS THE           */
/* DESTRUCTOR FOR THE OBJECT, AND dfun IS A FUNCTION THAT WILL CALL ALL  */
/* OF THE DESTRUCTORS IS THERE ARE SEVERAL.  ALWAYS ADD TO THE HEAD OF   */
/* THE LIST TO ENSURE THE PROPER ORDER OF DESTRUCTION.                   */
/*************************************************************************/
typedef struct dtor_list
{
   struct dtor_list *next;
   void             *object;
   union
   {
      void  (*dtor)(void *, int);
      void  (*dfun)(void);
   } fun;
} DTOR_LIST;

DTOR_LIST *dtors = NULL;
	 
/****************************************************************************/
/* CALL_DTORS() - PERFORM STATIC DESTRUCTION.                               */
/****************************************************************************/
void call_dtors(void)
{
   while (dtors)
   {
      /*-----------------------------------------------------------------*/
      /* SINCE A DESTRUCTOR MAY ADD NEW DESTRUCTORS TO THE LIST, NOTE    */
      /* AND REMOVE THE HEAD OF THE DESTRUCTOR LIST NOW.                 */
      /*-----------------------------------------------------------------*/
      DTOR_LIST *curr_dtor = dtors;
      dtors = dtors->next;

      /*-----------------------------------------------------------------*/
      /* IF A SINGLE OBJECT, CALL ITS DESTRUCTOR ON ITSELF (A FLAG VALUE */
      /* OF 2 INDICATES THAT OPERATOR DELETE SHOULD NOT BE CALLED).      */
      /* IF MULTIPLE OBJECTS, CALL THE SUPPLIED FUNCTION TO DESTROY THEM */
      /* ALL.                                                            */
      /*-----------------------------------------------------------------*/
      if (curr_dtor->object)  curr_dtor->fun.dtor(curr_dtor->object, 2);
      else                    curr_dtor->fun.dfun();
   }
}

/****************************************************************************/
/* ADD_DTOR() - ADD A DESTRUCTOR TO THE LIST OF STATIC DESTRUCTIONS.        */
/****************************************************************************/
void __add_dtor(DTOR_LIST *dtor_entry)
{
   /*-----------------------------------------------------------------------*/
   /* REGISTER call_dtors() SO exit() WILL CALL IT.  call_dtors() ISN'T     */
   /* CALLED DIRECTLY FROM exit() SO THAT IT ISN'T LINKED IN IF NOT USED.   */
   /*-----------------------------------------------------------------------*/
   _dtors_ptr = call_dtors;

   /*-----------------------------------------------------------------------*/
   /* ADD THE DESTRUCTOR TO THE LIST.                                       */
   /*-----------------------------------------------------------------------*/
   dtor_entry->next = dtors;
   dtors = dtor_entry;
}

sprintf.c/      1146129409  0     0     0       2736      `
/*****************************************************************************/
/*  SPRINTF.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SPRINTF  -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include <format.h>
#include <stdarg.h>
#include <string.h>

extern int _printfi(char **_format, va_list _ap, void *_op,
		    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);

/*****************************************************************************/
/* SPRINTF  -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a format string and an argument list to           */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int sprintf(char *_string, const char *_format, ...)
{
    va_list _ap;
    int   rval;
    char *fptr = (char *)_format;
    char *out_end = _string;

    va_start(_ap, _format);
    rval = _printfi(&fptr, _ap, (void *)&out_end, _outc, _outs);
    va_end(_ap);

    *out_end = '\0';

    return (rval);
}

/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
    return *(*((char **)_op))++ = c;
}

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
    size_t len = strlen(s);

    memcpy(*((char **)_op), s, len);
    *((char **)_op) += len;
    return len;
}
sqrt.c/         1146129409  0     0     0       2327      `
/****************************************************************************/
/*  sqrt   v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <errno.h>
#include "values.h"

/***************************************************************************/
/* SQRT() - Square Root                                                    */
/*   Computes square root of x using a Newton-Raphson approximation for    */
/*   sqrt(1/x).  Initial value x0 = .75 * 2 ^ -(e/2), where x = a * 2 ^ e. */
/*   This is the algorithm from page 11-30 of the TMS320C3x User's Guide.  */
/***************************************************************************/
#define ITERATIONS 6
 
double sqrt(double x)
{
    double x0;          /* estimate */
    int exp;
    int i;
 
    /************************************************************************/
    /* Check to see if the input is not in the function's domain.           */
    /************************************************************************/
    if (x <= 0.0)
    {
      if (x < 0.0) errno = EDOM;
      return (0.0);
    }
 
    /************************************************************************/
    /* initial estimate = .75 * 2 ^ -(exp/2)                                */
    /************************************************************************/
    exp = ( (*((unsigned long *) &x) >> 23) & 0xFF) - 0x7F;
    x0  = ldexp(0.75, -exp / 2);
 
    /************************************************************************/
    /* Refine estimate                                                      */
    /************************************************************************/
    for (i = 0; i < ITERATIONS ; i++)
      x0 *= (1.5 - x * 0.5 * x0 * x0);

/*
    i = ITERATIONS;
    do
      x0 *= (1.5 - x * 0.5 * x0 * x0);
    while (--i);
*/ 
    /************************************************************************/
    /* sqrt(x) = x * sqrt(1/x)                                              */
    /************************************************************************/
    return (x0 * x);
}

sscanf.c/       1146129409  0     0     0       5140      `
/*****************************************************************************/
/*  SSCANF.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SSCANF      -  Read formatted input from a string                      */
/*    _INPCHAR    -  Get a character from the string                         */
/*    _UNINPCHAR  -  Put a character back onto the string                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static int _inpchar(void **inp);
static void _uninpchar(void **inp, int outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);

/*****************************************************************************/
/* SSCANF   -  Read formatted input from a string                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int sscanf(const char *_str, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);

   return (_scanfi((void *)_str, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
}

/*****************************************************************************/
/* _INPCHAR -  Get a character from the string                               */
/*****************************************************************************/
static int _inpchar(void **inp)
{
   char result;
   char *buf = (char *)(*inp);

   result = *(buf++);
   *inp = (void *)buf;  

   return ((result == '\0') ? EOF : result);
}

/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back into the string                       */
/*                                                                           */
/* Note:  Since sscanf() never modifies the input buffer, we can assume      */
/*        that any calls to "_uninpchar" are merely putting back the same    */
/*        character that it had previously read in.  In this case, ignore    */
/*        the contents of outchar and simply back the buffer pointer up.     */
/*                                                                           */
/*        The parameter "outchar" cannot be removed, however, because        */
/*        the fscanf version of this function uses it.  Both versions        */
/*        of this function must have the same prototype since they are both  */
/*        passed as a function pointer to _scanfi.                           */
/*****************************************************************************/
static void _uninpchar(void **inp, int outchar)
{
   char *buf = (char *)(*inp);
   buf--;
   *inp = (void *)buf;  
   return;
}

/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns a 0 upon    */
/*    reaching the end of the format string or a mismatch, or a 1 if a '%'   */
/*    is encountered.                                                        */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   char *buf = (char *)*inp;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while(isspace(**_format))
   {
      for(;isspace(*buf); buf++) (*num_read)++;
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if(*((*_format)++) != *(buf++)) return (0);
      else (*num_read)++;

   if(**_format == '%')
   {
      *inp = (void *)buf;
       return 1;
   }
   else return (0);
}
stdarg.h/       1146129409  0     0     0       3103      `
/*****************************************************************************/
/* stdarg.h   v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDARG
#define _STDARG

#include <linkage.h>

#ifdef __cplusplus
#define va_start(ap, parmN) (ap = ((std::va_list)__va_parmadr(parmN)))
namespace std {
#else
#define va_start(ap, parmN) (ap = ((va_list)__va_parmadr(parmN)))
#endif /* __cplusplus */

typedef char *va_list;

#ifdef __cplusplus
} /* namespace std */
#endif

#define va_end(ap)

/****************************************************************************/
/* RETURN THE NEXT VALUE ON THE STACK ...                                   */
/*                                                                          */
/* (<advance ap>, <access the value>) BECOMES ...                           */
/*                                                                          */
/* ap -= 1 (stack grows toward high addresses)                              */
/* ap -= 1 more if type is long or float                                    */
/* ap -= 1 more if type is long or float and to account for alignment       */
/*       if necessary                                                       */
/*                                                                          */
/* if      (<type is passed by address [struct or union]>) return **ap;     */
/* else if (<type is integer size>)                        return *ap;      */
/*                                                                          */
/* LONG/FLOATS ARE ALWAYS ALIGNED ON AN EVEN WORD BOUNDARY, EVEN WHEN       */
/* PASSED AS PARAMETERS, THUS ap MUST BE ALIGNED FOR THOSE ACCESSES.        */
/****************************************************************************/
#if LARGE_MODEL
#define va_arg(ap, type)                                                 \
( (ap -= 1 + (__va_argref(type) ? (((long)ap & 1) ? 2 : 1) :		 \
				  (sizeof(type) == sizeof(int)) ? 0 :    \
                                   ((long)ap & 1) ? sizeof(type) :       \
                                                    sizeof(type) - 1 )), \
   (__va_argref(type)             ? (** (type **) (ap)) : (* (type *) (ap)) ))
#else
#define va_arg(ap, type)                                                 \
( (ap -= 1 + (__va_argref(type) ? (((int)ap & 1) ? 2 : 1) : 		 \
				  (sizeof(type) == sizeof(int)) ? 0 :    \
                                   ((int)ap & 1) ? sizeof(type)      :   \
                                                   sizeof(type) - 1 )),  \
   (__va_argref(type)             ? (** (type **) (ap)) : (* (type *) (ap)) ))
#endif

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::va_list;
#endif

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::va_list;
#endif

#endif /* __cplusplus */

#endif /* _STDARG */

stddef.h/       1146129409  0     0     0       1183      `
/*****************************************************************************/
/* stddef.h   v4.1.3                                                         */
/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDDEF
#define _STDDEF

#ifdef __cplusplus
extern "C" namespace std {
#endif

#ifndef NULL
#define NULL 0
#endif

typedef __PTRDIFF_T_TYPE__ ptrdiff_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef __SIZE_T_TYPE__ size_t;
#endif

#ifndef __cplusplus
#ifndef _WCHAR_T
#define _WCHAR_T

typedef unsigned int wchar_t;

#endif /* _WCHAR_T */
#endif /* ! __cplusplus */

#define offsetof(_type, _ident) ((size_t)__intaddr__(&(((_type *)0)->_ident)))

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::ptrdiff_t;
using std::size_t;
/*using std::wchar_t;*/
#endif

#endif  /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::ptrdiff_t;
using std::size_t;
/*using std::wchar_t;*/
#endif

#endif  /* __cplusplus */

#endif  /* _STDDEF */

stdexcept/      1146129409  0     0     0       1402      `
/*****************************************************************************/
/* stdexcept  v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifdef __EXCEPTIONS
#ifndef _STDEXCEPT_STDH
#define _STDEXCEPT_STDH

/* This lets users disable the EDG supplied exception classes. */
#ifndef __NO_EDG_EXCEPTION_CLASSES

#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace std {
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */
  class exception {
  public:
    exception() throw() {};
    exception(const exception&) throw() {};
    exception& operator=(const exception&) throw() { return *this; };
    virtual ~exception() throw() {} ;
    virtual const char* what() const throw() { return "";} ;
  };
#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace std */

#ifdef __EDG_IMPLICIT_USING_STD
/* Implicitly include a using directive for the STD namespace when this
   preprocessing flag is TRUE. */
using namespace std;
#endif /* ifdef __EDG_IMPLICIT_USING_STD */

#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */

#endif /* _STDEXCEPT_STDH */
#else /* __EXCEPTIONS */
#ifndef _STDEXCEPT
#define _STDEXCEPT
#endif
#endif /* __EXCEPTIONS */

stdexcept.h/    1146129409  0     0     0       1730      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*
The stdexcept header should be included as "#include <stdexcept>".
This file is provided for compatibility with older programs that use
"#include <stdexcept.h>".
*/
#ifndef _STDEXCEPT_H
#define _STDEXCEPT_H

#include <stdexcept>

#endif /* _STDEXCEPT_H */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
stdexcept_.cpp/ 1146129409  0     0     0       2064      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Functions that implement the "stdexcept" classes (19.1).

*/

#include "basics.h"
#include "runtime.h"

#if EXCEPTION_HANDLING

#include <stdexcept>

/*
If the runtime should be defined in the std namespace, open
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace std {
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */


/*
If the runtime should be defined in the std namespace, close
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace std */
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */


#endif /* EXCEPTION_HANDLING */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
stdint.h/       1146129410  0     0     0       5924      `
/*****************************************************************************/
/* STDINT.H v4.1.3                                                           */
/* Copyright (c) 2002-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDINT_H_
#define _STDINT_H_

/* 7.18.1.1 Exact-width integer types */

    typedef          int    int16_t;
    typedef unsigned int   uint16_t;
    typedef          long   int32_t;
    typedef unsigned long  uint32_t;


#if 0 || 0 || defined(__TMS320C28X__)
    typedef          long long  int64_t;
    typedef unsigned long long uint64_t;
#endif

/* 7.18.1.2 Minimum-width integer types */

    typedef  int16_t  int_least8_t;
    typedef uint16_t uint_least8_t;

    typedef  int16_t  int_least16_t;
    typedef uint16_t uint_least16_t;
    typedef  int32_t  int_least32_t;
    typedef uint32_t uint_least32_t;


#if 0 || 0 || defined(__TMS320C28X__)
    typedef  int64_t  int_least64_t;
    typedef uint64_t uint_least64_t;
#else
/* sorry, int_least64_t not implemented for C54x, C55x, MSP430 */
#endif

/* 7.18.1.3 Fastest minimum-width integer types */

    typedef  int16_t  int_fast8_t;
    typedef uint16_t uint_fast8_t;
    typedef  int16_t  int_fast16_t;
    typedef uint16_t uint_fast16_t;

    typedef  int32_t  int_fast32_t;
    typedef uint32_t uint_fast32_t;


#if 0 || 0 || defined(__TMS320C28X__)
    typedef  int64_t  int_fast64_t;
    typedef uint64_t uint_fast64_t;
#endif

/* 7.18.1.4 Integer types capable of holding object pointers */
    typedef          long intptr_t;
    typedef unsigned long uintptr_t;

/* 7.18.1.5 Greatest-width integer types */
#if 0 || 0 || 0 || defined(__TMS320C28X__)
    typedef          long long intmax_t;
    typedef unsigned long long uintmax_t;
#elif defined(_TMS320C5XX) || defined(__TMS320C27X__) || defined(__MSP430__)
    typedef          long intmax_t;
    typedef unsigned long uintmax_t;
#endif

/* 
   According to footnotes in the 1999 C standard, "C++ implementations
   should define these macros only when __STDC_LIMIT_MACROS is defined
   before <stdint.h> is included." 
*/
#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)

/* 7.18.2 Limits of specified width integer types */


    #define  INT16_MAX  INT32_C(32767)
    #define  INT16_MIN  (-INT16_MAX-1)
    #define UINT16_MAX  UINT32_C(65535)
    #define  INT32_MAX  INT32_C(2147483647)
    #define  INT32_MIN  (-INT32_MAX-1)
    #define UINT32_MAX  UINT32_C(4294967295U)


#if 0 || 0 || defined(__TMS320C28X__)
    #define  INT64_MAX  INT64_C(9223372036854775807)
    #define  INT64_MIN  (-INT64_MAX-1)
    #define UINT64_MAX  UINT64_C(18446744073709551615ULL)
#endif

    #define  INT_LEAST8_MAX   INT16_MAX
    #define  INT_LEAST8_MIN   INT16_MIN
    #define UINT_LEAST8_MAX   UINT16_MAX

    #define  INT_LEAST16_MAX  INT16_MAX
    #define  INT_LEAST16_MIN  INT16_MIN
    #define UINT_LEAST16_MAX  UINT16_MAX
    #define  INT_LEAST32_MAX  INT32_MAX
    #define  INT_LEAST32_MIN  INT32_MIN
    #define UINT_LEAST32_MAX  UINT32_MAX


#if 0 || 0 || defined(__TMS320C28X__)
    #define  INT_LEAST64_MAX  INT64_MAX
    #define  INT_LEAST64_MIN  INT64_MIN
    #define UINT_LEAST64_MAX  UINT64_MAX
#endif

    #define  INT_FAST8_MAX   INT16_MAX
    #define  INT_FAST8_MIN   INT16_MIN
    #define UINT_FAST8_MAX   UINT16_MAX
    #define  INT_FAST16_MAX  INT16_MAX
    #define  INT_FAST16_MIN  INT16_MIN
    #define UINT_FAST16_MAX  UINT16_MAX

    #define  INT_FAST32_MAX  INT32_MAX
    #define  INT_FAST32_MIN  INT32_MIN
    #define UINT_FAST32_MAX  UINT32_MAX


#if 0 || 0 || defined(__TMS320C28X__)
    #define  INT_FAST64_MAX  INT64_MAX
    #define  INT_FAST64_MIN  INT64_MIN
    #define UINT_FAST64_MAX  UINT64_MAX
#endif

    #define INTPTR_MAX   INT32_MAX
    #define INTPTR_MIN   INT32_MIN
    #define UINTPTR_MAX  UINT32_MAX

#if 0 || 0 || defined(__TMS320C28X__)
    #define INTMAX_MIN   INT64_MIN
    #define INTMAX_MAX   INT64_MAX
    #define UINTMAX_MAX  UINT64_MAX
#elif defined(__TMS320C55X__)
    #define INTMAX_MIN   INT40_MIN
    #define INTMAX_MAX   INT40_MAX
    #define UINTMAX_MAX  UINT40_MAX
#elif defined(_TMS320C5XX) || defined(__TMS320C27X__) || defined(__MSP430__)
    #define INTMAX_MIN   INT32_MIN
    #define INTMAX_MAX   INT32_MAX
    #define UINTMAX_MAX  UINT32_MAX
#endif

/* 7.18.3 Limits of other integer types */

    #define PTRDIFF_MAX INT32_MAX
    #define PTRDIFF_MIN INT32_MIN

/* sig_atomic_t not defined */

    #define SIZE_MAX INT32_MAX

    #define WCHAR_MAX UINT16_MAX
    #define WCHAR_MIN 0

/* wint_t not defined */

/* 7.18.4.1 Macros for minimum-width integer constants */

/*
   There is a defect report filed against the C99 standard concerning how 
   the (U)INTN_C macros should be implemented.  Please refer to --
   http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_209.htm 
   for more information.  These macros are implemented according to the
   suggestion given at this web site.
*/

    #define  INT8_C(value)  ((int_least8_t)(value))
    #define UINT8_C(value)  ((uint_least8_t)(value))
    #define  INT16_C(value) ((int_least16_t)(value))
    #define UINT16_C(value) ((uint_least16_t)(value))
    #define  INT32_C(value) ((int_least32_t)(value))
    #define UINT32_C(value) ((uint_least32_t)(value))


#if 0 || 0 || defined(__TMS320C28X__)
    #define  INT64_C(value) ((int_least64_t)(value))
    #define UINT64_C(value) ((uint_least64_t)(value))
#endif

/* 7.18.4.2 Macros for greatest-width integer constants */

    #define  INTMAX_C(value) ((intmax_t)(value))
    #define UINTMAX_C(value) ((uintmax_t)(value))

#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */

#endif /* _STDINT_H_ */
stdio.h/        1146129410  0     0     0       11403     `
/*****************************************************************************/
/* STDIO.H v4.1.3                                                            */
/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDIO 
#define _STDIO

#include <linkage.h>
#include <stdarg.h>

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cstdio> IS RECOMMENDED OVER <stdio.h>.  <stdio.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std {
#endif

/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/
#ifndef _SIZE_T
#define _SIZE_T
typedef __SIZE_T_TYPE__ size_t;
#endif

typedef struct {
      int fd;                    /* File descriptor */
      unsigned char* buf;        /* Pointer to start of buffer */
      unsigned char* pos;        /* Position in buffer */
      unsigned char* bufend;     /* Pointer to end of buffer */
      unsigned char* buff_stop;  /* Pointer to last read char in buffer */
      unsigned int   flags;      /* File status flags (see below) */
      int index;                 /* Location in ftable */
} FILE;

#ifndef _FPOS_T
#define _FPOS_T
typedef long fpos_t;
#endif /* _FPOS_T */

/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/
#define _IOFBF       0x0001
#define _IOLBF       0x0002
#define _IONBF       0x0004
#define _BUFFALOC    0x0008
#define _MODER       0x0010
#define _MODEW       0x0020
#define _MODERW      0x0040
#define _MODEA       0x0080
#define _MODEBIN     0x0100
#define _STATEOF     0x0200
#define _STATERR     0x0400
#define _UNGETC      0x0800
#define _TMPFILE     0x1000

#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))

/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/
#define BUFSIZ          256 
#define FOPEN_MAX       12
#define FILENAME_MAX    256  
#define TMP_MAX         65535

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

#ifndef NULL
#define NULL 0
#endif

#ifndef EOF
#define EOF    (-1)
#endif

#define stdin     (&_ftable[0])      
#define stdout    (&_ftable[1])
#define stderr    (&_ftable[2])

#define L_tmpnam  (sizeof(P_tmpdir) + 15)

/******** END OF ANSI MACROS ************************************************/

#define P_tmpdir        ""                   /* Path for temp files         */

/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/
/*- If you modify these values, be sure to also modify the ftable[] to     -*/
/*- correctly initialize the entries.  This is necessary since we do not   -*/
/*- clear bss by default!                                                  -*/
/****************************************************************************/
#define _NFILE          20                   /* Max number of files open    */

extern _DATA_ACCESS FILE _ftable[_NFILE];
extern _DATA_ACCESS char _tmpnams[_NFILE][L_tmpnam];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
extern _CODE_ACCESS int     remove(const char *_file);
extern _CODE_ACCESS int     rename(const char *_old, const char *_new);
extern _CODE_ACCESS FILE   *tmpfile(void);
extern _CODE_ACCESS char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern _CODE_ACCESS int     fclose(FILE *_fp); 
extern _CODE_ACCESS FILE   *fopen(const char *_fname, const char *_mode);
extern _CODE_ACCESS FILE   *freopen(const char *_fname, const char *_mode,
			            register FILE *_fp);
extern _CODE_ACCESS void    setbuf(register FILE *_fp, char *_buf);
extern _CODE_ACCESS int     setvbuf(register FILE *_fp, register char *_buf, 
			            register int _type, register size_t _size);
extern _CODE_ACCESS int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern _CODE_ACCESS int fprintf(FILE *_fp, const char *_format, ...);
extern _CODE_ACCESS int fscanf(FILE *_fp, const char *_fmt, ...);
extern _CODE_ACCESS int printf(const char *_format, ...);
extern _CODE_ACCESS int scanf(const char *_fmt, ...);
extern _CODE_ACCESS int sprintf(char *_string, const char *_format, ...);
extern _CODE_ACCESS int snprintf(char *_string, size_t _n, 
				 const char *_format, ...);
extern _CODE_ACCESS int sscanf(const char *_str, const char *_fmt, ...);
extern _CODE_ACCESS int vfprintf(FILE *_fp, const char *_format, va_list _ap);
extern _CODE_ACCESS int vprintf(const char *_format, va_list _ap);
extern _CODE_ACCESS int vsprintf(char *_string, const char *_format,
				 va_list _ap);
extern _CODE_ACCESS int vsnprintf(char *_string, size_t _n, 
				  const char *_format, va_list _ap);

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern _CODE_ACCESS int     fgetc(register FILE *_fp);
extern _CODE_ACCESS char   *fgets(char *_ptr, register int _size,
				  register FILE *_fp);
extern _CODE_ACCESS int     fputc(int _c, register FILE *_fp);
extern _CODE_ACCESS int     fputs(const char *_ptr, register FILE *_fp);
extern _CODE_ACCESS int     getc(FILE *_p);
extern _CODE_ACCESS int     getchar(void);
extern _CODE_ACCESS char   *gets(char *_ptr); 
extern _CODE_ACCESS int     putc(int _x, FILE *_fp);
extern _CODE_ACCESS int     putchar(int _x);
extern _CODE_ACCESS int     puts(const char *_ptr); 
extern _CODE_ACCESS int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern _CODE_ACCESS size_t  fread(void *_ptr, size_t _size, size_t _count,
				  FILE *_fp);
extern _CODE_ACCESS size_t  fwrite(const void *_ptr, size_t _size,
				   size_t _count, register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern _CODE_ACCESS int     fgetpos(FILE *_fp, fpos_t *_pos);
extern _CODE_ACCESS int     fseek(register FILE *_fp, long _offset,
				  int _ptrname);
extern _CODE_ACCESS int     fsetpos(FILE *_fp, const fpos_t *_pos);
extern _CODE_ACCESS long    ftell(FILE *_fp);
extern _CODE_ACCESS void    rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
extern _CODE_ACCESS void    clearerr(FILE *_fp);
extern _CODE_ACCESS int     feof(FILE *_fp);
extern _CODE_ACCESS int     ferror(FILE *_fp);
extern _CODE_ACCESS void    perror(const char *_s);

#define _getchar()      getc(stdin)
#define _putchar(_x)    putc((_x), stdout)
#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))

#define _ferror(_x)     ((_x)->flags & _STATERR)

#define _remove(_fl)    (unlink((_fl)))

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::FILE;
using std::fpos_t;
using std::_ftable;
using std::_tmpnams;
using std::remove;
using std::rename;
using std::tmpfile;
using std::tmpnam;
using std::fclose;
using std::fopen;
using std::freopen;
using std::setbuf;
using std::setvbuf;
using std::fflush;
using std::fprintf;
using std::fscanf;
using std::printf;
using std::scanf;
using std::sprintf;
using std::sscanf;
using std::vfprintf;
using std::vprintf;
using std::vsprintf;
using std::fgetc;
using std::fgets;
using std::fputc;
using std::fputs;
using std::getc;
using std::getchar;
using std::gets;
using std::putc;
using std::putchar;
using std::puts;
using std::ungetc;
using std::fread;
using std::fwrite;
using std::fgetpos;
using std::fseek;
using std::fsetpos;
using std::ftell;
using std::rewind;
using std::clearerr;
using std::feof;
using std::ferror;
using std::perror;
#endif  /* _CPP_STYLE_HEADER */

#endif  /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::FILE;
using std::fpos_t;
using std::_ftable;
using std::_tmpnams;
using std::remove;
using std::rename;
using std::tmpfile;
using std::tmpnam;
using std::fclose;
using std::fopen;
using std::freopen;
using std::setbuf;
using std::setvbuf;
using std::fflush;
using std::fprintf;
using std::fscanf;
using std::printf;
using std::scanf;
using std::sprintf;
using std::sscanf;
using std::vfprintf;
using std::vprintf;
using std::vsprintf;
using std::fgetc;
using std::fgets;
using std::fputc;
using std::fputs;
using std::getc;
using std::getchar;
using std::gets;
using std::putc;
using std::putchar;
using std::puts;
using std::ungetc;
using std::fread;
using std::fwrite;
using std::fgetpos;
using std::fseek;
using std::fsetpos;
using std::ftell;
using std::rewind;
using std::clearerr;
using std::feof;
using std::ferror;
using std::perror;
#endif  /* _CPP_STYLE_HEADER */

#endif  /* __cplusplus */

#endif  /* #ifndef _STDIO */


stdlib.h/       1146129410  0     0     0       5478      `
/*****************************************************************************/
/* stdlib.h   v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDLIB
#define _STDLIB

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cstdlib> IS RECOMMENDED OVER <stdlib.h>.  <stdlib.h> IS PROVIDED FOR 
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
#include <cstdlib>
using std::div_t;
using std::ldiv_t;
using std::size_t;
using std::abs;
using std::labs;
using std::atoi;
using std::atol;
using std::atof;
using std::strtol;
using std::strtoul;
using std::strtod;
using std::strtold;
using std::rand;
using std::srand;
using std::calloc;
using std::far_calloc;
using std::malloc;
using std::far_malloc;
using std::realloc;
using std::far_realloc;
using std::free;
using std::far_free;
using std::free_memory;
using std::far_free_memory;
using std::max_free;
using std::far_max_free;
using std::far_chkheap;
using std::chkheap;
using std::abort;
using std::atexit;
using std::bsearch;
using std::qsort;
using std::exit;
using std::div;
using std::ldiv;
using std::getenv;
using std::system;

using std::atoll;
using std::lldiv_t;
using std::lldiv;
using std::strtoll;
using std::strtoull;

#else /* !__cplusplus */

#include <linkage.h>

typedef struct { int  quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;
typedef struct { long long quot, rem; } lldiv_t;

#define MB_CUR_MAX    1

#ifndef NULL
#define NULL          0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef __SIZE_T_TYPE__ size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef unsigned int wchar_t;
#endif

#define EXIT_FAILURE  1
#define EXIT_SUCCESS  0

#define RAND_MAX      32767

         int           abs (int _val);
         long          labs(long _val);
	 long long 	llabs(long long _val);

         long          strtol (const char *st, char **endptr, int base);
         long          far_strtol (const far char *st, far char **endptr, 
				   int base);
         unsigned long strtoul(const char *st, char **endptr, int base);
         unsigned long far_strtoul(const far char *st, far char **endptr, 
				   int base);
         double        strtod (const char *st, char **endptr);
         long double   strtold (const char *st, char **endptr);
         double        far_strtod (const far char *st, far char **endptr);
         long double   far_strtold (const far char *st, far char **endptr);

	 long long     strtoll(const char *st, char **endptr, int base);
	 unsigned long long strtoull(const char *st, char **endptr, int base);
	 long long     far_strtoll(const far char *st, far char **endptr, 
		 						    int base);
	 unsigned long long far_strtoull(const far char *st, far char **endptr,
		 						    int base);
         int           atoi(const char *st);
         int           far_atoi(const far char *st);
         long          atol(const char *st);
	 int           ltoa(long val, char *buffer);
         long          far_atol(const far char *st);
__inline double        atof(const char *st) { return strtod(st, NULL); }
__inline double        far_atof(const far char *st) { return far_strtod(st, NULL); }

	 long long     atoll(const char *st);
	 long long     far_atoll(const far char *st);
         int           rand (void);
         void          srand(unsigned seed);

         void         *calloc  (size_t num, size_t size);
         far void     *far_calloc  (unsigned long num, unsigned long size);
	 void         *malloc  (size_t size);
         far void     *far_malloc  (unsigned long size);
	 void         *realloc (void *ptr, size_t size);
         far void     *far_realloc (far void *ptr, unsigned long size);
         void          free    (void *ptr);
         void          far_free    (far void *ptr);
	 int	       free_memory(void);
	 long          far_free_memory(void);
	 int           max_free(void);
	 long          far_max_free(void);
	 void         *chkheap();
	 long  	       far_chkheap();


         void          abort  (void); 
         int           atexit (void (*func)(void));
         void         *bsearch(const void *key, const void *base, 
			       size_t nmemb, size_t size, 
			       int (*compar)(const void *,const void *));
         far void     *far_bsearch(const far void *key, const far void *base, 
			           size_t nmemb, size_t size, 
			           int (*compar)(const far void *,const far void *));
         void          qsort  (void *base, size_t nmemb, size_t size,
			       int (*compar)(const void *, const void *));
         void          far_qsort  (far void *base, size_t nmemb, size_t size,
			           int (*compar)(const far void *, const far void *));
         void          exit   (int status);

         div_t         div (int numer, int denom);
         ldiv_t        ldiv(long numer, long denom);
         lldiv_t       lldiv(long long numer, long long denom);

         char         *getenv(const char *string);
         int           system(const char *name);

#endif /* __cplusplus */
#endif /* _STDLIB */

strcat.c/       1146129410  0     0     0       411       `
/****************************************************************************/
/*  strcat v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCAT

#include <string.h>

strchr.c/       1146129410  0     0     0       411       `
/****************************************************************************/
/*  strchr v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCHR

#include <string.h>

strcmp.c/       1146129410  0     0     0       411       `
/****************************************************************************/
/*  strcmp v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCMP

#include <string.h>

strcoll.c/      1146129410  0     0     0       605       `
/****************************************************************************/
/*  strcoll v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS int   strcoll(const char *string1, const char *string2)
{
     register const char *r1 = string1 - 1;
     register const char *r2 = string2 - 1;
     register char cp;
 
     while ((*++r2 == (cp = *++r1)) && cp);
     return *r1 - *r2;
}

strcpy.c/       1146129410  0     0     0       411       `
/****************************************************************************/
/*  strcpy v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCPY

#include <string.h>

strcspn.c/      1146129410  0     0     0       1042      `
/****************************************************************************/
/*  strcspn v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS size_t strcspn(const char *s1, const char *s2)
{
   const char *check;
   size_t      count = 0;
 
   /*---------------------------------------------------------------------*/
   /* FOR EACH CHAR IN s1                                                 */
   /*---------------------------------------------------------------------*/
   for (; *s1; s1++, count++)
   {
      for (check = s2; *check;)
	 /*---------------------------------------------------------------*/
	 /* QUIT WHEN FIND A CHAR IN s1 THAT'S EQUAL TO A CHAR IN s2      */
	 /*---------------------------------------------------------------*/
	 if (*s1 == *check++) return count;
   }
   return count;
}
strerror.c/     1146129410  0     0     0       726       `
/****************************************************************************/
/*  strerror  v4.1.3                                                        */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <errno.h>
#include <string.h>

_CODE_ACCESS char *strerror(int errnum)
{
   switch(errnum)
   {
      case 0      :  return ("No error");
      case EDOM   :  return ("Domain error");
      case ERANGE :  return ("Range error");
      case ENOENT :  return ("No such file or directory");
      case EFPOS  :  return ("File positioning error");
   }

   return ("Unknown error");
}
strftime.c/     1146129410  0     0     0       3820      `
/****************************************************************************/
/*  strftime v4.1.3                                                         */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <string.h>

extern int  sprintf(char *_string, const char *_format, ...);

static _DATA_ACCESS const char *const fday[] =
           { "Sunday","Monday","Tuesday","Wednesday",
	     "Thursday","Friday","Saturday" };

static _DATA_ACCESS const char *const fmon[] =
	   { "January","February","March","April","May",
	     "June", "July","August","September",
	     "October","November", "December" };

_CODE_ACCESS size_t strftime(char            *out,
	                     size_t           maxsize, 
	                     const char      *format,
	                     const struct tm *time)
{
    struct tm tt = *time; 
    int       count = 0;
    char      buf[37];

    mktime(&tt);     /* MAKE SURE THIS IS A LEGITIMATE TIME */

    for (;;)
    {
	while ((count < maxsize) && *format && (*format != '%'))
	{
	    count++;
	    *out++ = *format++;
	}

	if (count >= maxsize) return 0;
	if (*format == '\0')  { *out = 0; return count; }

	switch (*++format)
	{
	    case '%' : strcpy(buf, "%");                              break;
	    case 'z' : strcpy(buf, _tz.dstname);                      break;
	    case 'Z' : strcpy(buf, _tz.tzname);                       break;

	    case 'A' : strcpy (buf, fday[tt.tm_wday]);                break;
	    case 'a' : strncpy(buf, fday[tt.tm_wday], 3); buf[3] = 0; break;
	    case 'B' : strcpy (buf, fmon[tt.tm_mon]);                 break;
	    case 'b' : strncpy(buf, fmon[tt.tm_mon], 3);  buf[3] = 0; break;
	    case 'c' : sprintf(buf, "%s %s%3d %02d:%02d:%02d %d",
			       fday[tt.tm_wday], fmon[tt.tm_mon],
			       tt.tm_mday, tt.tm_hour, tt.tm_min,
			       tt.tm_sec, tt.tm_year + 1900);         break;

	    case 'I' : sprintf(buf, "%02d", ((tt.tm_hour != 0) &&
			                     (tt.tm_hour != 12)) ? 
			                    tt.tm_hour % 12 : 12);    break;
	    case 'H' : sprintf(buf, "%02d", tt.tm_hour);              break;
	    case 'M' : sprintf(buf, "%02d", tt.tm_min);               break;
	    case 'S' : sprintf(buf, "%02d", tt.tm_sec);               break;
	    case 'j' : sprintf(buf, "%03d", tt.tm_yday + 1);          break;
	    case 'd' : sprintf(buf, "%02d", tt.tm_mday);              break;
	    case 'e' : sprintf(buf, "%2d",  tt.tm_mday);              break;
	    case 'w' : sprintf(buf, "%1d",  tt.tm_wday);              break;
	    case 'm' : sprintf(buf, "%02d", tt.tm_mon + 1);           break;
	    case 'y' : sprintf(buf, "%02d", tt.tm_year % 100);        break;
	    case 'Y' : sprintf(buf, "%4d", 1900 + tt.tm_year);        break;

	    case 'p' : strcpy(buf, tt.tm_hour >= 12 ? "PM":"AM");     break;

	    case 'W' : sprintf(buf, "%02d", tt.tm_yday / 7 +
			       (tt.tm_yday % 7 >= (tt.tm_wday + 6) % 7));
	    							      break;
	    case 'U' : sprintf(buf, "%02d", tt.tm_yday / 7 +
			       (tt.tm_yday % 7 >= tt.tm_wday));       break;

	    case 'x' : sprintf(buf, "%3s %d, %d", fmon[tt.tm_mon], 
			       tt.tm_mday, tt.tm_year + 1900);        break;
	    case 'X' : sprintf(buf, "%02d:%02d:%02d", tt.tm_hour, 
			       tt.tm_min, tt.tm_sec);                 break;
	}

	/*-------------------------------------------------------------*/
	/* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */
	/*-------------------------------------------------------------*/
	if ((count += strlen(buf)) > maxsize) return 0;
	strcpy(out, buf);
	out += strlen(buf);
	format++;
    }
}
string.h/       1146129410  0     0     0       10660     `
/*****************************************************************************/
/* string.h   v4.1.3                                                         */
/* Copyright (c) 1993-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STRING
#define _STRING

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cstring> IS RECOMMENDED OVER <string.h>.  <string.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std
{
#endif /* __cplusplus */
 
#ifndef NULL
#define NULL 0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef __SIZE_T_TYPE__ size_t;
#endif

#include <linkage.h>

#if defined(_OPTIMIZE_FOR_SPACE) && (0 || 		\
				     1)
#define _OPT_IDECL
#else
#define _OPT_IDECL	_IDECL
#endif

_OPT_IDECL size_t  strlen(const char *_string);

_OPT_IDECL char *strcpy(char *_dest, const char *_src);
_OPT_IDECL char *strncpy(char *_to, const char *_from, size_t _n);
_OPT_IDECL char *strcat(char *_string1, const char *_string2);
_OPT_IDECL char *strncat(char *_to, const char *_from, size_t _n);
_OPT_IDECL char *strchr(const char *_string, int _c);
_OPT_IDECL char *strrchr(const char *_string, int _c);

_OPT_IDECL int  strcmp(const char *_string1, const char *_string2);
_OPT_IDECL int  strncmp(const char *_string1, const char *_string2, size_t _n);

_CODE_ACCESS int     strcoll(const char *_string1, const char *_string2);
_CODE_ACCESS size_t  strxfrm(char *_to, const char *_from, size_t _n);
_CODE_ACCESS char   *strpbrk(const char *_string, const char *_chs);
_CODE_ACCESS size_t  strspn(const char *_string, const char *_chs);
_CODE_ACCESS size_t  strcspn(const char *_string, const char *_chs);
_CODE_ACCESS char   *strstr(const char *_string1, const char *_string2);
_CODE_ACCESS char   *strtok(char *_str1, const char *_str2);
_CODE_ACCESS char   *strerror(int _errno);

_CODE_ACCESS void   *memmove(void *_s1, const void *_s2, size_t _n);

_OPT_IDECL int     memcmp(const void *_cs, const void *_ct, size_t _n);
_OPT_IDECL void   *memchr(const void *_cs, int _c, size_t _n);

_OPT_IDECL   void   *memset(void *_mem, int _ch, size_t _n);


#ifndef __cplusplus
#define far_memcpy __memcpy_ff
#define far_strcpy strcpy_ff
size_t    far_strlen(const far char *s);
char     *strcpy_nf(char *s1, const char far *s2);
char far *strcpy_fn(char far *s1, const char *s2);
char far *strcpy_ff(char far *s1, const char far *s2);
far char *far_strncpy(far char *s1, far const char *s2, size_t n);
far char *far_strcat(far char *s1, const far char *s2);
far char *far_strncat(far char *s1, const far char *s2, size_t n);
far char *far_strchr(const far char *s, int c);
far char *far_strrchr(const far char *s, int c);
int       far_strcmp(const far char *s1, const far char *s2);
int       far_strncmp(const far char *s1, const far char *s2, size_t n);
int       far_strcoll(const far char *s1, const far char *s2);
size_t    far_strxfrm(far char *s1, const far char *s2, size_t n);
far char *far_strpbrk(const far char *s1, const far char *s2);
size_t    far_strspn(const far char *s1, const far char *s2);
size_t    far_strcspn(const far char *s1, const far char *s2);
far char *far_strstr(const far char *s1, const far char *s2);
far char *far_strtok(far char *s1, const far char *s2);
far char *far_strerror(int errno);
void far *far_memmove(far void *s1, far const void *s2, size_t n);
void     *__memcpy_nf (void *_s1, far const void *_s2, size_t _n);
void far *__memcpy_fn (far void *_s1, const void *_s2, size_t _n);
void far *__memcpy_ff (far void *_s1, far const void *_s2, size_t _n);
int       far_memcmp(const far void *s1, const far void *s2, size_t n);
far void *far_memchr(const far void *s, int c, size_t n);
far void *far_memset(far void *s, int c, size_t n);
far void *far_memlcpy(far void *to, const far void *from, unsigned long n);
far void *far_memlmove(far void *to, const far void *from, unsigned long n);
#else /* __cplusplus */
long      far_memlcpy(long to, long from, unsigned long n);
long      far_memlmove(long to, long from, unsigned long n);
#endif /* __cplusplus */


#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::strlen;
using std::strcpy;
using std::strncpy;
using std::strcat;
using std::strncat;
using std::strchr;
using std::strrchr;
using std::strcmp;
using std::strncmp;
using std::strcoll;
using std::strxfrm;
using std::strpbrk;
using std::strspn;
using std::strcspn;
using std::strstr;
using std::strtok;
using std::strerror;
using std::memmove;
using std::memcpy;
using std::memcmp;
using std::memchr;
using std::memset;

using std::far_memlcpy;
using std::far_memlmove;

#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#if defined(_INLINE) || defined(_STRING_IMPLEMENTATION)

#if (defined(_STRING_IMPLEMENTATION) ||					\
     !(defined(_OPTIMIZE_FOR_SPACE) && (0 || 		\
					1))) 

#ifdef __cplusplus
namespace std {
#endif

#if (defined(_OPTIMIZE_FOR_SPACE) && (0 || 		\
				      1))
#define _OPT_IDEFN
#else
#define _OPT_IDEFN	_IDEFN
#endif

#if defined(_INLINE) || defined(_STRLEN)
_OPT_IDEFN size_t strlen(const char *string)
{
   size_t      n = (size_t)-1;
   const char *s = string - 1;

   do n++; while (*++s);
   return n;
}
#endif /* _INLINE || _STRLEN */

#if defined(_INLINE) || defined(_STRCPY)
_OPT_IDEFN char *strcpy(register char *dest, register const char *src)
{
     register char       *d = dest - 1;     
     register const char *s = src  - 1;     

     while (*++d = *++s);
     return dest;
}
#endif /* _INLINE || _STRCPY */

#if defined(_INLINE) || defined(_STRNCPY)
_OPT_IDEFN char *strncpy(register char *dest,
		     register const char *src,
		     register size_t n)
{
     if (n) 
     {
	 register char       *d = dest - 1;
	 register const char *s = src - 1;
	 while ((*++d = *++s) && --n);              /* COPY STRING         */
	 if (n-- > 1) do *++d = '\0'; while (--n);  /* TERMINATION PADDING */
     }
     return dest;
}
#endif /* _INLINE || _STRNCPY  */

#if defined(_INLINE) || defined(_STRCAT)
_OPT_IDEFN char *strcat(char *string1, const char *string2)
{
   char       *s1 = string1 - 1;
   const char *s2 = string2 - 1;

   while (*++s1);		     /* FIND END OF STRING   */
   s1--;  			     /* BACK UP OVER NULL    */
   while (*++s1 = *++s2);	     /* APPEND SECOND STRING */
   return string1;
}
#endif /* _INLINE || _STRCAT */

#if defined(_INLINE) || defined(_STRNCAT)
_OPT_IDEFN char *strncat(char *dest, const char *src, register size_t n)
{
    if (n)
    {
	char       *d = dest - 1;
	const char *s = src  - 1;

	while (*++d);                      /* FIND END OF STRING   */
	d--;                               /* BACK UP OVER NULL    */

	while (n--)
	  if (!(*++d = *++s)) return dest; /* APPEND SECOND STRING */
	*++d = 0;
    }
    return dest;
}
#endif /* _INLINE || _STRNCAT */

#if defined(_INLINE) || defined(_STRCHR)
_OPT_IDEFN char *strchr(const char *string, int c)
{
   char        tch, ch  = c;
   const char *s        = string - 1;

   for (;;)
   {
       if ((tch = *++s) == ch) return (char *) s;
       if (!tch)               return (char *) 0;
   }
}
#endif /* _INLINE || _STRCHR */

#if defined(_INLINE) || defined(_STRRCHR)
_OPT_IDEFN char *strrchr(const char *string, int c)
{
   char        tch, ch = c;
   char       *result  = 0;
   const char *s       = string - 1;

   for (;;)
   {
      if ((tch = *++s) == ch) result = (char *) s;
      if (!tch) break;
   }

   return result;
}
#endif /* _INLINE || _STRRCHR */

#if defined(_INLINE) || defined(_STRCMP)
_OPT_IDEFN int strcmp(register const char *string1,
		  register const char *string2)
{
   register int c1, res;

   for (;;)
   {
       c1  = (unsigned char)*string1++;
       res = c1 - (unsigned char)*string2++;

       if (c1 == 0 || res != 0) break;
   }

   return res;
}
#endif /* _INLINE || _STRCMP */

#if defined(_INLINE) || defined(_STRNCMP)
_OPT_IDEFN int strncmp(const char *string1, const char *string2, size_t n)
{
     if (n) 
     {
	 const char *s1 = string1 - 1;
	 const char *s2 = string2 - 1;
	 unsigned char cp;
	 int         result;

	 do 
	    if (result = (unsigned char)*++s1 - (cp = (unsigned char)*++s2))
                return result;
	 while (cp && --n);
     }
     return 0;
}
#endif /* _INLINE || _STRNCMP */

#if defined(_INLINE) || defined(_MEMCMP)
_OPT_IDEFN int memcmp(const void *cs, const void *ct, size_t n)
{
   if (n) 
   {
       const unsigned char *mem1 = (unsigned char *)cs - 1;
       const unsigned char *mem2 = (unsigned char *)ct - 1;
       int                 cp;

       while ((cp = *++mem1) == *++mem2 && --n);
       return cp - *mem2;
   }
   return 0;
}
#endif /* _INLINE || _MEMCMP */

#if defined(_INLINE) || defined(_MEMCHR)
_OPT_IDEFN void *memchr(const void *cs, int c, size_t n)
{
   if (n)
   {
      const unsigned char *mem = (unsigned char *)cs - 1;   
      unsigned char        ch  = c;

      do if ( *++mem == ch ) return (void *)mem;
      while (--n);
   }
   return NULL;
}
#endif /* _INLINE || _MEMCHR */

#if ((defined(_INLINE) || defined(_MEMSET)) && !0)
_OPT_IDEFN void *memset(void *mem, register int ch, register size_t length)
{
     register char *m = (char *)mem - 1;

     while (length--) *++m = ch;
     return mem;
}
#endif /* _INLINE || _MEMSET */

#ifdef __cplusplus
} /* namespace std */
#endif

#endif /* (_STRING_IMPLEMENTATION || !(_OPTIMIZE_FOR_SPACE && __TMS470__)) */

#endif /* (_INLINE || _STRING_IMPLEMENTATION) */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::strlen;
using std::strcpy;
using std::strncpy;
using std::strcat;
using std::strncat;
using std::strchr;
using std::strrchr;
using std::strcmp;
using std::strncmp;
using std::strcoll;
using std::strxfrm;
using std::strpbrk;
using std::strspn;
using std::strcspn;
using std::strstr;
using std::strtok;
using std::strerror;
using std::memmove;
using std::memcpy;
using std::memcmp;
using std::memchr;
using std::memset;

using std::far_memlcpy;
using std::far_memlmove;

#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* ! _STRING */
strlen.c/       1146129410  0     0     0       411       `
/****************************************************************************/
/*  strlen v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRLEN

#include <string.h>

strncat.c/      1146129410  0     0     0       412       `
/****************************************************************************/
/*  strncat v4.1.3                                                          */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRNCAT

#include <string.h>
strncmp.c/      1146129410  0     0     0       412       `
/****************************************************************************/
/*  strncmp v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRNCMP

#include <string.h>
strncpy.c/      1146129410  0     0     0       412       `
/****************************************************************************/
/*  strncpy v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRNCPY

#include <string.h>
strpbrk.c/      1146129410  0     0     0       566       `
/****************************************************************************/
/*  strpbrk v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS char *strpbrk(const char *s1, const char *s2)
{
   for (; *s1; s1++)
   {
      const char *check = s2;
 
      while (*check)
         if (*check++ == *s1) return (char *)s1;
   }
   return NULL;
}
strrchr.c/      1146129410  0     0     0       412       `
/****************************************************************************/
/*  strrchr v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRRCHR

#include <string.h>
strspn.c/       1146129410  0     0     0       1085      `
/****************************************************************************/
/*  strspn  v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

size_t strspn(const char *s1, const char *s2)
{
   const char *check;
   size_t      count = 0;
 
   /*---------------------------------------------------------------------*/
   /* FOR EACH CHAR IN s1                                                 */
   /*---------------------------------------------------------------------*/
   for (; *s1; s1++, count++)
   {
      check = s2;
 
      /*-------------------------------------------------------------------*/
      /* QUIT WHEN FIND A CHAR IN s1 THAT IS NOT IN s2                     */
      /*-------------------------------------------------------------------*/
      do
         if (!*check) return count;
      while (*check++ != *s1);
   }
 
   return count;
}

strstr.c/       1146129410  0     0     0       1328      `
/****************************************************************************/
/*  strstr v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

char *strstr(const char *s1, const char *s2)
{
   const char *cmp;
   const char *wpos;
 
   /*----------------------------------------------------------------------*/
   /* TRY EVERY POSITION IN THE CONTROL STRING                             */
   /*----------------------------------------------------------------------*/
   for (wpos = (char *)s1; *s1; wpos = ++s1)
   {
      cmp = s2;
 
      do
      {
	 /*----------------------------------------------------------------*/
	 /* AT END OF COMPARISON STRING, MUST HAVE A MATCH OR EMPTY STRING */
	 /*----------------------------------------------------------------*/
	 if (!*cmp)  return (char *)s1;
 
	 /*----------------------------------------------------------------*/
	 /* AT END OF CONTROL STRING, NO MATCH IS POSSIBLE                 */
	 /*----------------------------------------------------------------*/
	 if (!*wpos) return NULL;
 
      } while (*wpos++ == *cmp++);
   }
   return NULL;
}
strtod.c/       1146129410  0     0     0       4034      `
/****************************************************************************/
/*  strtod v4.1.3                                                           */
/*  Copyright (c) 1993-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>
#include <linkage.h>
#include <stdio.h>
#include <limits.h>

#if (DBL_MAX_10_EXP >= 256)  
static const _DATA_ACCESS double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 
						  1.e16, 1.e32, 1.e64, 1.e128,
						  1.e256};
#else 			    
static const _DATA_ACCESS double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 
						  1.e16, 1.e32};
#endif

static const _DATA_ACCESS double digits[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

_CODE_ACCESS double strtod(const char *st, char **endptr)
{
    double      result = 0;
    char        cp;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count  = 0;               /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;
    int         plus_or_minus = 0;        /* READ IN EXPONENT SIGN (+/-) */

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    for (; _isdigit(cp = *fst); ++fst) 
    {
       result = result * 10 + digits[cp - '0']; 
       value  = 1;
    }

    if (cp == '.') {
       while (_isdigit(cp = *++fst)) 
       {
          result = result * 10 + digits[cp - '0']; 
          value  = 1;
	  --exp;
       }
    }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /* IF EXPONENT IS BOGUS (i.e. "1.234empty" or "1.234e+mpty") RESTORE    */
    /* BOGUS EXPONENT BACK ONTO RETURNED STRING (endptr).                   */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       if ((sign = ((cp = *++fst) == '-')) || (cp == '+'))
       {
          cp = *++fst;
          plus_or_minus = 1;
       }
 
       if (!_isdigit(cp))
       {
          if (plus_or_minus) *--fst;
          *--fst;
          goto skip_loop;
       }

       for (count = 0; _isdigit(cp); cp = *++fst)
       {
	  if ((INT_MAX - abs(exp) - (cp - '0')) / 10 > count)
          {
             count *= 10; 
	     count += cp - '0';
	  } else
	  {
	    count = INT_MAX - exp;
	    break;
	  }
       }

skip_loop:

       if (sign) exp -= count;
       else      exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > DBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }
       else if (exp < DBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }
       else if (exp < 0) {
	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	        { if (exp & 1) result /= powerof10[count]; }
       }
       else {
	    for (count = 0; exp; count++, exp >>= 1)
	        { if (exp & 1) result *= powerof10[count]; }
       }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}
strtok.c/       1146129410  0     0     0       736       `
/****************************************************************************/
/*  strtok v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS char *strtok(char *str1, const char *str2)
{
     static _DATA_ACCESS char *last_end;
     char *start; 

     if (str1) last_end = str1;

     last_end += strspn(last_end, str2);
     if (*last_end == '\0') return (NULL);

     start = last_end;
     last_end += strcspn(last_end, str2);

     if (*last_end != '\0') *last_end++ = '\0'; 

     return start;
}

strtol.c/       1146129410  0     0     0       2820      `
/****************************************************************************/
/*  strtol v4.1.3                                                           */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>
#include <access.h>

_CODE_ACCESS long strtol(const char *st, char **endptr, int base)
{
    register long        result = 0;
    register char        cp;
    register const char *fst    = st;
    int                  digits = 0;
    int                  sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  } 
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(cp))
	             cp = *(fst += 2);
     }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;       
	    return sign ? LONG_MIN : LONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }
        return -result;
    }
    return result;
}

strtold.c/      1146129410  0     0     0       4079      `
/****************************************************************************/
/*  strtold v4.1.3                                                          */
/*  Copyright (c) 2002-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>
#include <linkage.h>
#include <stdio.h>
#include <limits.h>

#if (LDBL_MAX_10_EXP >= 256)  
static const _DATA_ACCESS long double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 
						       1.e16, 1.e32, 1.e64L, 
						       1.e128L, 1.e256L};
#else 			    
static const _DATA_ACCESS long double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 
						       1.e16, 1.e32};
#endif

static const _DATA_ACCESS double digits[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

_CODE_ACCESS long double strtold(const char *st, char **endptr)
{
    long double      result = 0;
    char        cp;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;
    int         plus_or_minus = 0;        /* READ IN EXPONENT SIGN (+/-) */

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    for (; _isdigit(cp = *fst); ++fst) 
    {
       result = result * 10 + digits[cp - '0']; 
       value  = 1;
    }

    if (cp == '.') {
       while (_isdigit(cp = *++fst)) 
       {
          result = result * 10 + digits[cp - '0']; 
          value  = 1;
	  --exp;
       }
    }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /* IF EXPONENT IS BOGUS (i.e. "1.234empty" or "1.234e+mpty") RESTORE    */
    /* BOGUS EXPONENT BACK ONTO RETURNED STRING (endptr).                   */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       if ((sign = ((cp = *++fst) == '-')) || (cp == '+'))
       {
          cp = *++fst;
          plus_or_minus = 1;
       }
 
       if (!_isdigit(cp))
       {
          if (plus_or_minus) *--fst;
          *--fst;
          goto skip_loop;
       }

       for (count = 0; _isdigit(cp); cp = *++fst)
       {
	  if ((INT_MAX - abs(exp) - (cp - '0')) / 10 > count)
          {
             count *= 10; 
	     count += cp - '0';
	  } else
	  {
	    count = INT_MAX - exp;
	    break;
	  }
       }

skip_loop:

       if (sign) exp -= count;
       else      exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > LDBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VALL : HUGE_VALL; }
       else if (exp < LDBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }
       else if (exp < 0) {
	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	        { if (exp & 1) result /= powerof10[count]; }
       }
       else {
	    for (count = 0; exp; count++, exp >>= 1)
	        { if (exp & 1) result *= powerof10[count]; }
       }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}

strtoll.c/      1146129410  0     0     0       2829      `
/****************************************************************************/
/*  strtoll v4.1.3                                                          */
/*  Copyright (c) 2000-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>
#include <access.h>

_CODE_ACCESS long long strtoll(const char *st, char **endptr, int base)
{
    register long long   result = 0;
    register char        cp;
    register const char *fst    = st;
    int                  digits = 0;
    int                  sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  } 
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(cp))
	             cp = *(fst += 2);
     }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st; 
	    return sign ? LLONG_MIN : LLONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LLONG_MAX) { errno = ERANGE; return (LLONG_MIN); }
        return -result;
    }
    return result;
}


strtoul.c/      1146129410  0     0     0       2656      `
/****************************************************************************/
/*  strtoul v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

_CODE_ACCESS unsigned long strtoul(const char *st, char **endptr, int base)
{
    register unsigned long result = 0;
    register char          cp;
    register const char   *fst = st;
    int                    digits = 0;
    int                    minus = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;
    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;        
	    return ULONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);

    return minus ? -result : result;
}

strtoull.c/     1146129410  0     0     0       2670      `
/****************************************************************************/
/*  strtoull v4.1.3                                                         */
/*  Copyright (c) 2000-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

_CODE_ACCESS unsigned long long strtoull(const char *st, char **endptr,int base)
{
    register unsigned long long result = 0;
    register char          cp;
    register const char   *fst = st;
    int                    digits = 0;
    int                    minus = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;
    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;        
	    return ULLONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);

    return minus ? -result : result;
}
strxfrm.c/      1146129410  0     0     0       736       `
/****************************************************************************/
/*  strxfrm v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stddef.h>
#include <string.h>

_CODE_ACCESS size_t strxfrm(register char *to,
			    register const char *from,
			    register size_t n)
{
     register int count = 0;     
     while (*from++) count++;                       /* GET LENGTH OF STRING */
     from -= count;
     from--;

     if (n) while ((*to++ = *from++) && --n);       /* COPY STRING          */

     return (count);
}
tan.c/          1146129410  0     0     0       2995      `
/****************************************************************************/
/*  tan    v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TAN() - Tangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 9.              */
/*									    */
/*  N = round(x * 2 / PI) 						    */
/*  f = mantissa x							    */
/*  g = f * f								    */
/*  xnum = f * p1 * g + 1						    */
/*  xden = (q2 * g + q1) * g + 1					    */
/*									    */
/*  if N is even, result = xnum / xden					    */
/*  if N is odd, result = xden / - xnum 				    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double tan(double x)
{
    double xn, f, g, xnum, xden;
    int n;

    /*************************************************************************/
    /* n = round(x * 2/PI)                                                   */
    /*************************************************************************/
    if (x < 0.0) n = (int) (x * TWOINVPI - 0.5);  /* since (int) -1.5 = -1.0 */
    else         n = (int) (x * TWOINVPI + 0.5);

    xn = (double) n;

    /*************************************************************************/
    /* f = x - xn * PI / 2 (but more mathematically stable)                  */
    /*************************************************************************/
    f = (x - xn * C5) - xn * C6;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

#if BITS<=24
    xnum = TAP1 * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;
#elif BITS>=25 && BITS<=32
    xnum = (TAP2 * g + TAP1) * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;
#elif BITS>=33 && BITS<=52
    xnum = ((TAP3 * g + TAP2) * g + TAP1) * g * f + f;
    xden = ((TAQ3 * g + TAQ2) * g + TAQ1) * g + 0.5 + 0.5;
#else
    xnum = ((TAP3 * g + TAP2) * g + TAP1) * g * f + f;
    xden = (((TAQ4 * g + TAQ3) * g + TAQ2) * g + TAQ1) * g + 0.5 + 0.5;
#endif

    /*************************************************************************/
    /* if n is odd                                                           */
    /*************************************************************************/
    if (n % 2 == 0) return (xnum / xden);
    else            return (xden / -xnum);	
}

tanh.c/         1146129410  0     0     0       2528      `
/****************************************************************************/
/*  tanh   v4.1.3                                                           */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TANH() - Hyperbolic Tangent						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 13.             */
/*  This also uses the Cody and Waite algorithm for exp in chapter 6.	    */
/*									    */
/*  f = abs(x)								    */
/*  if f < ln(3) / 2,							    */
/*	g = f * f							    */
/*	R = polynomial expansion					    */
/*	result = f + f * R						    */
/*									    */
/*  if d > XBIG, result = sign(x)                                           */
/*  if f > ln(3) / 2 & f <= XBIG, result = 1 - 2 / (exp(2f) + 1)	    */
/*  if f < ln(3) / 2, R = polynomial expansion; result = f + f * R          */
/*  if x < 0, result = - result 					    */
/****************************************************************************/
double tanh(double x)
{
    double f = x, g, p, q, r, result;
    int sign = x < 0;

    f = fabs(x);

    if      (f > XBIG)     return (sign ? -1.0 : 1.0);
    else if (f > LOGe3by2) 
	 {
	    result = 1.0 - 2.0 / (exp(2.0 * f) + 1.0);
	    return sign ? -result : result; 
	 }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = f * f;

#if BITS<=24
    p = (THP1 * g + THP0) * g;
    q = g + THQ0;
#elif BITS>=25 && BITS<=36
    p = (THP1 * g + THP0) * g;
    q = (g + THQ1) * g + THQ0;
#elif BITS>=37 && BITS<=48
    p = ((THP2 * g + THP1) * g + THP0) * g;
    q = (g + THQ1) * g + THQ0;
#else
    p = ((THP2 * g + THP1) * g + THP0) * g;
    q = ((g + THQ2) * g + THQ1) * g + THQ0;
#endif

    r = p / q;

    /*****************************************************************/
    /* tanh(x) = sign * result                                       */
    /*****************************************************************/
    result = f + f * r; 
    return sign ? -result : result; 
}
throw.cpp/      1146129410  0     0     0       73619     `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Throw processing for exception handling.

*/

#include "basics.h"
#include "runtime.h"
#include "eh.h"
#pragma hdrstop
#include "vec_newdel.h"

#if EXCEPTION_HANDLING

/* Structure used to maintain a stack of throws that are currently
   being processed. */
typedef struct a_throw_stack_entry *a_throw_stack_entry_ptr;
typedef struct a_throw_stack_entry {
  a_throw_stack_entry_ptr
		next;
			/* The next stack entry. */
  a_type_info_impl_ptr
		type_info;
			/* Type_Info of the object thrown. */
  a_destructor_ptr
		destructor;
			/* Destructor for the thrown object. */
  an_ETS_flag_set
		flags;
			/* A collection of bits that specify how the
			   additional information about the thrown object. */
  an_ETS_flag_set
		*ptr_flags;
			/* Pointer to an array of ETS flags for multi-level
			   pointers.  NULL for single level pointers, and for
			   ABI versions earlier that 2.41.  Used to implement
			   qualification conversions on multi-level
			   pointers. */
  an_access_flag_string
		access_flags;
			/* A null terminated character string that specifies
			   the accessibility of the base classes.  "y" means
			   that the base class is accessible, "m" means that
			   it is not. */
  void*		object_address;
			/* Pointer to the memory allocated to store
			   the copy of the object. */
  void*		pointer_buffer;
			/* A piece of memory large enough to store a pointer.
			   When a pointer is thrown the pointer may undergo
			   one of several possible conversions including a
			   conversion from a pointer to derived to a pointer
			   to base.  This buffer is used to store the modified
		  	   pointer.  The original pointer must be preserved for
			   use by a rethrow. */
  an_eh_stack_entry_ptr
		nearest_enclosing_try_block;
			/* Pointer to the nearest enclosing try block
			   (that is not currently in a handler) at
			   the point at which the throw was started.
			   This is used to detect abandoned throws. */
  a_throw_stack_entry_ptr
		primary_entry;
			/* If this is a rethrow, points to the throw stack
			   entry of the original throw. */
  unsigned long	use_count;
			/* Present only in primary entries (not rethrows).
			   Represents the number of throw stack entries
			   that are still active that refer to the object. */
  a_byte_boolean
		is_rethrow;
			/* TRUE if this entry represents a rethrow.
		  	   The object_address entry for a rethrow points
			   to an object allocated by a previous throw. */
  a_byte_boolean
		discard_entry;
			/* This field is used during the processing of
			   nested throws.  This flag is set when a stack
			   entry is no longer needed but cannot be freed
			   because an entry higher on the stack has not
			   yet been freed. */
  a_byte_boolean
		dtor_called;
			/* TRUE if the destructor for the object has already
			   been called.  This is only used for entries created
			   by throws that are not rethrows. */
  a_byte_boolean
		in_handler;
			/* TRUE when the object has been passed to a
			   handler.  It is at this point that the
			   object can be rethrown. */
  a_byte_boolean
		object_evaluation_complete;
			/* TRUE when the evaluation of the thrown object has
			   been completed, but before the object has been
			   copied to the EH temporary.  If the copy to the EH
			   temporary is elided, then this flag is set when
			   the execution of __throw begins. */
  a_byte_boolean
		object_copy_complete;
			/* Set to FALSE when __throw_alloc is called and
			   set to TRUE when __throw is called.  This
			   flag indicates that the thrown object has been
			   copied and must be destroyed at some point. */
  a_byte_boolean
		use_access_flags;
			/* TRUE if the access_flags string should be used to
			   determine the accessibility of base classes.
			   The access flag string was originally used for
			   this purpose but was later replaced by static
			   information in the base class specification
			   information.  This flag indicates which access
			   checking method should be used for a given throw. */
  an_eh_stack_entry
		throw_marker;
			/* An EH stack entry for the throw marker to be
			   linked into the EH stack while a given throw
			   is active. */
} a_throw_stack_entry;


/* Structure used to record information about blocks of memory handled
   by the EH memory management routines. */
typedef struct a_mem_block_descr *a_mem_block_descr_ptr;
typedef struct a_mem_block_descr {
  a_mem_block_descr_ptr
		next;
			/* The next stack entry. */
  void*		addr;
			/* Address of the block of memory. */
  a_sizeof_t	size;
			/* Size in bytes of the block of memory. */
  a_sizeof_t	used;
			/* Number of bytes used in the block. */
  a_byte_boolean
		dynamically_allocated;
			/* TRUE if the block of memory was dynamically
			   allocated.  The initial memory block is
			   statically allocated. */
} a_mem_block_descr;


/* Describes a single piece of memory allocated by the EH runtime. */
typedef struct a_mem_allocation *a_mem_allocation_ptr;
typedef struct a_mem_allocation {
  a_mem_allocation_ptr
		next;
			/* The next allocation entry. */
  a_sizeof_t	alloc_size;
			/* Size of the piece of memory.  This is the
			   allocated size including any space needed
			   for alignment not just the requested size. */
  void*		addr;
			/* Address of the memory allocated. */
  a_byte_boolean
		is_mem_block_descr_allocation;
			/* TRUE if this is a memory allocation done
			   to keep track of a memory block description
		           record. */
} a_mem_allocation;

#if ABI_CHANGES_FOR_RTTI
a_byte		MANGLED_NAME_OF_UNIQUE_ID_OF_VOID;
			/* This is used to get the address of the
			   unique ID for the void type for pointer to
			   void* conversions. */
#else /* !ABI_CHANGES_FOR_RTTI */
a_type_info_impl
                MANGLED_NAME_OF_VOID;
			/* This is used to get the address of the
			   type_info for the void type for pointer to
			   void* conversions. */
#endif /* !ABI_CHANGES_FOR_RTTI */


static a_throw_stack_entry_ptr
		curr_throw_stack_entry = NULL;
			/* The pointer to the top of the stack of throw
			   entries. */

static a_mem_block_descr_ptr
		curr_mem_block_descr = NULL;
			/* Pointer to the top of a stack of memory
			   blocks managed by the EH runtime. */

static a_mem_allocation_ptr
		mem_allocation_stack = NULL;
			/* Pointer to the top of a stack of memory
			   allocation entries. */
/*** START TI ADD ***/ 
#if 0
static a_mem_block_descr
		initial_mem_block_descr;
			/* Initial entry pointed to by the memory block
			   stack. */


static union {
  char		memory[EH_MEMORY_ALLOCATION_INCREMENT];
			/* The initial block of memory to be used.  This
			   avoids the need for the EH runtime to do
			   any dynamic memory allocation in most cases. */
  TYPE_WITH_MOST_STRICT_ALIGNMENT
		dummy;
			/* Used to ensure that the memory block is
			   guaranteed to be aligned on an appropriate
			   boundary. */
} initial_mem_block;
#endif
/*** END TI ADD ***/ 

/* Round a given size up to a multiple of MOST_STRICT_ALIGNMENT. */
#define round_size_to_alignment(size)					\
  (((size + MOST_STRICT_ALIGNMENT - 1) / MOST_STRICT_ALIGNMENT) *	\
                                                   MOST_STRICT_ALIGNMENT)

/* The number of bytes needed for a memory block description and any
   required alignment. */
#define NEEDED_FOR_MEM_BLOCK_DESCR \
  round_size_to_alignment(sizeof(a_mem_block_descr))


/* The number of bytes needed for a memory allocation structure and any
   required alignment. */
#define NEEDED_FOR_MEM_ALLOCATION_INFO \
  round_size_to_alignment(sizeof(a_mem_allocation))

/* The number of bytes needed at the end of a memory block to record the
   information needed to allocate a new memory block. */
#define RESERVED_FOR_END_OF_MEM_BLOCK \
  (NEEDED_FOR_MEM_BLOCK_DESCR + NEEDED_FOR_MEM_ALLOCATION_INFO)


/* The number of bytes that must be added to the_ptr to obtain a value
   with suitable alignment.  the_ptr is actually an integer value that
   represents an offset from the base of a block of memory that is known
   to be appropriately aligned. */
#define increment_needed_for_alignment(the_ptr)				\
  (((the_ptr % MOST_STRICT_ALIGNMENT) == 0) ?	\
         0 :								\
         (MOST_STRICT_ALIGNMENT - (the_ptr % MOST_STRICT_ALIGNMENT)))

static void alloc_new_mem_block(a_sizeof_t size);


static void* eh_get_memory(a_sizeof_t	size)
/*
This is a low level routine that just gets a piece of dynamically
allocated memory from the system.   This must get the memory in
a means that will not result in an exception being thrown.
*/
{
  void*		mem_block;

  mem_block = malloc(size);
  /* If we can't get the memory we need, call the terminate routine. */
  if (mem_block == NULL) {
    __call_terminate();
  }  /* if */
  return mem_block;
}  /* eh_get_memory */


static void eh_free_memory(void* ptr)
/*
This is a low level routine that simply frees a piece of dynamically allocated
memory to the system.  This must free the memory in a means that will not
result in an exception being thrown.
*/
{
  free(ptr);
}  /* eh_free_memory */


static void mem_block_descr_init(a_mem_block_descr_ptr mbdp)
/*
Initialize the fields of a memory block description record.
*/
{
  mbdp->next = NULL;
  mbdp->addr = NULL;
  mbdp->size = 0;
  mbdp->used = 0;
  mbdp->dynamically_allocated = FALSE;
}  /* mem_block_descr_init */


static void init_eh_memory_management(void)
/*
Initialize the variables that keep track of memory used by the EH runtime.
*/
{
/*** START TI ADD ***/ 
#if 0   /* Original EDG code */
  /* Initialize the initial memory block description record. */
  mem_block_descr_init(&initial_mem_block_descr);
  initial_mem_block_descr.addr = initial_mem_block.memory;
  initial_mem_block_descr.size = EH_MEMORY_ALLOCATION_INCREMENT;
  initial_mem_block_descr.used = 0;
  initial_mem_block_descr.dynamically_allocated = FALSE;
  curr_mem_block_descr = &initial_mem_block_descr;
#else  /* TI code */
  /* Allocate and initialize the initial memory block description record. */
  a_mem_block_descr_ptr initial_mem_block_descr = 
             (a_mem_block_descr_ptr)eh_get_memory(sizeof(a_mem_block_descr));
  mem_block_descr_init(initial_mem_block_descr);
  initial_mem_block_descr->addr = eh_get_memory(EH_MEMORY_ALLOCATION_INCREMENT);
  initial_mem_block_descr->size = EH_MEMORY_ALLOCATION_INCREMENT;
  initial_mem_block_descr->used = 0;
  initial_mem_block_descr->dynamically_allocated = FALSE;
  curr_mem_block_descr = initial_mem_block_descr;
#endif
/*** END TI ADD ***/
}  /* init_eh_memory_management */


/*
Return the address of the specified character position within the
current memory block.
*/
#define addr_in_mem_block(pos)						\
  (void *)(((char *)curr_mem_block_descr->addr) + pos)


static void* alloc_in_mem_block(a_sizeof_t	      size,
			        a_mem_allocation_ptr* map)
/*
Allocate a memory allocation record and the requested amount of space
in the current memory block.  There must be enough space for the allocation
to succeed and size must be a multiple of MOST_STRICT_ALIGNMENT.
*/
{
  void*			ptr;
  int			used;

  /* Get space from the memory block to store a new memory block description
     an a memory allocation record to describe it. */
  used = curr_mem_block_descr->used;
  *map = (a_mem_allocation_ptr)addr_in_mem_block(used);
  used += NEEDED_FOR_MEM_ALLOCATION_INFO;
  ptr = (void*)addr_in_mem_block(used);
  used += size;
  curr_mem_block_descr->used = used;
  /* Add this memory allocation record to the top of the stack. */
  (*map)->next = mem_allocation_stack;
  (*map)->addr = ptr;
  mem_allocation_stack = *map;
  /* Initialize the other fields of the memory allocation record. */
  (*map)->alloc_size = size;
  (*map)->is_mem_block_descr_allocation = FALSE;
  check_assertion(curr_mem_block_descr->used <= curr_mem_block_descr->used);
  check_assertion(size % MOST_STRICT_ALIGNMENT == 0);
  return ptr;
}  /* alloc_in_mem_block */


static void alloc_new_mem_block(a_sizeof_t	size)
/*
Allocate a new memory block of at least "size" bytes.  Actually,
it must also have enough space for an additional mem_block_descr entry
too.  We actually allocate "size + EH_MEM_ALLOCATION_INCREMENT" bytes since
we know that "size" bytes will immediately be consumed.
*/
{
  void*			mem_block;
  a_mem_allocation_ptr	map;
  a_mem_block_descr_ptr	mpdp;
  a_sizeof_t		new_size;

  /* Adjust the requested size.  The adjusted size is a multiple of the
     memory allocation increment.  If (adjusted_size - size) >
     (memory_allocation_increment * .5) then we allocate an extra
     memory_allocation_increment bytes. */
  new_size = ((size / EH_MEMORY_ALLOCATION_INCREMENT) + 1) *
                                              EH_MEMORY_ALLOCATION_INCREMENT;
  if ((new_size - size) < (EH_MEMORY_ALLOCATION_INCREMENT >>1)) {
    new_size += EH_MEMORY_ALLOCATION_INCREMENT;
  }  /* if */
  size = new_size;
  /* Get space from the memory block to store a new memory block description
     an a memory allocation record to describe it. */
  mpdp = (a_mem_block_descr_ptr)alloc_in_mem_block(NEEDED_FOR_MEM_BLOCK_DESCR,
						   &map);
  map->is_mem_block_descr_allocation = TRUE;
  mem_block = eh_get_memory(size);
  /* Add the new memory block description to the top of the stack. */
  mpdp->next = curr_mem_block_descr;
  curr_mem_block_descr = mpdp;
  /* Initialize the fields of the memory block descriptor. */
  mpdp->addr = mem_block;
  mpdp->size = size;
  mpdp->used = 0;
  mpdp->dynamically_allocated = TRUE;
}  /* alloc_new_mem_block */


static void* eh_alloc_on_stack(a_sizeof_t	size)
/*
Allocate a block of memory on the EH memory stack.
*/
{
  a_mem_allocation_ptr	map;
  int			needed_for_alignment;
  void*			ptr;
  a_sizeof_t		alloc_size;

  /* The memory management system is initialized the first time that
     this routine is called. */
  if (curr_mem_block_descr == NULL) {
    init_eh_memory_management();
  }  /* if */
  /* Determine the number of bytes that must be added to size to ensure
     that the resulting "used" value will be appropriately aligned. */
  needed_for_alignment = increment_needed_for_alignment(size);
  /* Make sure that the current memory block would have enough space
     leftover to allocate the requested space, plus the space needed for
     the memory allocation information plus a new memory block descriptor.
     If not, start the new memory block now. */
  alloc_size = size + needed_for_alignment;
  if ((alloc_size + NEEDED_FOR_MEM_ALLOCATION_INFO +
       curr_mem_block_descr->used +
       RESERVED_FOR_END_OF_MEM_BLOCK) > curr_mem_block_descr->size) {
    alloc_new_mem_block(alloc_size);
  }  /* if */
  ptr = alloc_in_mem_block(alloc_size, &map);
#if DEBUG
  if (__debug_level >= 5) {
    fprintf(__f_debug, "Allocated %lu bytes starting at %p, ending at %p\n",
            (unsigned long)size, (void*)ptr, (void*)(((char *)ptr)+size-1));
  }  /* if */
#endif /* DEBUG */
  return ptr;
}  /* eh_alloc_on_stack */


static void free_in_mem_block(void*	ptr)
/*
Free a block of memory allocated in a memory block.
*/
{
  a_mem_allocation_ptr	map;
  int			used;

  map = mem_allocation_stack;
  mem_allocation_stack = map->next;
  check_assertion(map->addr == ptr);
  used = curr_mem_block_descr->used;
  used -= map->alloc_size;
  used -= NEEDED_FOR_MEM_ALLOCATION_INFO;
  curr_mem_block_descr->used = used;
}  /* free_in_mem_block */


static void eh_free_on_stack(void*	ptr)
/*
Free a piece of memory on the memory stack.  If a memory block becomes
empty then remove it from the stack.
*/
{
  /* Free the memory passed by the caller. */
  free_in_mem_block(ptr);
  /* Is the memory block now empty? */
  if (curr_mem_block_descr->used == 0) {
    if (curr_mem_block_descr->next != NULL) {
      /* Don't free the initial memory block. */
      a_mem_block_descr_ptr	mpdp_to_free;
      mpdp_to_free = curr_mem_block_descr;
      curr_mem_block_descr = mpdp_to_free->next;
      /* Free the memory block.  This is freed to the system -- not just to
         the memory stack like other kinds of memory. */
      if (mpdp_to_free->dynamically_allocated) {
        /* Only free dynamically allocated blocks. */
        eh_free_memory(mpdp_to_free->addr);
      }  /* if */
      /* Free the memory block description entry. */
      free_in_mem_block(mpdp_to_free);
    }  /* if */
  }  /* if */
}  /* eh_free_on_stack */


/* Determine whether the type qualifiers are acceptable.  The thrown type
   may not have more qualifiers than the caught type.  The qualifiers are
   only checked if the thrown type is a pointer. */
#define qualifiers_acceptable(caught_flags, thrown_flags)		\
  ((!is_single_level_pointer(thrown_flags)) || 				\
   (caught_flags & thrown_flags & ETS_QUALIFIERS) ==			\
                                            (thrown_flags & ETS_QUALIFIERS))

#if DEBUG
static void db_eh_region_descr(an_eh_region_descr_ptr  ehrdp)
/*
Print the contents of a region description entry.
*/
{
  if (ehrdp == NULL) {
    fprintf(__f_debug, "  <NULL pointer>\n");
  } else {
    if (ehrdp->flags) {
      fprintf(__f_debug, "  flags: ");
      if (ehrdp->flags & RDF_INDIRECT) fprintf(__f_debug, " indirect");
      if (ehrdp->flags & RDF_NEW_ALLOCATION) fprintf(__f_debug, " new");
      if (ehrdp->flags & RDF_BASE_CLASS_SUBOBJECT) {
        fprintf(__f_debug, " subobject");
        /* The SUBOBJECT_VTABLE and LET_THIS flags share the same bit.
           The meaning depends on the setting of the BASE_CLASS_SUBOBJECT
           flag. */
        if (ehrdp->flags & RDF_SUBOBJECT_VTABLE) {
          fprintf(__f_debug, " subobject vtable");
        }  /* if */
      }  /* if */
      if (ehrdp->flags & RDF_GUARD_VAR_FOR_LOCAL_STATIC) {
        fprintf(__f_debug, " local static guard");
      }  /* if */
    }  /* if */
    fprintf(__f_debug, "  destr/delete=%p\n",
            (void*)(unsigned long)ehrdp->destructor_or_delete_routine);
#if 0
    if (ehrdp->array_size != 0) {
      fprintf(__f_debug, "  array_size=%ld\n", ehrdp->array_size);
    }  /* if */
#endif /* 0 */
    fprintf(__f_debug, "  handle=%d\n", ehrdp->handle);
    fprintf(__f_debug, "  next region=%d\n", ehrdp->index_of_next_region);
  }  /* if */
} /* db_eh_region_descr */


static void db_throw_stack_entry(a_throw_stack_entry_ptr tsep)
{
  fprintf(__f_debug, "typinfo=%p ", (void*)tsep->type_info);
  fprintf(__f_debug, "flags=%0x ", tsep->flags);
  fprintf(__f_debug, "object_address=%p ", (void*)tsep->object_address);
  if (tsep->is_rethrow) {
    fprintf(__f_debug, "is_rethrow=%0d ", tsep->is_rethrow);
  }  /* if */
  if (tsep->discard_entry) {
    fprintf(__f_debug, "discard_entry=%0d ", tsep->discard_entry);
  }  /* if */
  if (tsep->dtor_called) {
    fprintf(__f_debug, "dtor_called=%0d ", tsep->dtor_called);
  }  /* if */
  if (tsep->in_handler) {
    fprintf(__f_debug, "in_handler=%0d ", tsep->in_handler);
  }  /* if */
  if (tsep->use_count != 0) {
    fprintf(__f_debug, "use_count=%0lu ", tsep->use_count);
  }  /* if */
  if (tsep->primary_entry != NULL) {
    fprintf(__f_debug, "primary_entry=%p ", tsep->primary_entry);
  }  /* if */
}  /* db_throw_stack_entry */


static void db_throw_stack(char* str)
{
  a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;
  int				count = 0;

  fprintf(__f_debug, "Throw stack %s:\n", str);
  while (tsep != NULL) {
    fprintf(__f_debug, "  Entry %0d at %p: ", count++, tsep);
    db_throw_stack_entry(tsep);
    fprintf(__f_debug, "\n");
    tsep = tsep->next;
  }  /* while */
}  /* db_throw_stack */
#endif /* DEBUG */


static void cleanup(an_eh_stack_entry_ptr ehsep,
                    a_region_number       region,
		    a_region_number	  stop_at_region)
/*
Do the cleanup operations required in the function described by ehsep.
The current region number within ehsep is designated by region.  Cleanup
processing stops when we reach the region designated by stop_at_region.
Normally this is NULL_REGION_NUMBER but may have another value when
doing a partial cleanup as is done when an object in a try block
requires cleanup.
*/
{
  an_object_ptr	                *obj_addr_array;
  an_eh_region_descr_ptr	ehrdp;
  obj_addr_array = ehsep->variant.function.object_address_table;
  for (; region != stop_at_region; region = ehrdp->index_of_next_region) {
    an_object_ptr	        obj_addr;
    a_conditional_flag*	        flag_addr = NULL;
    char			*temp_addr;
    a_region_descr_flag_set     flags;
    an_eh_array_supplement_ptr	ehasp = NULL;
    void			*vtbl_ptr = NULL;

    ehrdp = &ehsep->variant.function.regions[region];
#if DEBUG
    if (__debug_level >= 2) {
      fprintf(__f_debug, "Region: %d, descr address=%p\n", region,
              (void*)ehrdp);
      db_eh_region_descr(ehrdp);
    }  /* if */
#endif /* DEBUG */
    flags = ehrdp->flags;
    if (flags & RDF_CONDITIONAL_FLAG) {
      /* This cleanup action is conditional.  The next region entry
         contains a handle that points to the flag.  Check the flag and
         only process this entry if it is TRUE. */
#if 0
      /* The following line needs to be modified when stack offsets are
	 being used instead of an object address array. */
#endif /* 0 */
      /* The object information is pointed to directly by the region entry. */
      flag_addr = (a_conditional_flag*)*(obj_addr_array + (ehrdp + 1)->handle);
#if DEBUG
      if (__debug_level >= 2) {
        fprintf(__f_debug, "  Conditional flag=%0d\n", *flag_addr);
      }  /* if */
#endif /* DEBUG */
      /* Skip processing of this entry if the flag is not set. */
      if (!*flag_addr) continue;
    }  /* if */
    if ((flags & RDF_SUBOBJECT_VTABLE) != 0 &&
        (flags & RDF_BASE_CLASS_SUBOBJECT) != 0) {
      /* This is a subobject destruction that has a special vtable pointer
         that is to be used.  The next region table entry contains a handle
         that points to the vtable address to be used.  If there is a
         conditional flag, the handle is in the region table entry after
         the conditional flag. */
      an_eh_region_descr_ptr	vtbl_ehrdp;
      vtbl_ehrdp = ehrdp + 1;
      if (flag_addr != NULL) vtbl_ehrdp++;
#if 0
      /* The following line needs to be modified when stack offsets are
	 being used instead of an object address array. */
#endif /* 0 */
      vtbl_ptr = *(void**)(obj_addr_array + vtbl_ehrdp->handle);
      if (vtbl_ehrdp->flags & RDF_INDIRECT) {
        /* If the indirect flag is set on the vtable region entry, get the
           actual vtable pointer from the address referred to by the region
           table entry.  This is not used by the fully portable mechanism. */
        temp_addr = (char *)*(void**)vtbl_ptr;
        vtbl_ptr = (void *)temp_addr;
      }  /* if */
#if DEBUG
      if (__debug_level >= 2) {
        fprintf(__f_debug, "  Vtable pointer=%p\n", vtbl_ptr);
      }  /* if */
#endif /* DEBUG */
    }  /* if */
#if 0
    /* In an implementation that uses stack offsets instead of an object
       address table, the handle field in the region description entry 
       will be a stack offset to be added to either the stack base or the
       current "this" parameter (if RDF_THIS_PARAM_OFFSET is set). */
#endif /* 0 */
    if (flags & RDF_ARRAY) {
      /* The object information is contained in the array supplement. */
      ehasp = &ehsep->variant.function.array_table[ehrdp->handle];
      obj_addr = *(obj_addr_array + ehasp->handle);
    } else {
      /* The object information is pointed to directly by the region entry. */
      obj_addr = *(obj_addr_array + ehrdp->handle);
    }  /* if */
    if (flags & RDF_INDIRECT) {
      /* If the indirect flag is set, get the actual object address from
         the address referred to by the region table entry.  This is not
         used by the fully portable mechanism. */
      temp_addr = (char *)*(void**)obj_addr;
      obj_addr = (void *)temp_addr;
    }  /* if */
#if DEBUG
    if (__debug_level >= 2) {
      fprintf(__f_debug, "  object address=%p\n", (void*)obj_addr);
    }  /* if */
#endif /* DEBUG */
    /* Do the actual cleanup of the object. */
    if ((flags & RDF_GUARD_VAR_FOR_LOCAL_STATIC) != 0) {
      /* The cleanup object is the variable that is set when a local static
         variable is initialized.  When such an entry is on the cleanup list
         it means that the exception was thrown while the local static was
         being initialized.  The cleanup action is to reset the guard
         variable so that it will be initialized again the next time the
         declaration of the local static is reached.  The test of
         RDF_BASE_CLASS_SUBOBJECT is needed because the GUARD_VAR bit
         is shared with the SUBOBJECT_VTABLE bit. */
      flag_addr = (a_conditional_flag*)obj_addr;
#ifdef __EDG_IA64_ABI
      /* In the IA-64 ABI, the guard is not actually set until the object
         initialization is complete, so the guard variable does not really
         need to be cleared (although the runtime routine does do so).  The
         call of __cxa_guard_abort is primarily done so that a lock can be
         released, if the implementation uses such locks. */
      ABI_NAMESPACE::__cxa_guard_abort((unsigned long long*)flag_addr);
#else /* ifndef __EDG_IA64_ABI */
      *flag_addr = 0;
#endif /* ifdef __EDG_IA64_ABI */
    } else if (!(flags & RDF_NEW_ALLOCATION)) {
      /* A normal (not a new allocation) region.  Call the destructor for
         the object. */
      a_destructor_ptr	dtor_ptr;
      dtor_ptr = (a_destructor_ptr)ehrdp->destructor_or_delete_routine;
      printf("Reached %d with ehrdp=%p dtor_ptr=%p\n", __LINE__, ehrdp, dtor_ptr);
      if (flags & RDF_ARRAY) {
        an_element_count	elements = ehasp->array_size;
#ifndef __EDG_IA64_ABI
        __vec_delete(obj_addr, elements, ehasp->element_size, dtor_ptr,
                    /*delete_flag=*/FALSE, /*unused_arg=*/0);
#else /* ifdef __EDG_IA64_ABI */
        ABI_NAMESPACE::__cxa_vec_dtor(obj_addr, elements, 
                                      ehasp->element_size, dtor_ptr);
#endif /* ifdef __EDG_IA64_ABI */
      } else if (vtbl_ptr != NULL) {
        /* A non-array object for which a special destructor must be called
           in order to supply information about the construction vtable to
           be used. */
        a_destructor_with_vtable_param_ptr	dtor_with_vtable;
        dtor_with_vtable = (a_destructor_with_vtable_param_ptr)dtor_ptr;
        dtor_with_vtable(obj_addr, vtbl_ptr);
      } else {
#ifndef __EDG_IA64_ABI
        /* Not an array and not an object that requires special construction
           vtable information.  Just destroy the object.  If the object is a
           complete object, pass in the value "2" to indicate that the
	   object and any subobjects should be destroyed.  If the object
           is itself a base class subobject, pass in the value "0"
	   indicating that only the object (and not any subobjects)
	   should be destroyed. */
        (dtor_ptr)(obj_addr, (flags & RDF_BASE_CLASS_SUBOBJECT) ? 0 : 2);
#else /* ifdef __EDG_IA64_ABI */
        (dtor_ptr)(obj_addr);
#endif /* ifdef __EDG_IA64_ABI */
      }  /* if */
    } else {
      /* A new allocation region.  Call the delete operator to free the
         space. */
      if (obj_addr != NULL) {
        if (flags & RDF_ARRAY) {
          /* The array flag indicates that this is the two operand form of
             the delete operation. */
          a_two_operand_delete_ptr	delete_ptr;
          delete_ptr =
                (a_two_operand_delete_ptr)ehrdp->destructor_or_delete_routine;
          (delete_ptr)(obj_addr, ehasp->element_size);
        } else {
          a_delete_ptr	delete_ptr;
          delete_ptr = (a_delete_ptr)ehrdp->destructor_or_delete_routine;
          (delete_ptr)(obj_addr);
        }  /* if */
      }  /* if */
    }  /* if */
  }  /* for */
}  /* cleanup */


/*
Return TRUE if tp1_qualifiers does not have some type qualifier that
tp2_qualifiers has.
*/
#define any_qualifier_in_set_missing(tp1_qualifiers, tp2_qualifiers)  \
  ((~(tp1_qualifiers) & (tp2_qualifiers)) != 0)

#if ABI_COMPATIBILITY_VERSION >= 241

static a_boolean check_pointer_levels_and_qualifiers(
			an_exception_type_specification_ptr	etsp,
			an_ETS_flag_set				*ptr_flags)
/*
Compare the type specified by "ptr_flags" with the one specified by
"etsp".  If the pointers have the same number of levels, and if the
qualifiers are compatible, return TRUE; otherwise return FALSE.  The
caller has already verified that both types are multi-level pointers.
The caller is also responsible for ensuring that the types pointed to
are the same.  For the qualifiers to be compatible, a qualification
conversion, as described in 4.4 [conv.qual] of the standard must be
permitted.
*/
{
  a_boolean		okay;
  a_boolean		previous_qualifiers_include_const = TRUE;
  an_ETS_flag_set	*source_ptr_flags;
  an_ETS_flag_set	*dest_ptr_flags;

  dest_ptr_flags = etsp->ptr_flags;
  source_ptr_flags = ptr_flags;
  for (okay = TRUE; okay == TRUE;) {
    an_ETS_flag_set	dest_qualifiers;
    an_ETS_flag_set	source_qualifiers;
    /* Get the qualifiers for the current level. */
    dest_qualifiers = get_qualifiers(*dest_ptr_flags);
    source_qualifiers = get_qualifiers(*source_ptr_flags);
    if (is_last(*source_ptr_flags) != is_last(*dest_ptr_flags)) {
      /* The number of levels of pointers do not match. */
      okay = FALSE;
    } else if (any_qualifier_in_set_missing(dest_qualifiers,
                                            source_qualifiers)) {
      /* Some qualifier is missing. */
      okay = FALSE;
    } else {
      /* If the destination has additional qualifiers not found in the
         source, any previous qualifiers must have included const. */
      if (any_qualifier_in_set_missing(source_qualifiers,
				       dest_qualifiers)) {
	okay = previous_qualifiers_include_const;
	if (!okay) break;
      }  /* if */
      /* See if this qualifier includes const. */
      if (!is_const(dest_qualifiers)) {
	previous_qualifiers_include_const = FALSE;
      }  /* if */
    }  /* if */
    /* Terminate the loop if this is the last qualifier. */
    if (is_last(*source_ptr_flags)) break;
    dest_ptr_flags++;
    source_ptr_flags++;
  }  /* for */
  return okay;
}  /* check_pointer_levels_and_qualifiers */

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

static int check_exception_type_specifications
                        (an_exception_type_specification_ptr  etsp,
                         a_type_info_impl_ptr		      type_info,
			 an_ETS_flag_set		      flags,
			 an_ETS_flag_set		      *ptr_flags,
			 an_access_flag_string                access_flags,
			 a_boolean			      use_access_flags,
			 void**				      object_ptr,
			 an_exception_type_specification_ptr* etsp_found)
/*
Examine the exception type information associated with a given try block or
throw specification and determine whether any of the entries match the
object being thrown.  Returns 0 if no matching catch was found.  If a match
is found the position in the catch array is returned (actually, the array
index plus 1).  A pointer to the exception type specification of the matching
entry is returned in etsp_found.
*/
{
  int		        result = 0;
  int		        index = 0;
  a_boolean	        done = FALSE;
  a_boolean		is_ptr;

  *etsp_found = NULL;
  is_ptr = is_pointer(flags, ptr_flags);
  do {
    a_boolean	        match = FALSE;
    void*               new_ptr;
    a_boolean		ets_is_ptr;
    a_boolean		is_single_ptr;
    a_boolean		ets_is_single_ptr;
    an_access_flag_string local_access_flags = access_flags;
#if DEBUG
    void* orig_ptr = object_ptr != NULL ? *object_ptr : NULL;
#endif /* DEBUG */
    ets_is_ptr = is_pointer(etsp->flags, etsp->ptr_flags);
    ets_is_single_ptr = is_single_level_pointer(etsp->flags);
    is_single_ptr = is_single_level_pointer(flags);
    index++;
    if (is_ellipsis(etsp->flags)) {
      match = TRUE;
    } else if (ets_is_ptr != is_ptr) {
      /* One is a pointer and the other is not.  This can't be a match. */
    } else if (matching_type_info(etsp->type_info, type_info)) {
      /* The underlying types match.  Determine whether the any pointer levels
         above that type are acceptable. */
      if (!is_ptr) {
        /* Both are not pointers -- a match. */
        match = TRUE;
      } else if (is_single_ptr != ets_is_single_ptr) {
        /* One pointer is single level, the other is multi-level.  No match. */
      } else if (is_single_ptr) {
        /* Both are single level pointers.  Make sure that any qualifiers
           present on the source type are there on the destination. */
        an_ETS_flag_set	source_qualifiers = get_qualifiers(flags);
        an_ETS_flag_set	dest_qualifiers = get_qualifiers(etsp->flags);
        if (!any_qualifier_in_set_missing(dest_qualifiers,
                                          source_qualifiers)) {
          /* The qualifiers are acceptable. */
          match = TRUE;
        }  /* if */
#if ABI_COMPATIBILITY_VERSION >= 241
      } else {
        /* Both are multi-level pointers.  Make sure the source can be
           converted to the destination by a valid qualification conversion. */
        if (check_pointer_levels_and_qualifiers(etsp, ptr_flags)) {
          match = TRUE;
        }  /* if */
#endif /* ABI_COMPATIBILITY_VERSION >= 241 */
      }  /* if */
    }  /* if */
    if (match) {
      /* We already found a match -- doesn't check further. */
    } else if (ets_is_ptr != is_ptr) {
      /* One is a pointer and the other is not.  This can't be a match. */
    } else if (!qualifiers_acceptable(etsp->flags, flags)) {
      /* A pointer is being thrown to a catch without appropriate qualifiers.
         This is not a match.  This check only tests the lowest bottom level
         of qualifiers and used for the match of a conversion to void* and
         derived to base conversions below. */
#if ABI_CHANGES_FOR_RTTI
    } else if (
#ifndef __EDG_IA64_ABI
               etsp->type_info->unique_id != NULL &&
               etsp->type_info->unique_id ==
                                         &MANGLED_NAME_OF_UNIQUE_ID_OF_VOID &&
#else /* ifdef __EDG_IA64_ABI */
               matching_type_info(etsp->type_info, &typeid(void)) &&
#endif /* ifdef __EDG_IA64_ABI */
               (ets_is_ptr == is_ptr) && ets_is_single_ptr) {
      /* The exception type specification is a void * and the object
         being thrown is some kind of pointer.  This is a match. */
      match = TRUE;
#else /* !ABI_CHANGES_FOR_RTTI */
    } else if (etsp->type_info == &MANGLED_NAME_OF_VOID &&
               (ets_is_ptr == is_ptr) && ets_is_single_ptr) {
      /* The exception type specification is a void * and the object
         being thrown is some kind of pointer.  This is a match. */
      match = TRUE;
#endif /* !ABI_CHANGES_FOR_RTTI */
    } else if ((!is_ptr ||
               (is_single_ptr && ets_is_single_ptr)) &&
#ifndef __EDG_IA64_ABI
	       type_info->base_class_entries != NULL &&
#else /* ifdef __EDG_IA64_ABI */
               (typeid(*type_info) == typeid(abi::__si_class_type_info) ||
                typeid(*type_info) == typeid(abi::__vmi_class_type_info)) &&
#endif /* ifdef __EDG_IA64_ABI */
	       __derived_to_base_conversion(object_ptr, &new_ptr, type_info,
					    etsp->type_info,
					    &local_access_flags,
                                            use_access_flags)) {
      /* A base class of the class that was thrown.  If the base class
	 is ambiguous or inaccessible then the base class flag will not
         be set.  The pointer is converted from a pointer to the derived 
	 class to a pointer to the base class.  Object_ptr will be NULL
	 when this routine is call to check throw specifications and no
	 object is involved, in which case the pointer conversion will not be
	 done, but derived_to_base_conversion will return TRUE to indicate
	 that such a conversion is possible. */
      match = TRUE;
      /* If a derived to base conversion was done, update the object pointer
	 to point to the base class. */
      if (object_ptr != NULL) *object_ptr = new_ptr;
#if DEBUG
      if (object_ptr != NULL && *object_ptr != NULL) {
        if (__debug_level >= 3) {
          if (orig_ptr != *object_ptr) {
            fprintf(__f_debug, "Orig ptr=%p, new ptr=%p\n", orig_ptr,
                    *object_ptr);
          }  /* if */
        }  /* if */
      }  /* if */
#endif /* DEBUG */
    }  /* if */
    if (match) {
      result = index;
     *etsp_found = etsp;
      break;
    }  /* if */
    done = etsp->flags & ETS_LAST;
    etsp++;
  } while (!done);
  return result;
}  /* check_exception_type_specifications */


static void destroy_thrown_object(a_throw_stack_entry_ptr	tsep)
/*
Call the destructor for the copy of the object created by the runtime and
indicate that the throw stack entry may be discarded when it reaches the
top of the throw stack.
*/
{
  void*				object_address;
  a_throw_stack_entry_ptr	primary_tsep;

#if DEBUG
  if (__debug_level >= 6) {
    db_throw_stack("at start of destroy_thrown_object");
    fprintf(__f_debug, "Possibly destroying object associated with tsep %p\n",
            tsep);
  }  /* if */
#endif /* DEBUG */
  /* If this is a rethrow, get a pointer to the throw stack entry associated
     with the original throw. */
  primary_tsep = tsep->is_rethrow ? tsep->primary_entry : tsep;
  if (!tsep->discard_entry) {
    /* If this is the first time the routine has been called for this entry,
       set the discard flag and decrement the use count. */
    tsep->discard_entry = TRUE;
    primary_tsep->use_count--;
  }  /* if */
  /* If the entry can be destroyed, and the destructor has not already been
     called, then call it now. */
  if (primary_tsep->use_count == 0 && !primary_tsep->dtor_called) {
    /* Call the destructor for the object if needed. */
    primary_tsep->dtor_called = TRUE;
    object_address = primary_tsep->object_address;
    if (primary_tsep->object_copy_complete &&
        !is_pointer(primary_tsep->flags, primary_tsep->ptr_flags)) {
#if DEBUG
      if (__debug_level >= 4) {
        fprintf(__f_debug, "Destroying object at %p\n", object_address);
      }  /* if */
#endif /* DEBUG */
      a_destructor_ptr	dtor_ptr;
      dtor_ptr = (a_destructor_ptr)primary_tsep->destructor;
      if (dtor_ptr != NULL) {
#ifndef __EDG_IA64_ABI
        (dtor_ptr)(object_address, 2);
#else /* ifdef __EDG_IA64_ABI */
        (dtor_ptr)(object_address);
#endif /* ifdef __EDG_IA64_ABI */
      }  /* if */
    }  /* if */
  }  /* if */
}  /* destroy_thrown_object */


EXTERN_C void __exception_started()
/*
Marks the point at which an exception that is thrown is considered
"uncaught".  This is the point after the evaluation of the thrown
object, but before the object is copied to the EH temporary.  If the
copy to the temporary is elided, this point is after both the evaluation
and the copy that is integrated into the evaluation.
*/
{
  a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;

  /* Link the throw processing marker onto the EH stack. */
  tsep->throw_marker.next = __curr_eh_stack_entry;
  __curr_eh_stack_entry = &tsep->throw_marker;
  tsep->object_evaluation_complete = TRUE;
}  /* exception_started */


EXTERN_C void __exception_caught(void)
/*
Unlink the throw marker entry from the EH stack.  This is called after
the catch parameter has been copied.
*/
{
  check_assertion(__curr_eh_stack_entry->kind ==
                  ehsek_throw_processing_marker);
  __curr_eh_stack_entry = __curr_eh_stack_entry->next;
}  /* __exception_caught */


EXTERN_C int __throw(void)
/*
Process a throw.  This routine looks through the stack entries for
a try block with a catch that matches the type of the object thrown.
*/
{
  an_eh_stack_entry_ptr		ehsep;
  an_eh_stack_entry_ptr		destination_ehsep = NULL;
#if !UNWIND_STACK_BEFORE_CALLING_TERMINATE
  an_eh_stack_entry_ptr		non_internal_destination_ehsep = NULL;
#endif /* !UNWIND_STACK_BEFORE_CALLING_TERMINATE */
  int				destination_catch_value;
  void*				object_ptr;
  void*				object_buffer_ptr;
  a_type_info_impl_ptr		thrown_type_info;
  an_ETS_flag_set		throw_flags;
  an_ETS_flag_set		*throw_ptr_flags;
  an_exception_type_specification_ptr
				etsp_found;
  an_access_flag_string         access_flags;
  a_boolean			use_access_flags;

  if (!curr_throw_stack_entry->object_evaluation_complete) {
    /* If the __exception_started routine was not explicitly called by the
       code generated at the throw site, call it now. */
    __exception_started();
  }  /* if */
  /* When __throw is called we know that the object has been copied and
     must be destroyed when the throw stack entry is popped. */
  curr_throw_stack_entry->object_copy_complete = TRUE;
  /* Get the information about the current thrown object from the
     throw stack. */
  thrown_type_info = curr_throw_stack_entry->type_info;
  throw_flags = curr_throw_stack_entry->flags;
  throw_ptr_flags = curr_throw_stack_entry->ptr_flags;
  access_flags = curr_throw_stack_entry->access_flags;
  use_access_flags = curr_throw_stack_entry->use_access_flags;
  /* If the throw object is a pointer we copy the pointer into a separate
     buffer whose address is passed to the catch.  This is done because
     the pointer may undergo a conversion (such as derived to base) and we
     need to preserve the original pointer in case it is needed by a
     rethrow. */
  if (is_pointer(throw_flags, throw_ptr_flags)
/*** START TI ADD ***/ 
      && !is_pointer_to_func(throw_flags, throw_ptr_flags)
/*** END TI ADD ***/
      ) {
    /* It is a pointer.  object_buffer_ptr points to the special pointer
       buffer in the throw stack.  object_ptr contains the value of the
       pointer. */
    object_buffer_ptr = curr_throw_stack_entry->object_address;
    object_ptr = *(void**)object_buffer_ptr;
    object_buffer_ptr = (void*)&curr_throw_stack_entry->pointer_buffer;
  } else {
    /* It is not a pointer.  object_buffer_ptr points to the original copy
       of the object.  object_ptr points to the object buffer. */
    object_buffer_ptr = curr_throw_stack_entry->object_address;
    object_ptr = object_buffer_ptr;
  }  /* if */
#if DEBUG
  if (__debug_level >= 1) {
    fprintf(__f_debug, "__throw called\n");
  }  /* if */
#endif /* DEBUG */
  /* Get the address of the thrown object. */
  /* Find the try block that can catch the object being thrown. */
  ehsep = __curr_eh_stack_entry;
  check_assertion(ehsep == &curr_throw_stack_entry->throw_marker);
  /* Skip past the throw marker entry. */
  ehsep = ehsep->next;
  while (ehsep != NULL) {
    an_eh_stack_entry_kind	kind = ehsep->kind;
    if (kind == (an_eh_stack_entry_kind)ehsek_function) {
      /* Do nothing with function blocks at this time. */
    } else if (kind == (an_eh_stack_entry_kind)ehsek_vec_new_or_delete) {
      /* Do nothing with vec_new and vec_delete entries at this time. */
    } else if (kind == (an_eh_stack_entry_kind)ehsek_try_block) {
      if (ehsep->variant.try_block.catch_info == NULL) {
        /* Skip over try blocks for which a catch is active. */
        int result;
        if (ehsep->variant.try_block.catch_entries != NULL) {
          /* A normal (i.e., non-internal) try block.  See if any of the
            catch handlers match the object thrown. */
          result = check_exception_type_specifications
				(ehsep->variant.try_block.catch_entries,
				 thrown_type_info, throw_flags,
                                 throw_ptr_flags, access_flags,
				 use_access_flags, &object_ptr, &etsp_found);
        } else {
          /* An internal try block, which has no catch entries.  An internal
             try block is equivalent to a "catch (...)".  Set result to 1 to
             indicate that this is a valid handler for the throw.  The value
             of result will not be used in the handler code. */
          result = 1;
        }  /* if */
        if (result != 0) {
          /* A matching try block was found.  This could be an regular try
             block or an "internal" try block that is generated as part of
             the EH cleanup code for things like placement new operations
             (with matching placement delete functions).  Internal try
             blocks are treated like normal try blocks in all respects
             except that they are not considered a matching handler for
             purposes of determining whether or not terminate() should be
             called. */
          if (destination_ehsep == NULL) {
            destination_ehsep = ehsep;
            destination_catch_value = result;
          }  /* if */
          if (ehsep->variant.try_block.catch_entries != NULL) {
            /* This is a normal (i.e., not an internal) try block. */
#if !UNWIND_STACK_BEFORE_CALLING_TERMINATE
            non_internal_destination_ehsep = ehsep;
#endif /* !UNWIND_STACK_BEFORE_CALLING_TERMINATE */
            break;
          }  /* if */
        }  /* if */
      }  /* if */
    } else if (destination_ehsep != NULL) {
      /* Once a matching try block has been found, disregard an subsequent
         throw specification entries or throw processing markers that might
         be found.   The only other entries that are considered are
         non-internal try blocks to see if a matching handler can be found. */
      ehsep = ehsep->next;
      continue;
    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_spec) {
      /* Check for violations of throw specifications.  If a throw
         specification is violated we cleanup until we reach the
         violated throw specification and then call unexpected.
         If result is zero, no match was found.  If there is an empty
         specification then, by definition, no match is found. */
      int	result = 0;
      if (ehsep->variant.throw_specification != NULL) {
        an_exception_type_specification_ptr	dummy_etsp;
        result = check_exception_type_specifications
				  (ehsep->variant.throw_specification,
				   thrown_type_info, throw_flags,
                                   throw_ptr_flags, access_flags,
				   use_access_flags, (void**)NULL,
                                   &dummy_etsp);
      }  /* if */
      if (result == 0) {
        destination_ehsep = ehsep;
        break;
      }  /* if */
    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_processing_marker) {
      /* This entry is put on the stack before object cleanup begins.  If
         we find this marker it means that a destructor threw an
         exception that was not handled within the destructor.  The EH
         stack entry should point to the throw processing marker when
         exception_caught is called. */
      __curr_eh_stack_entry = ehsep;
      /* Indicate that the current thrown object is now in a handler.  This
         makes the object eligible for a rethrow. */
      curr_throw_stack_entry->in_handler = TRUE;
      __exception_caught();
      __call_terminate();
    } else {
      unexpected_condition();
    }  /* if */
    ehsep = ehsep->next;
  }  /* while */
#if !UNWIND_STACK_BEFORE_CALLING_TERMINATE
  /* If no matching (non-internal) handler was found, call terminate. */
  if (non_internal_destination_ehsep == NULL) {
      /* Indicate that the current thrown object is now in a handler.  This
         makes the object eligible for a rethrow. */
      curr_throw_stack_entry->in_handler = TRUE;
    __exception_caught();
    __call_terminate();
  }  /* if */
#endif /* !UNWIND_STACK_BEFORE_CALLING_TERMINATE */
  /* Go through the EH stack again and do any necessary cleanup. */
  ehsep = __curr_eh_stack_entry;
  /* Skip past the throw marker entry. */
  ehsep = ehsep->next;
  while (ehsep != destination_ehsep) {
    an_eh_stack_entry_kind	kind = ehsep->kind;
#if DEBUG
     if (__debug_level >= 2) {
       fprintf(__f_debug, "Processing EH stack entry at %p, kind=%d\n",
               (void *)ehsep, kind);
     }  /* if */
#endif /* DEBUG */
    if (kind == (an_eh_stack_entry_kind)ehsek_function) {
      cleanup(ehsep, __eh_curr_region, NULL_REGION_NUMBER);
      __eh_curr_region = ehsep->variant.function.saved_region_number;
    } else if (kind == (an_eh_stack_entry_kind)ehsek_vec_new_or_delete) {
      /* A vec_new or vec_delete operation that was in process when the
         exception occurred.  Call the routine to cleanup the partially
         constructed or destructed array. */
      __cleanup_vec_new_or_delete(ehsep);
    } else if (kind == (an_eh_stack_entry_kind)ehsek_try_block) {
      /* A try block that is being skipped. */
      if (ehsep->variant.try_block.catch_info != NULL) {
        /* A catch clause associated with this try block is currently
	   being processed.  Because this try block is being bypassed the
           throw entry is no longer needed.  It cannot be discarded yet
           because the thrown objects are allocated using a stack.  Call
           the destructor for the object and set a flag that this entry
           should be discarded when it reaches the top of the stack. */
        a_throw_stack_entry_ptr	tsep;
        tsep = (a_throw_stack_entry_ptr)ehsep->variant.try_block.catch_info;
        destroy_thrown_object(tsep);
      }  /* if */
    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_spec) {
      /* Do nothing. */
    } else if (kind == (an_eh_stack_entry_kind)ehsek_throw_processing_marker) {
      /* Do nothing. */
    } else {
      unexpected_condition();
    }  /* if */
    ehsep = ehsep->next;
  }  /* while */
#if UNWIND_STACK_BEFORE_CALLING_TERMINATE
  /* If no handler was found call the terminate function.  Note that this
     tests "destination_ehsep" instead of "non_internal_destination_ehsep".
     When an internal try block is the matching handler, it should be used
     to do the necessary cleanup even when no "real" matching handler is
     found.  When the internal try block does its rethrow, the rethrow will
     result in a call to terminate() when no matching handler is found. */
  if (destination_ehsep == NULL) {
    /* Indicate that the current thrown object is now in a handler.  This
       makes the object eligible for a rethrow. */
    curr_throw_stack_entry->in_handler = TRUE;
    __exception_caught();
    __call_terminate();
  }  /* if */
#endif /* UNWIND_STACK_BEFORE_CALLING_TERMINATE */
  if (destination_ehsep->kind == (an_eh_stack_entry_kind)ehsek_try_block) {
    /* A try block may have objects that must be cleaned up before
       transferring control to one of the catch clauses.  This is determined
       by comparing the current region number with the region number in
       the try block.  If they are different then some objects must be
       cleaned up.  Call the cleanup routine to cleanup objects until we
       reach the region number indicated by the value in the try block. */
    if (destination_ehsep->variant.try_block.region_number !=
							 __eh_curr_region) {
      /* Find the function entry that contains the cleanup information. */
      an_eh_stack_entry_ptr	function_ehsep = destination_ehsep->next;
      while (function_ehsep->kind != (an_eh_stack_entry_kind)ehsek_function) {
        function_ehsep = function_ehsep->next;
      }  /* while */
      cleanup(function_ehsep, __eh_curr_region,
              destination_ehsep->variant.try_block.region_number);
      /* Restore the region number to the appropriate value for entry to the
         catch clause. */
      __eh_curr_region = destination_ehsep->variant.try_block.region_number;
    }  /* if */
  }  /* if */

  /* Update the throw processing marker so that its "next" entry points
     to the appropriate location after all cleanup actions have taken
     place. */
  check_assertion(__curr_eh_stack_entry ==
                  &curr_throw_stack_entry->throw_marker);
  __curr_eh_stack_entry->next = destination_ehsep;
  /* Indicate that the current thrown object is now in a handler.  This makes
     the object eligible for a rethrow. */
  curr_throw_stack_entry->in_handler = TRUE;
  if (destination_ehsep->kind == (an_eh_stack_entry_kind)ehsek_try_block) {
    a_boolean	exception_caught = FALSE;
    __catch_clause_number = destination_catch_value;
    if (is_pointer(throw_flags, throw_ptr_flags)
/*** START TI ADD ***/ 
	&& !is_pointer_to_func(throw_flags, throw_ptr_flags)
/*** END TI ADD ***/
	) {
      /* The throw object is a pointer that may have underdone some
         kind of conversion such as a derived to base conversion.  Save
         the updated pointer.  Note that object_buffer_ptr has already
         been modified to point to a separate buffer so that the original
         pointer is preserved in case it is needed by a rethrow. */
      *(void**)object_buffer_ptr = object_ptr;
      __caught_object_address = object_buffer_ptr;
    } 
/*** START TI ADD ***/ 
    else if (is_pointer_to_func(throw_flags, throw_ptr_flags)) {
      __caught_object_address = object_buffer_ptr;
    }
/*** END TI ADD ***/
    else {
      /* The thrown object is not a pointer.  object_ptr starts out with the
         same value as object_buffer_ptr but may be modified my a
         derived to base conversion.  It still points somewhere within
         the object buffer, however. */
      __caught_object_address = object_ptr;
    }  /* if */
    /* Update the pointer in the try block to point to the throw stack entry
       for the thrown object. */
    destination_ehsep->variant.try_block.catch_info =
                                               (void*)curr_throw_stack_entry;
#if ABI_COMPATIBILITY_VERSION < 235
    /* Starting with ABI version 2.35, __exception_caught is called by
       __internal_rethrow at the conclusion of the catch clause associated
       with an internal try block. */
    if (destination_ehsep->variant.try_block.catch_entries == NULL) {
      /* For an internal try block an exception is considered caught as soon
         as the handler is started (because there is no copy constructor to
         be called to initialize the catch parameter).  Mark the exception
         as caught now. */
      exception_caught = TRUE;
    }  /* if */
#endif /* ABI_COMPATIBILITY_VERSION < 235 */
#if ABI_COMPATIBILITY_VERSION < 233
    /* ABI versions earlier than 2.33 don't include calls to the
       __exception_caught routine.  Call it explicitly here.  This
      is equivalent to the old behavior. */
    exception_caught = TRUE;
#endif /* ABI_COMPATIBILITY_VERSION < 233 */
    if (exception_caught) {
      /* Mark the exception as caught now, if appropriate. */
      __exception_caught();
    }  /* if */
    longjmp(destination_ehsep->variant.try_block.setjmp_buffer, 1);
  } else if (destination_ehsep->kind ==
                                (an_eh_stack_entry_kind)ehsek_throw_spec) {
    /* A destination stack entry indicates that a throw specification was
       violated.  Call unexpected.  The EH stack should point to the
       entry for the exception specification that was violated.  Remove
       the throw processing marker from the stack. */
    __curr_eh_stack_entry = __curr_eh_stack_entry->next;
#if !ABI_CHANGES_FOR_RTTI
   /* When RTTI is not used, the old semantics of unexpected() are used in
      which the type of an object thrown by unexpected is not checked against
      the violated exception specification.  Remove the EH stack entry
      for the violated throw specification. */
   __curr_eh_stack_entry = __curr_eh_stack_entry->next;
#endif /* ABI_CHANGES_FOR_RTTI */
    __call_unexpected();
  }  /* if */
  return 0;
}  /* __throw */


static void push_throw_stack(a_type_info_impl_ptr    type_info,
			     a_destructor_ptr	     destructor,
			     an_ETS_flag_set	     flags,
			     an_ETS_flag_set	     *ptr_flags,
                             an_access_flag_string   access_flags,
                             a_boolean               use_access_flags,
			     void*		     object_address,
			     a_boolean		     is_rethrow,
                             a_throw_stack_entry_ptr primary_entry)
/*
Push an entry onto the throw stack and initialize its fields.
*/
{
  a_throw_stack_entry_ptr	tsep;
  an_eh_stack_entry_ptr		ehsep;

  tsep =
      (a_throw_stack_entry_ptr)eh_alloc_on_stack(sizeof(a_throw_stack_entry));
  tsep->next = curr_throw_stack_entry;
  curr_throw_stack_entry = tsep;
  tsep->type_info = type_info;
  tsep->destructor = destructor;
  tsep->flags = flags;
  tsep->ptr_flags = ptr_flags;
  tsep->access_flags = access_flags;
  tsep->use_access_flags = use_access_flags;
  tsep->object_address = object_address;
  tsep->pointer_buffer = NULL;
  tsep->primary_entry = primary_entry;
  tsep->use_count = 0;
  /* If this is a rethrow, increment the use count of the primary entry.
     Otherwise, increment the use count of this entry. */
  if (is_rethrow) {
    primary_entry->use_count++;
  } else {
    tsep->use_count++;
  }  /* if */
  tsep->is_rethrow = is_rethrow;
  tsep->dtor_called = FALSE;
  tsep->discard_entry = FALSE;
  tsep->in_handler = FALSE;
  tsep->object_copy_complete = FALSE;
  tsep->object_evaluation_complete = FALSE;
  tsep->throw_marker.next = NULL;
  tsep->throw_marker.kind = ehsek_throw_processing_marker;
  /* Record a pointer to the nearest enclosing try block in the throw
     stack entry.  If this throw has the same nearest enclosing try block
     as the previous throw then the previous throw should be discarded.
     This can occur if a throw is done from a copy constructor called
     after __throw_alloc but before __throw. */
  ehsep = __curr_eh_stack_entry;
  while (ehsep != NULL) {
    /* Try blocks that are currently inside a handler are not considered. */
    if (ehsep->kind == (an_eh_stack_entry_kind)ehsek_try_block &&
        ehsep->variant.try_block.catch_info == NULL) break;
    ehsep = ehsep->next;
  }  /* while */
  tsep->nearest_enclosing_try_block = ehsep;
  if (tsep->next != NULL) {
    if (tsep->next->nearest_enclosing_try_block == ehsep) {
      /* There is a previous throw and it does point to the same nearest
         enclosing try block. */
      destroy_thrown_object(tsep);
    }  /* if */
  }  /* if */
}  /* push_throw_stack */


EXTERN_C void __rethrow(void)
/*
Rethrow the current thrown object.
*/
{
  a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;

  /* Find the throw stack entry for the throw currently being handled. */
  for (; tsep != NULL; tsep = tsep->next) {
    if (tsep->in_handler && !tsep->is_rethrow) break;
  }  /* for */
  if (tsep == NULL) {
    /* No handler is currently active. */
    __call_terminate();
  }  /* if */
  push_throw_stack(tsep->type_info,
                   tsep->destructor,
		   tsep->flags,
                   tsep->ptr_flags,
		   tsep->access_flags,
		   tsep->use_access_flags,
		   tsep->object_address,
		   /*is_rethrow=*/TRUE,
                   tsep);
  __throw();
}  /* __rethrow */


#if ABI_COMPATIBILITY_VERSION >= 235
EXTERN_C void __internal_rethrow(void)
/*
Entry point to rethrow used by internal try blocks.  This routine simply
calls __exception_caught to mark the throw as complete, then does a normal
rethrow.
*/
{
  __exception_caught();
  __rethrow();
}  /* __internal_rethrow */
#endif /* ABI_COMPATIBILITY_VERSION >= 235 */


/*
__throw_alloc is called for ABI versions that do not include RTTI.
When RTTI is supported, __throw_setup is called for ABI versions up to
and including 2.37, and in later ABI versions for types that have no
destructor.  The 2.38 ABI passes the destructor pointer to
__throw_setup_dtor, and removes it from the type_info_impl structure
to fix some corner cases in which a destructor is required solely for
the purpose of creating a type_info_impl object.  The 2.41 ABI uses
__throw_setup_ptr when a multi-level pointer is passed.  This is used
to supply additional information used for qualification conversions.
*/

#if ABI_COMPATIBILITY_VERSION >= 241

EXTERN_C void* __throw_setup_ptr(a_type_info_impl_ptr  type_info,
  			          a_sizeof_t	        size,
			          an_ETS_flag_set	*ptr_flags)
/*
Allocate space for the object to be thrown and save information about
the type being thrown.  This is like __throw_setup, except that the
a pointer to an array of ETS flags for multi-level pointers is passed.
*/
{
  void*				object_address;
  
  object_address = (void *)eh_alloc_on_stack(size);
  push_throw_stack(type_info, (a_destructor_ptr)NULL, ETS_NO_FLAGS,
                   ptr_flags, (an_access_flag_string)NULL,
	           /*use_access_flags=*/FALSE, object_address,
		   /*is_rethrow=*/FALSE,
                   (a_throw_stack_entry_ptr)NULL);
  return object_address;
}  /* __throw_setup_ptr */

#endif /* ABI_COMPATIBILITY_VERSION >= 241 */

#if ABI_CHANGES_FOR_RTTI
EXTERN_C void* __throw_setup(a_type_info_impl_ptr  type_info,
  			     a_sizeof_t	           size,
			     int	           ets_flags)
/*
Allocate space for the object to be thrown and save information about
the type being thrown.  This is like __throw_alloc, except no access_flags
are provided.  ets_flags is passed as an int (and not an_ETS_flag_set)
because that is how it is passed by the code generated by the front end.
*/
{
  void*				object_address;
  a_destructor_ptr		destructor;
  /* For ABI versions up to and including 2.37, the destructor pointer,
     if any, is stored in the type_info_impl object.  After 2.37, this
     routine is only used for objects without destructors. */
#if ABI_COMPATIBILITY_VERSION <= 237
  destructor = type_info->destructor;
#else /* !ABI_COMPATIBILITY_VERSION <= 237 */
  destructor = (a_destructor_ptr)NULL;
#endif /* ABI_COMPATIBILITY_VERSION <= 237 */
  object_address = (void *)eh_alloc_on_stack(size);
  push_throw_stack(type_info, destructor, ets_flags, (an_ETS_flag_set*)NULL,
                   (an_access_flag_string)NULL,
	           /*use_access_flags=*/FALSE, object_address,
		   /*is_rethrow=*/FALSE,
                   (a_throw_stack_entry_ptr)NULL);
  return object_address;
}  /* __throw_setup */

#if ABI_COMPATIBILITY_VERSION >= 238

EXTERN_C void* __throw_setup_dtor(a_type_info_impl_ptr  type_info,
  			          a_sizeof_t	        size,
			          int			ets_flags,
				  a_destructor_ptr	destructor)
/*
Allocate space for the object to be thrown and save information about
the type being thrown.  This is like __throw_setup, except that the
destructor pointer is passed as a parameter instead of being fetched
from the type_info_impl structure.  ets_flags is passed as an int (and
not an_ETS_flag_set) because that is how it is passed by the code
generated by the front end.
*/
{
  void*				object_address;

  object_address = (void *)eh_alloc_on_stack(size);
  push_throw_stack(type_info, destructor, ets_flags, (an_ETS_flag_set*)NULL,
                   (an_access_flag_string)NULL,
	           /*use_access_flags=*/FALSE, object_address,
		   /*is_rethrow=*/FALSE,
                   (a_throw_stack_entry_ptr)NULL);
  return object_address;
}  /* __throw_setup_dtor */

#endif /* ABI_COMPATIBILITY_VERSION >= 238 */

#else /* !ABI_CHANGES_FOR_RTTI */

EXTERN_C void* __throw_alloc(a_type_info_impl_ptr  type_info,
			     a_sizeof_t		   size,
			     int		   ets_flags,
			     an_access_flag_string access_flags)
/*
Allocate space for the object to be thrown and save information about
the type being thrown.  ets_flags is passed as an int (and not an_ETS_flag_set)
because that is how it is passed by the code generated by the front end.
*/
{
  void*				object_address;

  object_address = (void *)eh_alloc_on_stack(size);
  push_throw_stack(type_info, type_info->destructor, ets_flags,
                   (an_ETS_flag_set*)NULL, access_flags,
                   /*use_access_flags=*/TRUE,
		   object_address, /*is_rethrow=*/FALSE,
                   (a_throw_stack_entry_ptr)NULL);
  return object_address;
}  /* __throw_alloc */
#endif /* ABI_CHANGES_FOR_RTTI */


EXTERN_C void __free_thrown_object(void)
/*
Free the space used to make the copy of the thrown object.  Called at
the completion of a catch clause.
*/
{
#if DEBUG
  if (__debug_level >= 6) {
    db_throw_stack("at start of free_thrown_object");
  }  /* if */
#endif /* DEBUG */
  check_assertion(curr_throw_stack_entry != NULL);
  destroy_thrown_object(curr_throw_stack_entry);
  /* Free any entries with the discard_entry flag set.  This always frees
     the top entry but may also free additional entries associated with
     pending catches that were later skipped over by a throw. */
  while (curr_throw_stack_entry != NULL &&
         curr_throw_stack_entry->discard_entry) {
    a_throw_stack_entry_ptr	tsep = curr_throw_stack_entry;
    a_boolean			is_rethrow = tsep->is_rethrow;
    void*			object_address = tsep->object_address;
    /* If this is not a rethrow, the destructor should have already been
       called. */
    check_assertion(is_rethrow || tsep->dtor_called);
    /* Unlink this entry from the throw stack. */
    curr_throw_stack_entry = tsep->next;
    /* Free the space used for the throw stack entry.  Note that the stack
       entry and the object must be freed in the reverse of the order
       in which they were allocated since this is a stack. */
    eh_free_on_stack(tsep);
    if (!is_rethrow) {
      /* Free the space used for the copy of the object. */
      eh_free_on_stack(object_address);
    }  /* if */
  }  /* while */
#if DEBUG
  if (__debug_level >= 3) {
    db_throw_stack("at end of free_thrown_object");
  }  /* if */
#endif /* DEBUG */
}  /* __free_thrown_object */


EXTERN_C void __eh_exit_processing(void)
/*
Exit has been called.  Do any processing required to ensure that an
exception thrown by a static destructor or routine registered with
at_exit cannot throw beyond the exit call.
*/
{
  /* Clear the EH stack entry.  This will prevent a throw from finding
     a try block that was entered before exit was called. */
  __curr_eh_stack_entry = NULL;
}  /* __eh_exit_processing */


EXTERN_C void __suppress_optim_on_vars_in_try(void)
/*
Calls of this routine are generated when the C generating back end is
used.  It is used to make optimizers think that the addresses have been
taken of any local variables used inside a try block, thus ensuring that
their values will be saved when calling a routine inside the try block
that may throw an exception.  The routine is not supposed to actually
get called.
*/
{
  unexpected_condition();
} /* __suppress_optim_on_vars_in_try */

EXTERN_C an_eh_stack_entry_ptr __get_curr_eh_stack_entry(void)
/*
Return a pointer to __get_curr_eh_stack_entry.
*/
{
  return __curr_eh_stack_entry;
}  /* __get_curr_eh_stack_entry */


EXTERN_C void __type_of_thrown_object(a_type_info_impl_ptr	*type,
				      an_ETS_flag_set		*flags,
				      an_ETS_flag_set		**ptr_flags)
/*
Return a pointer to the typeinfo entry for the type of the object that
was thrown and the flags associated with the thrown object.
*/
{
  check_assertion(curr_throw_stack_entry != NULL);
  *type = curr_throw_stack_entry->type_info;
  *flags = curr_throw_stack_entry->flags;
  *ptr_flags = curr_throw_stack_entry->ptr_flags;
}  /* __type_of_thrown_object */


EXTERN_C a_boolean __can_throw_type(a_type_info_impl_ptr	type,
				    an_ETS_flag_set		flags,
				    an_ETS_flag_set		*ptr_flags)
/*
This routine is called by the code that checks whether an exception thrown
by unexpected() violates the current exception specification.  Find the
innermost exception specification and check whether the specified type
and flag combination is allowed.
*/
{
  a_boolean		result = FALSE;
  an_eh_stack_entry_ptr	ehsep;

  ehsep = __curr_eh_stack_entry;
  for (ehsep = __curr_eh_stack_entry; ehsep != NULL; ehsep = ehsep->next) {
    if (ehsep->kind == (an_eh_stack_entry_kind)ehsek_throw_spec) break;
  }  /* for */
  check_assertion(ehsep != NULL);
  if (ehsep->variant.throw_specification != NULL) {
    an_exception_type_specification_ptr	dummy_etsp;
    int					catch_pos;
    catch_pos = check_exception_type_specifications
				  (ehsep->variant.throw_specification,
				   type, flags, ptr_flags,
                                   (an_access_flag_string)NULL,
				   /*use_access_flags=*/FALSE, (void**)NULL,
                                   &dummy_etsp);
    if (catch_pos != 0) result = TRUE;
  }  /* if */
  return result;
}  /* __can_throw_type */

/*** START TI ADD ***/
/*
EH_CONTEXT is the data structure to hold the EH globals
*/
struct EH_CONTEXT
{
    a_region_number          eh_curr_region;
    an_eh_stack_entry_ptr    curr_eh_stack_entry;
    int                      catch_clause_number;
    void                    *caught_object_address;
    a_throw_stack_entry_ptr  curr_throw_stack_entry;
    a_mem_block_descr_ptr    curr_mem_block_descr;
    a_mem_allocation_ptr     mem_allocation_stack;
};
/*
 return the size of the memory block to hold the EH globals
*/
EXTERN_C int __eh_context_size()
{
    return sizeof(EH_CONTEXT);
}
/*
Store EH globals to "to"; and restore EH globals from "from"
*/
EXTERN_C void __swap_eh_context(void *restore_from_context, 
                                void *save_to_context)
{
    EH_CONTEXT *from = (EH_CONTEXT *)restore_from_context;
    EH_CONTEXT *to   = (EH_CONTEXT *)save_to_context;

    if (to)
    {
        to->eh_curr_region         = __eh_curr_region;
        to->curr_eh_stack_entry    = __curr_eh_stack_entry;
        to->catch_clause_number    = __catch_clause_number;
        to->caught_object_address  = __caught_object_address;
        to->curr_throw_stack_entry = curr_throw_stack_entry;
        to->curr_mem_block_descr   = curr_mem_block_descr;
        to->mem_allocation_stack   = mem_allocation_stack;
    }

    if (from)
    {
        __eh_curr_region         = from->eh_curr_region;
        __curr_eh_stack_entry    = from->curr_eh_stack_entry;
        __catch_clause_number    = from->catch_clause_number;
        __caught_object_address  = from->caught_object_address;
        curr_throw_stack_entry   = from->curr_throw_stack_entry;
        curr_mem_block_descr     = from->curr_mem_block_descr;
        mem_allocation_stack     = from->mem_allocation_stack;
    }
}

/*** END TI ADD ***/
#else /* !EXCEPTION_HANDLING */

EXTERN_C void __eh_exit_processing(void)
/*
A stub version of __eh_exit_processing that is used when the runtime is
built without exception handling support.  This version does nothing.
*/
{
}  /* __eh_exit_processing */

#endif /* EXCEPTION_HANDLING */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

time.c/         1146129410  0     0     0       543       `
/*****************************************************************************/
/*  TIME.C v4.1.3                                                            */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <time.h> 

extern _CODE_ACCESS time_t HOSTtime();

_CODE_ACCESS time_t time(time_t *timer) 
{
   time_t result;

   result = (time_t)HOSTtime();
   if(timer) *timer = result;
   return(result);
}


time.h/         1146129410  0     0     0       3487      `
/*****************************************************************************/
/* time.h     v4.1.3                                                         */
/* Copyright (c) 1990-2006  Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _TIME
#define _TIME

#include <linkage.h>

#define CLOCKS_PER_SEC 1000

#ifndef NULL
#define NULL      0
#endif

#ifdef __cplusplus
extern "C" namespace std {
#endif

typedef unsigned long clock_t;
typedef unsigned long time_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef __SIZE_T_TYPE__ size_t;
#endif

struct tm 
{
    int tm_sec;      /* seconds after the minute   - [0,59]  */
    int tm_min;      /* minutes after the hour     - [0,59]  */
    int tm_hour;     /* hours after the midnight   - [0,23]  */
    int tm_mday;     /* day of the month           - [1,31]  */
    int tm_mon;      /* months since January       - [0,11]  */
    int tm_year;     /* years since 1900                     */
    int tm_wday;     /* days since Sunday          - [0,6]   */
    int tm_yday;     /* days since Jan 1st         - [0,365] */
    int tm_isdst;    /* Daylight Savings Time flag           */
};

/*************************************************************************/
/* TIME ZONE STRUCTURE DEFINITION                                        */
/*************************************************************************/
typedef struct 
{
    short daylight;
    long  timezone;
    char  tzname[4];
    char  dstname[4];
} TZ;

extern _DATA_ACCESS TZ _tz;

/****************************************************************************/
/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */
/****************************************************************************/
_CODE_ACCESS clock_t    clock(void);             
_CODE_ACCESS time_t     time(time_t *_timer);   
 
_CODE_ACCESS time_t     mktime(struct tm *_tptr);
_CODE_ACCESS double     difftime(time_t _time1, time_t _time0);
      _IDECL char      *ctime(const time_t *_timer);
_CODE_ACCESS char      *asctime(const struct tm *_timeptr);
_CODE_ACCESS struct tm *gmtime(const time_t *_timer);
_CODE_ACCESS struct tm *localtime(const time_t *_timer);
_CODE_ACCESS size_t     strftime(char *_out, size_t _maxsize, 
				 const char *_format,
				 const struct tm *_timeptr);

#if defined(_INLINE) || defined(_CTIME_)

_IDEFN char *ctime(const time_t *timer)
{
   return(asctime(localtime(timer)));
}

#endif /* _INLINE || _CTIME_ */

#ifdef __cplusplus
} /* extern "C" */

#ifndef _CPP_STYLE_HEADER
using std::clock_t;
using std::time_t;
using std::size_t;
using std::tm;
using std::TZ;
using std::_tz;
using std::clock;
using std::time;
using std::mktime;
using std::difftime;
using std::ctime;
using std::asctime;
using std::gmtime;
using std::localtime;
using std::strftime;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::clock_t;
using std::time_t;
using std::size_t;
using std::tm;
using std::TZ;
using std::_tz;
using std::clock;
using std::time;
using std::mktime;
using std::difftime;
using std::ctime;
using std::asctime;
using std::gmtime;
using std::localtime;
using std::strftime;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* _TIME */

tmpfile.c/      1146129410  0     0     0       1371      `
/*****************************************************************************/
/*  TMPFILE.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPFILE  -  Create a temporary file, and return a pointer to the       */
/*                stream                                                     */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>


/*****************************************************************************/
/* TMPFILE  -  Create a temporary file, and return a pointer to its FILE     */
/*             structure                                                     */
/*****************************************************************************/
_CODE_ACCESS FILE *tmpfile(void)
{
   char tfname[L_tmpnam];
   FILE *_fp = (tmpnam(tfname)) ? (fopen(tfname, "wb+")) : NULL;

   if(_fp)
   {
      _SET(_fp, _TMPFILE);
      strcpy(_tmpnams[_fp->fd], tfname);
   }

   return (_fp);
}


tmpnam.c/       1146129410  0     0     0       4110      `
/*****************************************************************************/
/*  TMPNAM.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPNAM   -  Generate a unique filename                                 */
/*    _GETNAME -  Generate the character string for the filename             */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>

static char *_getname(int cnt, char *result);


/*****************************************************************************/
/* TMPNAM   -  Generate a unique filename                                    */
/*                                                                           */
/*    This function generates a unique filename, and can be called up to     */
/*    TMP_MAX times.                                                         */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS char *tmpnam(char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   static _DATA_ACCESS unsigned int  counter = 0;
   static _DATA_ACCESS char tfname[L_tmpnam];
   int  fd;
 
   /*------------------------------------------------------------------------*/ 
   /* Get a filename from _GETNAME                                           */
   /*------------------------------------------------------------------------*/ 
   _getname(counter++, tfname);

   /*------------------------------------------------------------------------*/ 
   /* Check to see if the filename exists.  Keep getting filenames until     */
   /* a unique one is found, or this function has reached its limit.         */
   /*------------------------------------------------------------------------*/ 
   while(((fd=open(tfname, O_RDONLY, 0666)) >= 0) && (counter < TMP_MAX))
   {
      close(fd);
      _getname(counter++, tfname);
   }
 
   if(counter >= TMP_MAX) return (NULL);
 
   /*------------------------------------------------------------------------*/ 
   /* If _S is not NULL, store the new filename in it.                       */
   /*------------------------------------------------------------------------*/ 
   if(_s)
   {
      strcpy(_s, tfname);
      return (_s);
   }
 
   return (tfname);
}


/*****************************************************************************/
/* _GETNAME -  Generate the character string for the filename                */
/*                                                                           */
/*    This function takes a number passed to it by TMPNAM, and generates a   */
/*    filename from it.  It returns a pointer to the filename.               */
/*                                                                           */
/*****************************************************************************/
static char *_getname(int cnt, char *result)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *end   = result + L_tmpnam -1;
   char *spos;
 
   strcpy(result, P_tmpdir);
   spos = (result + strlen(result));
 
   *(spos++) = 'T';
 
   for(;cnt; cnt /= 10) *(spos++) = ((cnt % 10)+ '0');
 
   for(;spos < end; *(spos++)='0');
   *(end--) = '\0';
 
   return (result);
}

tmzone.c/       1146129410  0     0     0       553       `
/*****************************************************************************/
/*  _tz v4.1.3                                                               */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <time.h>

_DATA_ACCESS TZ _tz =
{
   0,                       /* daylight */
   21600,                   /* timezone */
   "CST",                   /* tzname   */
   "DST",                   /* dstname  */
};


toascii.c/      1146129410  0     0     0       426       `
/****************************************************************************/
/*  toascii v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int toascii(int c)
{
    return(_toascii(c));
}

tolower.c/      1146129410  0     0     0       424       `
/****************************************************************************/
/*  tolower v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int tolower(int c)
{
    return(_tolower(c));
}
toupper.c/      1146129410  0     0     0       426       `
/****************************************************************************/
/*  toupper v4.1.3                                                          */
/*  Copyright (c) 1993-2006  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int toupper(int c)
{
    return(_toupper(c));
}

trgdrv.c/       1146129410  0     0     0       7660      `
/*****************************************************************************/
/*  TRGDRV.C v4.1.3                                                          */
/*  Copyright (c) 1996-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/****************************************************************************/
/* Functions:                                                               */
/*    HOSTopen()    -    Sends open command with arguments to the host      */
/*    HOSTclose()   -    Sends close command with arguments to the host     */
/*    HOSTread()    -    Sends read command with arguments to the host      */
/*    HOSTwrite()   -    Sends write command with arguments to the host     */
/*    HOSTlseek()   -    Sends lseek command with arguments to the host     */
/*    HOSTunlink()  -    Sends unlink command with arguments to the host    */
/*    HOSTrename()  -    Sends rename command with arguments to the host    */
/*    GETENV()      -    Get the enviroment value for the passed variable   */
/*                        name                                              */
/*    HOSTTIME()    -    Get the time from the host                         */
/*    HOSTCLK()     -    Get the target clock value (CLK register)          */
/****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <file.h>
#include <_lock.h>

#include <ankcio.h>

extern _CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd),
                        HOSTclose(int dev_fd),
                        HOSTread(int dev_fd, char *buf, unsigned count),
                        HOSTwrite(int dev_fd, const char *buf, unsigned count),
                        HOSTunlink(const char *path),
                        HOSTrename(const char *old_name, const char *new_name);

extern _CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin);
extern _CODE_ACCESS time_t HOSTtime(void);
extern _CODE_ACCESS clock_t HOSTclock(void);

extern _CODE_ACCESS void readmsg(register unsigned char *parm,
				 register char *data);

extern _CODE_ACCESS void writemsg(unsigned char  command,
                                  register const unsigned char *parm,
                                  register const          char *data,
                                  unsigned int   length);

static _DATA_ACCESS unsigned char parmbuf[8];

/****************************************************************************/
/* HOSTOPEN()  -  Pass the open command and its arguments to the host.      */
/****************************************************************************/
_CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd)
{
   int dev_fd;
   _lock();

   LOADSHORT(parmbuf,llv_fd,0);
   LOADSHORT(parmbuf,flags,2);
   writemsg(_DTOPEN,parmbuf,(char *)path,strlen(path)+1);
					 /* SEND NULL ACROSS ALSO */
   readmsg(parmbuf,NULL);

   dev_fd = UNLOADSHORT(parmbuf,0);
   _unlock();
   return (dev_fd < 0) ? dev_fd : llv_fd;
}

/****************************************************************************/
/* HOSTCLOSE()  -  Pass the close command and its arguments to the host.    */
/****************************************************************************/
_CODE_ACCESS int HOSTclose(int dev_fd)
{
   int result;
   _lock();

   LOADSHORT(parmbuf,dev_fd,0);

   writemsg(_DTCLOSE,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTREAD()  -  Pass the read command and its arguments to the host.      */
/****************************************************************************/
_CODE_ACCESS int HOSTread(int dev_fd, char *buf, unsigned count)
{
   int result;
   _lock();

   if (count > BUFSIZ) count = BUFSIZ;

   LOADSHORT(parmbuf,dev_fd,0);
   LOADSHORT(parmbuf,count,2);

   writemsg(_DTREAD,parmbuf,NULL,0);
   readmsg(parmbuf,buf);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTWRITE()  -  Pass the write command and its arguments to the host.    */
/****************************************************************************/
_CODE_ACCESS int HOSTwrite(int dev_fd, const char *buf, unsigned count)
{
   int result;
   _lock();

   if (count > BUFSIZ) count = BUFSIZ;

   LOADSHORT(parmbuf,dev_fd,0);
   LOADSHORT(parmbuf,count,2);
   writemsg(_DTWRITE,parmbuf,(char *)buf,count);
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTLSEEK()  -  Pass the lseek command and its arguments to the host.    */
/****************************************************************************/
_CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin)
{
   off_t result;
   _lock();

   LOADSHORT(parmbuf,dev_fd,0);
   LOAD32(parmbuf,offset,2);
   LOADSHORT(parmbuf,origin,6);

   writemsg(_DTLSEEK,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   result = UNLOAD32(parmbuf,0);
   _unlock();
   return result;
}

_CODE_ACCESS int HOSTunlink(const char *path)
{
   int result;
   _lock();

   writemsg(_DTUNLINK,parmbuf,(char *)path,strlen(path) + 1);
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

_CODE_ACCESS int HOSTrename(const char *old, const char *new)
{
   char combined[100];
   int  length; 
   int  result;
   _lock();

   strcpy(combined,old);
   length = strlen(old)+1;
   strcpy(combined+length,new);
   length += strlen(new) + 1;

   writemsg(_DTRENAME,parmbuf,combined,length);
                                                 /*SEND NULL ACROSS ALSO*/
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* GETENV()  -  Get the enviroment value for the passed variable name       */
/****************************************************************************/
_CODE_ACCESS char *getenv(const char *_string)
{
   static _DATA_ACCESS char result[200];
   _lock();

   writemsg(_DTGETENV,parmbuf,(char *)_string,strlen(_string) + 1);
   readmsg(parmbuf,result);

   _unlock();
   return strlen(result) ? result : 0;
}

/****************************************************************************/
/* HOSTTIME()  -  Get the time from the host                                */
/****************************************************************************/
_CODE_ACCESS time_t HOSTtime(void)
{
   time_t result;
   _lock();

   writemsg(_DTGETTIME,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   result = (time_t)(UNLOAD32(parmbuf,0));
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTclock()  -  Get the current number of clock ticks                    */
/****************************************************************************/
_CODE_ACCESS clock_t HOSTclock(void)
{
   clock_t result;
   _lock();

   writemsg(_DTGETCLK,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   result = (clock_t)(UNLOAD32(parmbuf,0));
   _unlock();
   return result;
}
typeinfo/       1146129410  0     0     0       1899      `
/*****************************************************************************/
/* typeinfo  v4.1.3                                                          */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/
#if __EXCEPTIONS
#define THROW(throw_spec) throw(throw_spec)
#define THROW_NOTHING() throw()
#else /* !__EXCEPTIONS */
#define THROW(throw_spec) /* Nothing. */
#define THROW_NOTHING() /* Nothing. */
#endif /* __EXCEPTIONS */

#ifndef _TYPEINFO
#define _TYPEINFO

#ifndef __embedded_cplusplus

#include <stdexcept>
namespace std 
{

   class bad_cast   
   {
   public:
     bad_cast() throw() { };
     bad_cast(const bad_cast&) throw() {};
     bad_cast& operator=(const bad_cast& rhs) throw() 
	{   
	    operator=(rhs);
            return *this;
        }
     virtual ~bad_cast() throw() {};
     virtual const char* what() const throw() { return ""; };
   };
   class bad_typeid 
   {
   public:
	bad_typeid() throw() {};
	bad_typeid(const bad_typeid& ) throw() {};
	bad_typeid& operator=(const bad_typeid& rhs) throw()
	{
  	  operator=(rhs);
  	  return *this;
	};	
        virtual ~bad_typeid() throw() {};
	virtual const char* what() const throw() { return ""; };
  };

#pragma define_type_info
   class type_info 
   {
      public:
	 virtual ~type_info();
	 bool operator==(const type_info& rhs) const;
	 bool operator!=(const type_info& rhs) const;
	 bool before( const type_info& rhs) const;
	 const char* name() const;
      protected:
	 type_info(const type_info& rhs);
      private:
	 type_info& operator=(const type_info& rhs);

#ifdef __EDG_IA64_ABI
  private:
    const char *__type_name;
#endif /* ifdef __EDG_IA64_ABI */
   };

}
#endif /* __embedded_cplusplus */
#endif /*_TYPEINFO */

typeinfo_.cpp/  1146129410  0     0     0       10381     `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Run-time type identification -- user callable functions.

*/

#include "basics.h"
#include "runtime.h"

#if ABI_CHANGES_FOR_RTTI

#include "rtti.h"
#include <typeinfo>

/*
If the runtime should be defined in the std namespace, open
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace std {
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */


__bool type_info::operator==(const type_info& rhs) const
/*
Return TRUE if two type_info structures refer to the same type.
*/
{
  a_type_info_impl_ptr  tiip1;
  a_type_info_impl_ptr  tiip2;

  tiip1 = (a_type_info_impl_ptr)this;
  tiip2 = (a_type_info_impl_ptr)&rhs;
  return matching_type_info(tiip1, tiip2);
}  /* type_info::operator== */


__bool type_info::operator!=(const type_info& rhs) const
/*
Return TRUE if two type_info structures do not refer to the same type.
*/
{
  a_type_info_impl_ptr  tiip1;
  a_type_info_impl_ptr  tiip2;

  tiip1 = (a_type_info_impl_ptr)this;
  tiip2 = (a_type_info_impl_ptr)&rhs;
  return !matching_type_info(tiip1, tiip2);
}  /* type_info::operator!= */


__bool type_info::before(const type_info& rhs) const
/*
Return TRUE if the type_info for *this precedes the type_info for rhs using
some implementation dependent collating sequence.
*/
{
#ifdef __EDG_IA64_ABI
  /* Do the comparison based on the address at which the type name string
     is allocated.  The name string is guaranteed by the ABI to be unique. */
  return __type_name < rhs.__type_name;
#else /* defined(__EDG_IA64_ABI) */
  /* This is implemented by comparing the pointers used to represent the type
     information.  If the type_info_impl has a unique_id, the address of the
     unique_id is used for collation.  If it does not have a unique_id (i.e.,
     we know there is only a single type_info_impl structure for the type) then
     the address of the single type_info_impl is used for collation. */
  a_type_info_impl_ptr  tiip1;
  a_type_info_impl_ptr  tiip2;
  void*                 ptr1;
  void*                 ptr2;

  tiip1 = (a_type_info_impl_ptr)this;
  tiip2 = (a_type_info_impl_ptr)&rhs;
  ptr1 = tiip1->unique_id != NULL ? (void*)tiip1->unique_id : (void*)tiip1;
  ptr2 = tiip2->unique_id != NULL ? (void*)tiip2->unique_id : (void*)tiip2;
  return ptr1 < ptr2;
#endif /* defined(__EDG_IA64_ABI) */
}  /* type_info::before */


const char * type_info::name() const
/*
Returns a pointer to the name string for this type.
*/
{
#ifndef __EDG_IA64_ABI
  a_type_info_impl_ptr  tiip1;

  tiip1 = (a_type_info_impl_ptr)this;
  return tiip1->name;
#else /* defined(__EDG_IA64_ABI) */
  return __type_name;
#endif /* defined(__EDG_IA64_ABI) */
}  /* type_info::name */


type_info::~type_info()
/*
Destructor for type_info.  This should never actually be called.
*/
{
}  /* type_info::~type_info */


/* The definition of the exception classes can be disabled. */
#if USE_EDG_EXCEPTION_CLASSES

#if EXCEPTION_HANDLING

/*
The bad_cast class is only supplied when the runtime supports exception
handling.
*/
/*** START TI ADD ***/
/*
In TI's EH implementation,bad_cast, bad_typeid's declaration and 
definition have been moved to header file <typeinfo> for better
readibility.

So we comment this definition out here.
*/
#if 0 /* TI move to header file <typeinfo> */ 
/*** END TI ADD ***/
bad_cast::bad_cast() THROW_NOTHING()
/*
Constructor for bad_cast.
*/
{
}  /* bad_cast::bad_cast */


bad_cast::bad_cast(const bad_cast& rhs) THROW_NOTHING() : exception(rhs)
/*
Copy constructor for bad_cast.  Currently does nothing.
*/
{
}  /* bad_cast::bad_cast */


bad_cast& bad_cast::operator=(const bad_cast& rhs) THROW_NOTHING()
/*
Assignment operator for bad_cast.  Currently does nothing.
*/
{
  /* Call the base class assignment operator. */
  exception::operator=(rhs);
  return *this;
}  /* bad_cast::operator= */


bad_cast::~bad_cast() THROW_NOTHING()
/*
Destructor for bad_cast.
*/
{
}  /* bad_cast::~bad_cast */


const char* bad_cast::what() const THROW_NOTHING()
/*
Return a string providing information about the exception.  Currently,
no additional information is available.
*/
{
  return "";
}  /* bad_cast::~bad_cast */


bad_typeid::bad_typeid() THROW_NOTHING()
/*
Constructor for bad_typeid.
*/
{
}  /* bad_typeid::bad_typeid */


bad_typeid::bad_typeid(const bad_typeid& rhs) THROW_NOTHING() : exception(rhs)
/*
Copy constructor for bad_typeid.  Currently does nothing.
*/
{
}  /* bad_typeid::bad_typeid */


bad_typeid& bad_typeid::operator=(const bad_typeid& rhs) THROW_NOTHING()
/*
Assignment operator for bad_typeid.  Currently does nothing.
*/
{
  /* Call the base class assignment operator. */
  exception::operator=(rhs);
  return *this;
}  /* bad_typeid::operator= */


bad_typeid::~bad_typeid() THROW_NOTHING()
/*
Destructor for bad_typeid.
*/
{
}  /* bad_typeid::~bad_typeid */


const char* bad_typeid::what() const THROW_NOTHING()
/*
Return a string providing information about the exception.  Currently,
no additional information is available.
*/
{
  return "";
}  /* bad_typeid::~bad_typeid */
/*** START TI ADD ***/
#endif /* TI move to header file <typeinfo> */
/*** END TI ADD ***/
#endif /* EXCEPTION_HANDLING */

#endif /* USE_EDG_EXCEPTION_CLASSES */

#ifdef __EDG_IA64_ABI

/*
Define the type_info objects that are supposed to be present in the runtime
library.  Try to work hard enough that the compiler won't eliminate the
generation of the type_info objects.
*/
const type_info *__dummy_typeinfo;
void __gen_dummy_typeinfos()
{
#define gen_typeinfos(type)                 \
  __dummy_typeinfo = &typeid(type),         \
  __dummy_typeinfo = &typeid(type *),       \
  __dummy_typeinfo = &typeid(const type *)
  gen_typeinfos(void); 
  gen_typeinfos(bool); 
  gen_typeinfos(wchar_t);
  gen_typeinfos(char); 
  gen_typeinfos(signed char); gen_typeinfos(unsigned char); 
  gen_typeinfos(short);       gen_typeinfos(unsigned short); 
  gen_typeinfos(int);         gen_typeinfos(unsigned int); 
  gen_typeinfos(long);        gen_typeinfos(unsigned long); 
  gen_typeinfos(long long);   gen_typeinfos(unsigned long long);
  gen_typeinfos(float); 
  gen_typeinfos(double); 
  gen_typeinfos(long double);
#undef gen_typeinfos
}
  
#endif /* ifdef __EDG_IA64_ABI */

/*
If the runtime should be defined in the std namespace, close
the std namespace.
*/
#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace std */
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

#ifdef __EDG_IA64_ABI
#ifdef __EDG_RUNTIME_USES_NAMESPACES
namespace __cxxabiv1 {
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */

__fundamental_type_info::~__fundamental_type_info()
/*
Destructor for __fundamental_type_info.  This should never actually be 
called.  
*/
{
}  /* __fundamental_type_info::~__fundamental_type_info */


__array_type_info::~__array_type_info()
/*
Destructor for __array_type_info.  This should never actually be 
called.  
*/
{
}  /* __array_type_info::~__array_type_info */


__function_type_info::~__function_type_info()
/*
Destructor for __function_type_info.  This should never actually be 
called.  
*/
{
}  /* __function_type_info::~__function_type_info */


__enum_type_info::~__enum_type_info()
/*
Destructor for __enum_type_info.  This should never actually be 
called.  
*/
{
}  /* __enum_type_info::~__enum_type_info */


__class_type_info::~__class_type_info()
/*
Destructor for __class_type_info.  This should never actually be 
called.  
*/
{
}  /* __class_type_info::~__class_type_info */


__si_class_type_info::~__si_class_type_info()
/*
Destructor for __si_class_type_info.  This should never actually be 
called.  
*/
{
}  /* __si_class_type_info::~__si_class_type_info */


__vmi_class_type_info::~__vmi_class_type_info()
/*
Destructor for __vmi_class_type_info.  This should never actually be 
called.  
*/
{
}  /* __vmi_class_type_info::~__vmi_class_type_info */


__pbase_type_info::~__pbase_type_info()
/*
Destructor for __pbase_type_info.  This should never actually be 
called.  
*/
{
}  /* __pbase_type_info::~__pbase_type_info */


__pointer_type_info::~__pointer_type_info()
/*
Destructor for __pointer_type_info.  This should never actually be 
called.  
*/
{
}  /* __pointer_type_info::~__pointer_type_info */


__pointer_to_member_type_info::~__pointer_to_member_type_info()
/*
Destructor for __pointer_to_member_type_info.  This should never actually be 
called.  
*/
{
}  /* __pointer_to_member_type_info::~__pointer_to_member_type_info */

#ifdef __EDG_RUNTIME_USES_NAMESPACES
}  /* namespace __cxxabiv1 */
#endif /* ifdef __EDG_RUNTIME_USES_NAMESPACES */
#endif /* ifdef __EDG_IA64_ABI */

#endif /* ABI_CHANGES_FOR_RTTI */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

u_div.asm/      1146129410  0     0     0       431       `
******************************************************************************
* u_div.asm  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "u_div27.inc"
        .elseif .TMS320C2800
                .include "u_div28.inc"
        .endif


u_div27.inc/    1146129410  0     0     0       2622      `
******************************************************************************
* u_div27.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the functions for unsigned 16-bit divide and modulus.
*
* Upon entry the numerator is in AH, the denominator is in AL.
* Stack memory is not used.
******************************************************************************

******************************************************************************
* 16-BIT UNSIGNED DIVIDE, CALCULATE Q / D AND RETURN IN ACCUMULATOR "A"
******************************************************************************
	.global	U$$DIV

U$$DIV:	.asmfunc
******************************************************************************
* PREPARATION
******************************************************************************
	MOV	AR6,AH		; move denominator to clear AH
	MOVB	AH,#0		; clear AH

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,AR6		; divide step

******************************************************************************
* QUOTIENT IS IN AL
******************************************************************************
	FFCRET	*XAR7		; return
	.endasmfunc

	.page
******************************************************************************
* 16-BIT UNSIGNED MODULUS, CALCULATE Q % D AND RETURN IN ACCUMULATOR "A"
******************************************************************************
	.global	U$$MOD

U$$MOD:	.asmfunc
******************************************************************************
* PREPARATION
******************************************************************************
	MOV	AR6,AH		; move denominator to clear AH
	MOVB	AH,#0		; clear AH

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,AR6		; divide step

******************************************************************************
* QUOTIENT IS IN AL, REMAINDER IS IN AH
******************************************************************************
	MOV	AL,AH		; move remainder to return reg (AL)
	FFCRET	*XAR7		; return
	.endasmfunc
u_div28.inc/    1146129410  0     0     0       2622      `
******************************************************************************
* u_div28_inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the functions for unsigned 16-bit divide and modulus.
*
* Upon entry the numerator is in AH, the denominator is in AL.
* Stack memory is not used.
******************************************************************************

******************************************************************************
* 16-BIT UNSIGNED DIVIDE, CALCULATE Q / D AND RETURN IN ACCUMULATOR "A"
******************************************************************************
	.global	U$$DIV

U$$DIV:	.asmfunc
******************************************************************************
* PREPARATION
******************************************************************************
	MOV	AR6,AH		; move denominator to clear AH
	MOVB	AH,#0		; clear AH

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,AR6		; divide step

******************************************************************************
* QUOTIENT IS IN AL
******************************************************************************
	FFCRET	*XAR7		; return
	.endasmfunc

	.page
******************************************************************************
* 16-BIT UNSIGNED MODULUS, CALCULATE Q % D AND RETURN IN ACCUMULATOR "A"
******************************************************************************
	.global	U$$MOD

U$$MOD:	.asmfunc
******************************************************************************
* PREPARATION
******************************************************************************
	MOV	AR6,AH		; move denominator to clear AH
	MOVB	AH,#0		; clear AH

******************************************************************************
* PERFORM DIVIDE
******************************************************************************
	RPT	#15		; repeat 16 times
||	SUBCU	ACC,AR6		; divide step

******************************************************************************
* QUOTIENT IS IN AL, REMAINDER IS IN AH
******************************************************************************
	MOV	AL,AH		; move remainder to return reg (AL)
	FFCRET	*XAR7		; return
	.endasmfunc
u_tofd.asm/     1146129410  0     0     0       703       `
*;*****************************************************************************
*;                                                                            *
*;  U_TOFD v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  U$$TOFD - Convert an unsigned 16 bit integer into an IEEE 754 format      *
*;            double precision floating point number                          *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "u_tofd28.inc"
        .endif

u_tofd28.inc/   1146129410  0     0     0       6953      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  U_TOFD v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  U$$TOFD  - Convert an unsigned 16 bit integer into an IEEE 754 format     *
;*             double precision floating point number			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN AL   
;*   o RESULT IS RETURNED IN *XAR6
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                           AR4  |        | RES_EXP  |       *
;*                                                +-------------------+       *
;*                                          XAR6  | PTR TO RET VALUE  |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   U$$TOFD
        .sect     ".text"

U$$TOFD	.asmfunc
        .asg      XAR4,    XRES_EXP
        .asg       AR4,    RES_EXP
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
        MOVL    P, ACC            ; Save input float
        MOVL    ACC, XAR6         ;
        B       RETURN, EQ        ; Return if return pointer is null
*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Load the initial exponent value 0x40D                                 *
*;    3 If input is negative (MSB is 1)                                       *
*;        - Right shift by one so that MSB is in bit 62                       *
*;        - Set the exponent to  0x3FF + 0xF = 0x40E                          *
*;    4 If input is positive (MSB is 0)                                       *
*;        - Normalize the mantissa so that MSB is in bit 62                   *
*;        - Set the exponent to 0x40D - nn, where nn is the number of bits    *
*;          shifted out for normalization.                                    *
*;*****************************************************************************
*
        MOVL    ACC, P          ; Restore input in ACC
        LSL  	ACC, #16	; Move integer to AH
	B	OP_ZERO, EQ	; Return zero if integer is zero

	MOV 	P, #0 		; Zero out P
	MOVL	XRES_EXP, #0x40D; Load the initial exponent value             

	B	NORMALIZE, GT	; Normalize if MSB is zero; 
	LSR64 	ACC:P, #1	; MSB is 1 so adjust the mantissa
	INC 	RES_EXP    	; and adjust the exponent
	B	PACK, UNC
NORMALIZE:
	RPT	#15		; Normalize the value and adjust the exponent
     || NORM	ACC, XRES_EXP--	;
	
*
*;*****************************************************************************
*;       PACK mantissa and exponent into Double precision format.             *
*;*****************************************************************************
*
PACK:
	LSR64	ACC:P, #14	; Move the mantissa out of AH. Since only 16 
				; bits of the mantissa are significant this 
				; is not a problem
	MOV	AH, RES_EXP	; Load exponent and remove implied one 
	LSL64	ACC:P, #4	; Shift back mantissa and exponent
*
RETURN_VALUE:
        MOVL    RES_LSW, P     ;
        MOVL    RES_MSW, ACC   ; Load the return value in the return area.
RETURN:
        LRETR

        .page
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
OP_ZERO:
        ZAPA	                  ; For underflow result in ACC:P = 0
        B       RETURN_VALUE,UNC
	.endasmfunc

u_tofs.asm/     1146129410  0     0     0       707       `
*;*****************************************************************************
*;                                                                            *
*;  U$$TOFS v4.1.3							      *
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;  Convert a 16-bit unsigned integer to floating point                       *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "u_tofs27.inc"
        .elseif .TMS320C2800
                .include "u_tofs28.inc"
        .endif

u_tofs27.inc/   1146129410  0     0     0       8961      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  U$$TOFS v4.1.3							      *
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;  Convert a 16-bit unsigned integer to floating point                       *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       U$$TOFS                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a 16-bit unsigned       AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in AL.                                     *
*;       When the conversion is complete                                      *
*;       the float value will be in ACC.                                      *
*;                                                                            *
*;       inputs: unsigned 16-bit integer in AL                                *
*;                                                                            *
*;       implementation:  The value of the                                    *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            into ACC                                                        *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   U$$TOFS

U$$TOFS  .asmfunc
	 .asg	AR4, EXPONENT
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the two cases it belongs.     *
*;    Case 1:  value is 0; branch to return                                   *
*;    Case 2:  all other values                                               *
*;*****************************************************************************
*
        LSL     ACC, 15         ; move integer to AH for norm 
        AND     AH, #07FFFh     ; add positive sign bit
        TEST    ACC
        B       ZERO, EQ        ; branch if integer == 0
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (0Fh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOV     EXPONENT, #08Eh ; set exponent count to 0Fh (offset binary)

	RPT	#31
     || NORM    ACC, EXPONENT-- ; normalize ACC to get mantissa value and
                                ; find actual exponent value
* 
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM M000 0000 0000 0000]                *
*;  Shift mantissa   [0000 0000 0000 0000 0MMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0000 0000 0EEE EEEE EMMM MMMM MMMM MMMM]                *
*;  Shift for        [0EEE EEEE EMMM MMMM MMMM MMMM 000 0000]                 *
*;*****************************************************************************
*
        AND     AH, #03FFFh         ; remove implied one and sign bit
        CLRC    SXM
        SFR     ACC, 15             ; shift mantissa to make room for exponent
        ADD     ACC, EXPONENT << 15 ; pack exponent
        LSL     ACC, 8              ; shift for correct placement
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RESTORE
ZERO
        RET
	.endasmfunc

u_tofs28.inc/   1146129410  0     0     0       8993      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  U$$TOFS v4.1.3							      *
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;  Convert a 16-bit unsigned integer to floating point                       *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       U$$TOFS                                             register file    *
*;                                                         +----------------+ *
*;       This routine converts a 16-bit unsigned       AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in AL.                                     *
*;       When the conversion is complete                                      *
*;       the float value will be in ACC.                                      *
*;                                                                            *
*;       inputs: unsigned 16-bit integer in AL                                *
*;                                                                            *
*;       implementation:  The value of the                                    *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            into ACC                                                        *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;                                                                            *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   U$$TOFS

U$$TOFS  .asmfunc
	 .asg	AR4, EXPONENT
	 .asg	XAR4, XEXPONENT
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the two cases it belongs.     *
*;    Case 1:  value is 0; branch to return                                   *
*;    Case 2:  all other values                                               *
*;*****************************************************************************
*
        LSL     ACC, 15         ; move integer to AH for norm 
        AND     AH, #07FFFh     ; add positive sign bit
        TEST    ACC
        B       ZERO, EQ        ; branch if integer == 0
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (0Fh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOVB    XEXPONENT, #08Eh ; set exponent count to 0Fh (offset binary)

	RPT	#31		 ;
     || NORM    ACC, XEXPONENT-- ; normalize ACC to get mantissa value and
                                ; find actual exponent value
* 
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM M000 0000 0000 0000]                *
*;  Shift mantissa   [0000 0000 0000 0000 0MMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0000 0000 0EEE EEEE EMMM MMMM MMMM MMMM]                *
*;  Shift for        [0EEE EEEE EMMM MMMM MMMM MMMM 000 0000]                 *
*;*****************************************************************************
*
        AND     AH, #03FFFh         ; remove implied one and sign bit
        CLRC    SXM
        SFR     ACC, 15             ; shift mantissa to make room for exponent
        ADD     ACC, EXPONENT << 15 ; pack exponent
        LSL     ACC, 8              ; shift for correct placement
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RESTORE
ZERO
        LRETR
	.endasmfunc

ul_lsr.asm/     1146129410  0     0     0       363       `
******************************************************************************
* ul_lsr.asm  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "ul_lsr27.inc"
        .endif


ul_lsr27.inc/   1146129410  0     0     0       1201      `
******************************************************************************
* ul_lsr27.inc  v4.1.3
* Copyright (c) 1997-2006      Texas Instruments Incorporated
******************************************************************************

******************************************************************************
* This module contains the routine for unsigned 32-bit right shift
*
* Value to be shifted is passed in accumulator.
* Shift value is passed in AR4.
*
* No stack memory used.
******************************************************************************

******************************************************************************
* 32-BIT UNSIGNED RIGHT SHIFT
******************************************************************************
	.global	UL$$LSR

UL$$LSR:	.asmfunc
        MOV     T,AR4           ; move shift arg to T 
	CLRC	SXM		; turn off sign extension mode
        TBIT    T,#4            ; see if CNT >= 16
        B       LT16,NTC        ; branch if it isn't
        SFR     ACC,16          ; shift the first 16
LT16:
        SFR     ACC,T           ; finish off shift using value in T
 
	FFCRET	*XAR7		; return
	.endasmfunc


ul_tofd.asm/    1146129410  0     0     0       706       `
*;*****************************************************************************
*;                                                                            *
*;  UL_TOFD v4.1.3 
*;  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
*;  UL$$TOFD - Convert an unsigned 32 bit integer into an IEEE 754 format     * 
*;             double precision floating point number                         *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ul_tofd28.inc"
        .endif
ul_tofd28.inc/  1146129410  0     0     0       6898      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  UL_TOFD v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  UL$$TOFD  - Convert an unsigned 32 bit integer into an IEEE 754 format    *
;*              double precision floating point number			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN ACC  
;*   o RESULT IS RETURNED IN *XAR6
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                           AR4  |        | RES_EXP  |       *
;*                                                +-------------------+       *
;*                                          XAR6  | PTR TO RET VALUE  |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   UL$$TOFD
        .sect     ".text"

UL$$TOFD	.asmfunc
        .asg      XAR4,    XRES_EXP
        .asg       AR4,    RES_EXP
        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;       CHECK FOR NULL POINTER                                               *
*;*****************************************************************************
*
        MOVL    P, ACC            ; Save input float
        MOVL    ACC, XAR6         ;
        B       RETURN, EQ        ; Return if return pointer is null
*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Load the initial exponent value 0x41D                                 *
*;    3 If input is negative (MSB is 1)                                       *
*;        - Right shift by one so that MSB is in bit 62                       *
*;        - Set the exponent to  0x3FF + 1F = 0x41E                           *
*;    4 If input is positive (MSB is 0)                                       *
*;        - Normalize the mantissa so that MSB is in bit 62                   *
*;        - Set the exponent to 0x41D - nn, where nn is the number of bits    *
*;          shifted out for normalization.                                    *
*;*****************************************************************************
*
        MOVL 	ACC, P		; Restore input in ACC
	B	OP_ZERO, EQ	; Return zero if ACC is zero

	MOV 	P, #0 		; Zero out P
	MOVL	XRES_EXP, #0x41D; Load the initial exponent value             

	B	NORMALIZE, GT	; Normalize if MSB is zero; 
	LSR64 	ACC:P, #1	; MSB is 1 so adjust the mantissa
	INC 	RES_EXP    	; and adjust the exponent
	B	PACK, UNC
NORMALIZE:
	RPT	#31		; Normalize the value and adjust the exponent
     || NORM	ACC, XRES_EXP--	;
	
*
*;*****************************************************************************
*;       PACK mantissa and exponent into Double precision format.             *
*;*****************************************************************************
*
PACK:
	LSR64	ACC:P, #14	; Move the mantissa out of AH. Since only 32 
				; bits of the mantissa are significant this 
				; is not a problem
	MOV	AH, RES_EXP	; Load exponent and remove implied one 
	LSL64	ACC:P, #4	; Shift back mantissa and exponent
*
RETURN_VALUE:
        MOVL    RES_LSW, P     ;
        MOVL    RES_MSW, ACC   ; Load the return value in the return area.
RETURN:
        LRETR

        .page
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
OP_ZERO:
        ZAPA	                  ; For underflow result in ACC:P = 0
        B       RETURN_VALUE,UNC
	.endasmfunc
ul_tofs.asm/    1146129410  0     0     0       779       `
*;*****************************************************************************
*;                                                                            *
*;  UL$$TOFS - v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;  Convert a 32-bit unsigned integer to a floating point value               *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2700
                .include "ul_tofs27.inc"
        .elseif .TMS320C2800
                .include "ul_tofs28.inc"
        .endif

ul_tofs27.inc/  1146129410  0     0     0       9202      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  UL$$TOFS - v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;  Convert a 32-bit unsigned integer to a floating point value               *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       UL$$TOFS                                            register file    *
*;                                                         +----------------+ *
*;       This routine converts a 32-bit un-signed      AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in ACC.                                    *
*;       When the conversion is complete                                      *
*;       the float value will be in ACC.                                      *
*;                                                                            *
*;       inputs:  A (unsigned long value) in ACC                              *
*;                                                                            *
*;       implementation:  The value of the                                    *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            back into ACC.                                                  *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;       NOTE : POSSIBLE LOSS OF PRECISION SINCE 32-BIT FLOAT HAS ONLY        *
*;              24 BITS OF PRECISION                                          *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   UL$$TOFS

UL$$TOFS .asmfunc
	 .asg	AR4, EXPONENT
*
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the three cases it belongs.   *
*;    Case 1:  value is 0; branch to return                                   *
*;    Case 2:  all other values                                               *
*;*****************************************************************************
*
        TEST    ACC
        B       ZERO, EQ        ; branch if integer == 0
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (1Fh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOV     EXPONENT, #09Dh ; set exponent count to (1FH - 1)
        B       LEFT_SHIFT, GT
        INC     EXPONENT
        CLRC    SXM
        SFR     ACC, 1
        B       PACK

LEFT_SHIFT
	RPT	#31
     || NORM    ACC, EXPONENT-- ; normalize ACC to get mantissa value and
                                ; find actual exponent value
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Shift mantissa   [0000 0000 0MMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0EEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;*****************************************************************************
*
PACK
        AND     AH, #03FFFh         ; remove implied one and sign bit
        CLRC    SXM
        SFR     ACC, 7              ; shift mantissa to make room for exponent
        MOV     PH, AH              ; save AH
        MOV     AH, EXPONENT
        LSL     AH, 7               ; adjust exponent
        OR      AH, PH              ; restore AH with exponent
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        RET
	.endasmfunc
ul_tofs28.inc/  1146129410  0     0     0       9235      `
         .width 96
*;*****************************************************************************
*;                                                                            *
*;  UL$$TOFS - v4.1.3
*;  Copyright (c) 2000-2006 Texas Instruments Incorporated                    *
*;                                                                            *
*;  Convert a 32-bit unsigned integer to a floating point value               *
*;                                                                            *
*;*****************************************************************************
*;*****************************************************************************
*;                                                                            *
*;  revision:  original                                                       *
*;                                                                            *
*;*****************************************************************************
*;                                                                            *
*;       UL$$TOFS                                            register file    *
*;                                                         +----------------+ *
*;       This routine converts a 32-bit un-signed      AR4 |  exponent      | *
*;       integer to a 32-bit floating point.               +----------------+ *
*;       Upon entry the integer is in ACC.                                    *
*;       When the conversion is complete                                      *
*;       the float value will be in ACC.                                      *
*;                                                                            *
*;       inputs:  A (unsigned long value) in ACC                              *
*;                                                                            *
*;       implementation:  The value of the                                    *
*;            integer is normalized in the exponent.                          *
*;            The exponent is determined by decrementing                      *
*;            from the assummed maximum value.  The                           *
*;            sign, exponent, and normalized mantissa                         *
*;            (implied one bit removed) are packed                            *
*;            back into ACC.                                                  *
*;                                                                            *
*;       result:  returned in ACC                                             *
*;       NOTE : POSSIBLE LOSS OF PRECISION SINCE 32-BIT FLOAT HAS ONLY        *
*;              24 BITS OF PRECISION                                          *
*;*****************************************************************************
         .page
*;*****************************************************************************
*;                                                                            *
*;  Floating Point Format - Single Precision                                  *
*;                                                                            *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
*;       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
*;       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
*;                                                                            *
*;                                                                            *
*;       Single precision floating point format is a 32 bit format            *
*;       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
*;       23 bit mantissa field.  The fields are defined as follows.           *
*;                                                                            *
*;            Sign <S>          : 0 = positive values; 1 = negative values    *
*;                                                                            *
*;            Exponent <E7-E0>  : offset binary format                        *
*;                                00 = special cases (i.e. zero)              *
*;                                01 = exponent value + 127 = -126            *
*;                                FE = exponent value + 127 = +127            *
*;                                FF = special cases (not implemented)        *
*;                                                                            *
*;            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
*;                                1.M22M21...M1M0                             *
*;                                                                            *
*;            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
*;                                +1.0000000 e-126 to +1.9999998 e+127        *
*;                                (where e represents 2 to the power of)      *
*;                                -3.4028236 e+38  to -1.1754944 e-38         *
*;                                +1.1754944 e-38  to +3.4028236 e+38         *
*;                                (where e represents 10 to the power of)     *
*;*****************************************************************************
         .page
         .global   UL$$TOFS

UL$$TOFS .asmfunc
	 .asg	AR4, EXPONENT
	 .asg	XAR4, XEXPONENT
*
*
*;*****************************************************************************
*;       INTEGER EVALUATION                                                   *
*;  Test the integer to determine into which of the three cases it belongs.   *
*;    Case 1:  value is 0; branch to return                                   *
*;    Case 2:  all other values                                               *
*;*****************************************************************************
*
        TEST    ACC
        B       ZERO, EQ        ; branch if integer == 0
*
*;*****************************************************************************
*;       NORMALIZATION                                                        *
*;  Load exponent value - using bias (07Fh) and assuming maximum value (1Fh)  *
*;  Normalize the mantissa                                                    *
*;  Push exponent and normalized mantissa onto stack.                         *
*;*****************************************************************************
*
        MOVB    XEXPONENT, #09Dh ; set exponent count to 1FH - 1 
        B       LEFT_SHIFT, GT
        INC     EXPONENT
        CLRC    SXM
        SFR     ACC, 1
        B       PACK,UNC

LEFT_SHIFT:
	RPT	#31
     || NORM    ACC, XEXPONENT-- ; normalize ACC to get mantissa value and
                                 ; find actual exponent value
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Shift mantissa   [0000 0000 0MMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0EEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;*****************************************************************************
*
PACK
        AND     AH, #03FFFh         ; remove implied one and sign bit
        CLRC    SXM
        SFR     ACC, 7              ; shift mantissa to make room for exponent
        MOV     PH, AH              ; save AH
        MOV     AH, EXPONENT
        LSL     AH, 7               ; adjust exponent
        OR      AH, PH              ; restore AH with exponent
*
*;*****************************************************************************
*;       RETURN                                                               *
*;*****************************************************************************
*
RETURN
ZERO
        LRETR
	.endasmfunc

ull_tofd.asm/   1146129410  0     0     0       708       `
*;*****************************************************************************
*;                                                                            *
*;  ULL_TOFD v4.1.3 
*;  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
*;  ULL$$TOFD - Convert an unsigned 64 bit integer into an IEEE 754 format    * 
*;              double precision floating point number                        *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ull_tofd28.inc"
        .endif
ull_tofd28.inc/ 1146129410  0     0     0       6695      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  ULL_TOFD v4.1.3 
;*  Copyright (c) 2002-2006 Texas Instruments Incorporated                    *
;*  ULL$$TOFD  - Convert an unsigned 64 bit integer into an IEEE 754 format   *
;*               double precision floating point number			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN ACC:P
;*   o RESULT IS RETURNED IN *XAR6
;*
;******************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                           AR5  |        | RES_EXP  |       *
;*                                                +-------------------+       *
;*                                           AR7  |        | TMP16    |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   ULL$$TOFD
        .sect     ".text"

ULL$$TOFD	.asmfunc
        .asg      XAR5,    XRES_EXP
        .asg       AR5,    RES_EXP
        .asg       AR7,    TMP16   

        .asg   *+XAR6[2],  RES_MSW
        .asg   *+XAR6[0],  RES_LSW

*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Load the initial exponent value 0x41D                                 *
*;    3 If input is negative (MSB is 1)                                       *
*;        - Right shift by one so that MSB is in bit 62                       *
*;        - Set the exponent to  0x3FF + 3F = 0x43E                           *
*;    4 If input is positive (MSB is 0)                                       *
*;        - Normalize the mantissa so that MSB is in bit 62                   *
*;        - Set the exponent to 0x41D - nn, where nn is the number of bits    *
*;          shifted out for normalization.                                    *
*;*****************************************************************************
*
	CMP64	ACC:P			; Clear V flag
	CMP64	ACC:P			;
	B	OP_ZERO, EQ		; Return zero if ACC is zero

	MOVL	XRES_EXP, #0x43D	; Load the initial exponent value
	B	NORMALIZE, GEQ		; If bit 63 is 0 normalize.
	INC	RES_EXP			; If bit 63 is 1 no need to normalize,
	LSR64	ACC:P,#1 	        ; just shift right by 1 and adjust the
	B	PACK,UNC		; exponent and start packing.

NORMALIZE:
	NORMALIZE64  RES_EXP, TMP16	; Normalize the mantissa 
	
*
*;*****************************************************************************
*;       PACK mantissa and exponent into Double precision format.             *
*;*****************************************************************************
*
PACK:
	LSR64   ACC:P  #10	; 
	MOVL	RES_LSW, P	; Store the low 32 bits of the result

	LSR64   ACC:P, #4	; Move the mantissa out of AH. Since we already
				; saved the lower 32 bits to result we are okay.
        MOV     AH, RES_EXP     ; Load exponent and remove implied one 
        LSL64   ACC:P, #4       ; Shift back mantissa and exponent
        MOVL    RES_MSW, ACC    ; Load the return value in the return area.
	LRETR
*
RETURN_VALUE:
        MOVL    RES_LSW, P     ;
        MOVL    RES_MSW, ACC   ; Load the return value in the return area.
RETURN:
        LRETR

        .page
*
*;*****************************************************************************
*;       UNDERFLOW PROCESSING                                                 *
*;  Set ACC:P to 0x00000000:00000000                                          *
*;*****************************************************************************
*
OP_ZERO:
        ZAPA	                  ; For underflow result in ACC:P = 0
        B       RETURN_VALUE,UNC
	.endasmfunc

ull_tofs.asm/   1146129410  0     0     0       708       `
*;*****************************************************************************
*;                                                                            *
*;  ULL_TOFS v4.1.3 
*;  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
*;  ULL$$TOFS - Convert an unsigned 64 bit integer into an IEEE 754 format    * 
*;              single precision floating point number                        *
*;                                                                            *
*;*****************************************************************************
        .include "c2000asm.inc"
        .if .TMS320C2800
                .include "ull_tofs28.inc"
        .endif
ull_tofs28.inc/ 1146129410  0     0     0       8217      `
        .width 96
;******************************************************************************
;*                                                                            *
;*  ULL_TOFS v4.1.3 
;*  Copyright (c) 2003-2006 Texas Instruments Incorporated                    *
;*  ULL$$TOFS  - Convert an unsigned 64 bit integer into an IEEE 754 format   *
;*               single precision floating point number			      *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;*                                                                            *
;*  revision:  original                                                       *
;*                                                                            *
;******************************************************************************
;******************************************************************************
;******************************************************************************
;*
;*   o INPUT OP1 IS IN ACC:P
;*   o RESULT IS RETURNED IN ACC 
;*
;*       NOTE : POSSIBLE LOSS OF PRECISION SINCE 32-BIT FLOAT HAS ONLY         
;*              24 BITS OF PRECISION                                           
;******************************************************************************
;*                                                                            *
;*  Floating Point Format - Single Precision                                  *
;*                                                                            *
;*                                                                            *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |31 |30 |29 |28 |27 |26 |25 |24 |23 |22 |21 |20 |19 |18 |17 |16 |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       | S |E7 |E6 |E5 |E4 |E3 |E2 |E1 |E0 |M22|M21|M20|M19|M18|M17|M16|    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*                                                                            *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       |M15|M14|M13|M12|M11|M10|M9 |M8 |M7 |M6 |M5 |M4 |M3 |M2 |M1 |M0 |    *
;*       |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    *
;*       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+    *
;*                                                                            *
;*                                                                            *
;*       Single precision floating point format is a 32 bit format            *
;*       consisting of a 1 bit sign field, an 8 bit exponent field, and a     *
;*       23 bit mantissa field.  The fields are defined as follows.           *
;*                                                                            *
;*            Sign <S>          : 0 = positive values; 1 = negative values    *
;*                                                                            *
;*            Exponent <E7-E0>  : offset binary format                        *
;*                                00 = special cases (i.e. zero)              *
;*                                01 = exponent value + 127 = -126            *
;*                                FE = exponent value + 127 = +127            *
;*                                FF = special cases (not implemented)        *
;*                                                                            *
;*            Mantissa <M22-M0> : fractional magnitude format with implied 1  *
;*                                1.M22M21...M1M0                             *
;*                                                                            *
;*            Range             : -1.9999998 e+127 to -1.0000000 e-126        *
;*                                +1.0000000 e-126 to +1.9999998 e+127        *
;*                                (where e represents 2 to the power of)      *
;*                                -3.4028236 e+38  to -1.1754944 e-38         *
;*                                +1.1754944 e-38  to +3.4028236 e+38         *
;*                                (where e represents 10 to the power of)     *
;******************************************************************************
;*                                                                            *
;*                                                  register file             *
;*                                                +-------------------+       *
;*                                           AR5  |        | EXPONENT |       *
;*                                                +-------------------+       *
;*                                           AR6  |        | TMP16    |       *
;*                                                +-------------------+       *
;*                                                                            *
;******************************************************************************
        .page
	.include  "fd_util28.inc"
        .global   ULL$$TOFS
        .sect     ".text"

ULL$$TOFS:	.asmfunc
        .asg      XAR5,    XEXPONENT
        .asg       AR5,    EXPONENT
        .asg       AR6,    TMP16   
*
*;*****************************************************************************
*;    1 Handle the special case where input is zero                           *
*;    2 Load the initial exponent value 0x7F + 3F = 0xBE                      *
*;    3 If input MSB is 1                                                     *
*;        - Right shift by one so that MSB is in bit 62                       *
*;        - Set the exponent to  0x7F + 3F = 0xBE                             *
*;    4 If input is positive (MSB is 0)                                       *
*;        - Normalize the mantissa so that MSB is in bit 62                   *
*;        - Set the exponent to 0xBD - nn, where nn is the number of bits     *
*;          shifted out for normalization.                                    *
*;*****************************************************************************
*
	CMP64	ACC:P			; Clear V flag
	CMP64	ACC:P			;
	B	RETURN, EQ		; Return zero if ACC is zero

	MOVB	XEXPONENT, #0xBD	; Load the initial exponent to 0xBD
	B	NORMALIZE, GT		; If MSB is 0 normalize the value.

	INC	EXPONENT		; MSB is 1 so inc the exp to 0xBE
	LSR64	ACC:P, #1		; Right shift so that MSB is in bit 62
	B	PACK,UNC		; No need to normalize, go to pack.

NORMALIZE:
	NORMALIZE64  EXPONENT, TMP16	; Normalize the mantissa 
	
*
*;*****************************************************************************
*;       CONVERSION OF FLOATING POINT FORMAT - PACK                           *
*;  Mask  mantissa   [00MM MMMM MMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Shift mantissa   [0000 0000 0MMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Pack exponent.   [0EEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;  Add sign         [SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM]                *
*;*****************************************************************************
*
PACK:
        AND     AH, #03FFFh         ; remove implied one and sign bit
	LSR64	ACC:P, #7	    ; shift mantissa to make room for exponent
        MOV     TMP16, AH           ; save AH
        MOV     AH, EXPONENT
        LSL     AH, 7               ; adjust exponent
        OR      AH, TMP16           ; restore AH with exponent
*
RETURN:
        LRETR
	.endasmfunc

unaccess.h/     1146129410  0     0     0       36        `
/* unaccess.h: Empty by default */
ungetc.c/       1146129410  0     0     0       3503      `
/*****************************************************************************/
/*  UNGETC.C v4.1.3                                                          */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    UNGETC   -  Push a character back onto a stream                        */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* UNGETC   -  Push a character back onto a stream                           */
/*                                                                           */
/*    This function returns the character pushed back upon success, or an    */
/*    EOF upon failure.                                                      */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int ungetc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the character is an EOF, or if an UNGETC has already been performed */
   /* and there is no room left in the buffer, return an EOF.                */
   /*------------------------------------------------------------------------*/
   if(_c == EOF || (_fp->pos < _fp->buf)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the file is in update mode, and is currently writing, change it to  */
   /* read mode.                                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODERW))
   {
      _UNSET(_fp, _MODEW);
      _SET(_fp, _MODER);
   }
 
   /*------------------------------------------------------------------------*/
   /* Set up a buffer if one is needed, and none exists.                     */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      if(setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ) == EOF) return (EOF);
 
   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer, set the _UNGETC flag in the stream,   */
   /* and clear the EOF flag in the stream.                                  */
   /*------------------------------------------------------------------------*/
   *(--_fp->pos) = (unsigned char)_c;
   _SET(_fp, _UNGETC);
   _UNSET(_fp, _STATEOF);

   /*------------------------------------------------------------------------*/
   /* If this is an UNGETC on an empty file, make the end of the read buffer.*/
   /*------------------------------------------------------------------------*/
   if(!_fp->buff_stop) _fp->buff_stop = _fp->buf;

   return ((unsigned char)_c);
}


values.h/       1146129411  0     0     0       9340      `
/*****************************************************************************/
/* values.h   v4.1.3                                                         */
/* Copyright (c) 1996-2006 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _VALUES
#define _VALUES

#define BITS	  23                 /* There are 23 bits in the mantissa   */
#define MAXX	  88.72283906        /* ln(HUGE_VAL)                        */
#define MAXH	  89.41598624	     /* ln(HUGE_VAL) + ln(2)                */
#define TWO23	  8388608	     /* 2 ^ BITS                            */
#define XBIG	  8.664339757	     /* (BITS/2 + 1) * ln(2)                */

/****************************************************************************/
/*  The following macros define constants used throughout the functions.    */
/****************************************************************************/

/* macros used in asin and acos */

#define SQRTWO	  1.4142135623730950
#if BITS<=24
#define ASP1	  0.933935835
#define ASP2	 -0.504400557
#define ASQ0	  0.560363004e1
#define ASQ1	 -0.554846723e1
#elif BITS>=25 && BITS<=36
#define ASP1	 -0.27516555290596e1
#define ASP2	  0.29058762374859e1
#define ASP3	 -0.59450144193246
#define ASQ0	 -0.16509933202424e2
#define ASQ1	  0.24864728969164e2
#define ASQ2	 -0.10333867072113e2
#elif BITS>=37 && BITS<=48
#define ASP1	  0.85372164366771950e1
#define ASP2	 -0.13428707913425312e2
#define ASP3	  0.59683157617751534e1
#define ASP4	 -0.65404068999335009
#define ASQ0	  0.51223298620109691e2
#define ASQ1	 -0.10362273186401480e3
#define ASQ2	  0.68719597653808806e2
#define ASQ3	 -0.16429557557495170e2
#else
#define ASP1	 -0.27368494524164255994e2
#define ASP2	  0.57208227877891731407e2
#define ASP3	 -0.39688862997504877339e2
#define ASP4	  0.10152522233806463645e2
#define ASP5	 -0.69674573447350646411
#define ASQ0	 -0.16421096714498560795e3
#define ASQ1	  0.41714430248260412556e3
#define ASQ2	 -0.38186303361750149284e3
#define ASQ3	  0.15095270841030604719e3
#define ASQ4	 -0.23823859153670238830e2
#endif

/* macros used in atan and atan2 */

#define TWO_SQRT3 0.26794919243112270647
#define SQRTTHREE 1.73205080756887729353
#define PI	  3.14159265358979323846
#if BITS<=24
#define ATP0	 -0.4708325141
#define ATP1	 -0.5090958253e-1
#define ATQ0	  0.1412500740e1
#elif BITS>=25 && BITS<=32
#define ATP0	 -0.144008344874e1
#define ATP1	 -0.720026848898
#define ATQ0	  0.432025038919e1
#define ATQ1	  0.475222584599e1
#elif BITS>=33 && BITS<=50
#define ATP0	 -0.427432672026241096e1
#define ATP1	 -0.427444985367930329e1
#define ATP2	 -0.794391295408336251
#define ATQ0	  0.128229801607919841e2
#define ATQ1	  0.205171376564218456e2
#define ATQ2	  0.919789364835039806e1
#else
#define ATP0	 -0.13688768894191926929e2
#define ATP1	 -0.20505855195861651981e2
#define ATP2	 -0.84946240351320683534e1
#define ATP3	 -0.83758299368150059274
#define ATQ0	  0.41066306682575781263e2
#define ATQ1	  0.86157349597130242515e2
#define ATQ2	  0.59578436142597344465e2
#define ATQ3	  0.15024001160028576121e2
#endif

/* macros used in sin and cos */

#define INVSPI	  0.31830988618379067154
#define HALFPI	  1.57079632679489661923
#if BITS<=32
#define C1	  3.140625
#define C2	  9.67653589793e-4
#else
#define C1	  3.1416015625
#define C2	 -8.908910206761537356617e-6
#endif
#if BITS<=24
#define R1	 -0.1666665668e+0
#define R2	  0.8333025139e-2
#define R3	 -0.1980741872e-3
#define R4	  0.2601903036e-5
#elif BITS>=25 && BITS<=32
#define R1	 -0.1666666660883
#define R2	  0.8333330720556e-2
#define R3	 -0.1984083282313e-3
#define R4	  0.2752397106775e-5
#define R5	 -0.2386834640601e-7
#elif BITS>=33 && BITS<=50
#define R1	 -0.166666666666659653
#define R2	  0.833333333327592139e-2
#define R3	 -0.198412698232225068e-3
#define R4	  0.275573164212926457e-5
#define R5	 -0.250518708834705760e-7
#define R6	  0.160478446323816900e-9
#define R7	 -0.737066277507114174e-12
#else
#define R1	 -0.16666666666666665052
#define R2	  0.83333333333331650314e-2
#define R3	 -0.19841269841201840457e-3
#define R4	  0.27557319210152756119e-5
#define R5	 -0.25052106798274584544e-7
#define R6	  0.16058936490371589114e-9
#define R7	 -0.76429178068910467734e-12
#define R8	  0.27204790957888846175e-14
#endif

/* macros used in exp, cosh, and sinh */

#define LOGe2	  0.6931471805599453094172321
#define LOG102    0.301029995663981198017
#define INVLOGe2  1.4426950408889634074
#if BITS<=29
#define EXP0	  0.24999999950
#define EXP1	  0.41602886268e-2
#define EXQ0	  0.5
#define EXQ1	  0.49987178778e-1
#elif BITS>=30 && BITS<=42
#define EXP0	  0.24999999999992
#define EXP1	  0.59504254977591e-2
#define EXQ0	  0.5
#define EXQ1	  0.53567517645222e-1
#define EXQ2	  0.29729363682238e-3
#elif BITS>=43 && BITS<=56
#define EXP0	  0.249999999999999993
#define EXP1	  0.694360001511792852e-2
#define EXP2	  0.165203300268279130e-4
#define EXQ0	  0.5
#define EXQ1	  0.555538666969001188e-1
#define EXQ2	  0.495862884905441294e-3
#else
#define EXP0	  0.25
#define EXP1	  7.5753180159422776666e-3
#define EXP2	  3.1555192765684646356e-5
#define EXQ0	  0.5
#define EXQ1	  5.6817302698551221787e-2
#define EXQ2	  6.3121894374398503557e-4
#define EXQ3	  7.5104028399870046114e-7
#endif
#if BITS<=24
#define SHP0	 -0.713793159e1
#define SHP1	 -0.190333399
#define SHQ0	 -0.428277109e2
#elif BITS>=25 && BITS<=40
#define SHP0	  0.10622288837151e4
#define SHP1	  0.31359756456058e2
#define SHP2	  0.34364140358506
#define SHQ0	  0.63733733021822e4
#define SHQ1	 -0.13051012509199e3
#elif BITS>=41 && BITS<=50
#define SHP0	  0.23941435923050069e4
#define SHP1	  0.85943284838549010e2
#define SHP2	  0.13286428669224229e1
#define SHP3	  0.77239398202941923e-2
#define SHQ0	  0.14364861553830292e5
#define SHQ1	 -0.20258336866427869e3
#else
#define SHP0	 -0.35181283430177117881e6
#define SHP1	 -0.11563521196851768270e5
#define SHP2	 -0.16375798202630751372e3
#define SHP3	 -0.78966127417357099479
#define SHQ0	 -0.21108770058106271242e7
#define SHQ1	  0.36162723109421836460e5
#define SHQ2	 -0.27773523119650701667e3
#endif

/* macros used in log10 and log */

#define SQRTHALF  0.70710678118654752440
#define LOG10e	  0.4342944819032518
#define C3	  0.693359375
#define C4	 -2.121944400546905827679e-4
#if BITS<=24
#define A0	 -0.5527074855
#define B0	 -0.6632718214e1
#elif BITS>=25 && BITS<=32
#define A0	 -0.4649062303464
#define A1	  0.1360095468621e-1
#define B0	 -0.5578873750242e1
#elif BITS>=33 && BITS<=48
#define A0	  0.37339168963160866e1
#define A1	 -0.63260866233859665
#define A2	  0.44445515109803323e-2
#define B0	  0.44807002755736436e2
#define B1	 -0.14312354355885324e2
#else
#define A0	 -0.64124943423745581147e2
#define A1	  0.16383943563021534222e2
#define A2	 -0.78956112887491257267
#define B0	 -0.76949932108494879777e3
#define B1	  0.31203222091924532844e3
#define B2	 -0.35667977739034646171e2
#endif

/* macros used in pow */

#define L1	  2.885390072738
#define L3	  0.961800762286
#define L5	  0.576584342056
#define L7	  0.434259751292
#define T6	  0.0002082045327
#define T5	  0.001266912225
#define T4	  0.009656843287
#define T3	  0.05549288453
#define T2	  0.2402279975
#define T1	  0.6931471019

/* macros used in tan */

#define TWOINVPI  0.63661977236758134308
#if BITS<=32
#define C5	  1.5703125
#define C6	  4.83826794897e-4
#else
#define C5	  1.57080078125
#define C6	 -4.454455103380768678308e-6
#endif
#if BITS<=24
#define TAP1	 -0.958017723e-1
#define TAQ1	 -0.429135777e+0
#define TAQ2	  0.971685835e-2
#elif BITS>=25 && BITS<=32
#define TAP1	 -0.1113614403566
#define TAP2	  0.1075154738488e-2
#define TAQ1	 -0.4446947720281
#define TAQ2	  0.1597339213300e-1
#elif BITS>=33 && BITS<=52
#define TAP1	 -0.1282834704095743847
#define TAP2	  0.2805918241169988906e-2
#define TAP3	 -0.7483634966612065149e-5
#define TAQ1	 -0.4616168037429048840
#define TAQ2	  0.2334485282206872802e-1
#define TAQ3	 -0.2084480442203870948e-3
#else
#define TAP1	 -0.13338350006421960681
#define TAP2	  0.34248878235890589960e-2
#define TAP3	 -0.17861707342254426711e-4
#define TAQ1	 -0.46671683339755294240
#define TAQ2	  0.25663832289440112864
#define TAQ3	 -0.31181531907010027307e-3
#define TAQ4	  0.49819433993786512270e-6
#endif

/* macros used in tanh */

#define LOGe3by2  0.54930614433405484570
#if BITS<=24
#define THP0	 -0.8237728127
#define THP1	 -0.3831010665e-2
#define THQ0	  0.2471319654e1
#elif BITS>=25 && BITS<=36
#define THP0	 -0.21063958000245e2
#define THP1	 -0.93363475652401
#define THQ0	  0.63191874015582e2
#define THQ1	  0.28077653470471e2
#elif BITS>=37 && BITS<=48
#define THP0	 -0.19059522426982292e2
#define THP1	 -0.92318689451426177
#define THP2	 -0.36242421934642173e-3
#define THQ0	  0.57178567280965817e2
#define THQ1	  0.25640987595178975e2
#else
#define THP0	 -0.16134119023996228053e4
#define THP1	 -0.99225929672236083313e2
#define THP2	 -0.96437492777225469787
#define THQ0	  0.48402357071988688686e4
#define THQ1	  0.22337720718962312926e4
#define THQ2	  0.11274474380534949335e3
#endif

#endif /* _VALUES */
vars.cpp/       1146129411  0     0     0       1886      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

/*

Performs initialization of global variables used by the runtime.

*/

#define EXTERN /* empty */
#define VAR_INITIALIZERS 1

#include "basics.h"
#include "runtime.h"
#include "vec_newdel.h"
/*** START TI ADD ***/
/* We do not need main.h to build TI RTS */
#if 0
/*** END TI ADD ***/
#include "main.h"
*** START TI ADD ***/
#endif
/*** END TI ADD ***/
#include "vec_newdel.h"
#include "eh.h"

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/



vec_cctor.cpp/  1146129411  0     0     0       2724      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ runtime routine to execute a copy constructor for each element of an array.

*/

#include "basics.h"
#include "runtime.h"

#ifndef __EDG_IA64_ABI
EXTERN_C void __vec_cctor(void                         *array_ptr,
                          size_t                       number_of_elements,
                          size_t                       element_size,
                          a_copy_constructor_ptr       ctor,
                          void                         *src_array_ptr)
/*
Walk through the array, calling the specified copy constructor for each
array element.  The corresponding element of the array pointed to by
src_array_ptr is the source operand for the copy constructor.  Because
this runtime routine will only be called for constructor initialization
of member arrays, the number_of_elements can never be zero.
*/
{
  int  i;
  char *arr_ptr;
  char *src_arr;

  if (ctor != NULL) {
    for (i = 0, arr_ptr = (char *)array_ptr, src_arr = (char *)src_array_ptr;
         i < number_of_elements;
         i++, arr_ptr += element_size, src_arr += element_size) {
      (*ctor)((void *)arr_ptr, (void *)src_arr);
    }  /* for */
  }  /* if */
}  /* __vec_ctor */
#endif /* ifndef __EDG_IA64_ABI */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
vec_newdel.cpp/ 1146129411  0     0     0       50047     `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

C++ runtime routines to provide vector new() and delete() functionality.

*/

#include "basics.h"
#include "runtime.h"
#include "eh.h"
#pragma hdrstop
#include "vec_newdel.h"
/*** START TI ADD ***/
/* We do not need main.h to build TI RTS */
#if 0
/*** END TI ADD ***/
#include "main.h"
/*** START TI ADD ***/
#endif
/*** END TI ADD ***/
#if ABI_COMPATIBILITY_VERSION >= 300
#include "memzero.h"
#endif /* ABI_COMPATIBILITY_VERSION >= 300 */

/*
For arrays, _vec_new() and _vec_delete() will maintain a linked list of 
"hidden" information on each array allocated and subsequently deleted.
This information will be used by _vec_ctor() and _vec_dtor() to determine
the size of undimensioned arrays.
*/

/*
Hidden structure of information for each array "allocated" by new().
*/
typedef struct vec_info *a_vec_info_ptr;
				/* Pointer to a vector information struct. */
typedef struct vec_info {
  a_vec_info_ptr
		next;		/* Pointer to the next structure in a linked
				   list. */
  void 	        *array_ptr;	/* Pointer to array. */
  size_t        array_size;	/* Size of memory in the array. */
} vec_info;


#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO
static a_vec_info_ptr _head_vec_info = NULL;
				/* Pointer to the beginning of the linked list
				   of array information. */

static a_vec_info_ptr _free_vec_info = NULL;
				/* Pointer to a list of free array information
				   structures. */
#endif /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

#ifndef __EDG_IA64_ABI
EXTERN_C void _array_pointer_not_from_vec_new();
                               /* Function called when an invalid pointer that
                                  was not allocated by vec_new is passed
                                  to one of the vector handling routines. */
#endif /* ifndef __EDG_IA64_ABI */

struct an_array_alloc_eh_info {
  void*	array_ptr;
			/* Pointer to the memory allocated for the array. */
  a_sizeof_t
		number_of_elements;
			/* Total number of elements in the array. */
  a_sizeof_t
		element_size;
			/* Size of each element. */
  a_sizeof_t
		prefix_size;
                        /* Size of the array prefix. */
  a_sizeof_t
		elements_processed;
			/* Number of elements constructed or destructed so
			   far. */
  a_boolean
		is_vec_new;
			/* TRUE if this is a vec_new operation, FALSE if this
			   is a vec_delete. */
  a_boolean
		free_memory_on_cleanup;
			/* TRUE if the memory for the array was allocated by
			   new and should be freed during object cleanup. */
  a_destructor_ptr
		destructor;
			/* Pointer to the destructor to be called for each
			   element of the array. */
  a_delete_ptr
		delete_routine;
			/* Pointer to the delete routine to be called to
			   deallocate an array. */

  a_boolean	is_two_arg;
			/* TRUE if the delete routine is the two argument
			   form.  FALSE if it is the single argument form. */
#ifdef __EDG_IA64_ABI
  a_boolean     terminate_immediately;
                        /* TRUE if any exception during the destruction of the
                           array elements should result in termination.  */
#endif /* defined(__EDG_IA64_ABI) */
};


/*
Increment a void* pointer by a given value.
*/
#define increment_ptr(ptr, incr) (ptr = ((void*)((char*)ptr + incr)))

#if EXCEPTION_HANDLING
static void add_vec_new_or_delete_eh_stack_entry
				(an_eh_stack_entry_ptr	    ehsep,
                                 an_array_alloc_eh_info_ptr aaehip,
			         a_boolean		    is_vec_new)
/*
Link an entry onto the EH stack that describes the vec_new or vec_delete
operation that is in process.
*/
{
  ehsep->next = __curr_eh_stack_entry;
  __curr_eh_stack_entry = ehsep;
  ehsep->kind = ehsek_vec_new_or_delete;
  ehsep->variant.array_alloc_eh_info = aaehip;
  aaehip->array_ptr                 = NULL;
  aaehip->number_of_elements        = 0;
  aaehip->element_size              = 0;
  aaehip->prefix_size               = 0;
  aaehip->elements_processed        = 0;
  aaehip->is_vec_new                = is_vec_new;
  aaehip->free_memory_on_cleanup    = FALSE;
  aaehip->destructor		    = NULL;
  aaehip->delete_routine	    = NULL;
  aaehip->is_two_arg	 	    = FALSE;
}  /* add_vec_new_or_delete_eh_stack_entry */
#endif /* EXCEPTION_HANDLING */


#if USE_PREFIX_FOR_ARRAY_ALLOC_INFO
/*
Structure used to record the size of an array that has been allocated.
Space for this structure is reserved at the beginning of the block of
memory allocated to hold the array.
*/

/* ARM ABI Mode is based on "C++ ABI for the ARM Architecture"(CPPABI)
3.2.2 Array construction and destruction 
3.2.2.1 Array cookies
3.2.2.2 Array cookie alignment
on page 9,  Doc # Genc-003540 v1.0 */


#if !defined(__EDG_IA64_ABI) && defined(TI_ARRAY_PREFIX)
typedef struct an_alloc_prefix *an_alloc_prefix_ptr;
/*** START TI ADD ***/
struct an_alloc_prefix {
  size_t number_of_elements;
                        /* To maintain backward compatibility with
			   previous TI RTS, we modified this data 
			   structure. It is to our knowledge that 
			   this change and its relevant changes
			   will not harm the functionality of 
			   the RTS */
};
#define LARGE_TYPE_MASK (sizeof(long double) - 1)
size_t __array_new_prefix_size = 
                    (sizeof(an_alloc_prefix) + LARGE_TYPE_MASK) & ~LARGE_TYPE_MASK;
#elif !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)
typedef struct an_alloc_prefix *an_alloc_prefix_ptr;
/* EDG defined array prefix */
struct an_alloc_prefix {
  size_t	size;
			/* The size of the array, in bytes. */

  size_t	encoded_number_of_elements;
			/* The number of elements in the array.  This value
                           is encoded so that a zero value is not represented
			   as a zero.  This is done to help detect situations
			   in which the prefix has been overwritten. */
};
/*
Compute the size in bytes of the prefix to be allocated.  This must
be at least as large as an_alloc_prefix, but must also be a multiple
of the most strict alignment. */
size_t	__array_new_prefix_size = 
	          ((sizeof(an_alloc_prefix) + MOST_STRICT_ALIGNMENT - 1) /
                               MOST_STRICT_ALIGNMENT) * MOST_STRICT_ALIGNMENT;

#elif defined(__EDG_IA64_ABI) && defined(__eabi__) /* ARM ABI Mode */
typedef struct an_alloc_prefix *an_alloc_prefix_ptr;
struct an_alloc_prefix {
    std::size_t	element_size;
			/* The size of the array, in bytes. */

    std::size_t	element_count;
			/* The number of elements in the array. */
};
size_t	__array_new_prefix_size = 8;
#elif defined(__EDG_IA64_ABI) && !defined(__eabi__) /* PURE IA64_ABI but ! ARM ABI Mode */
typedef size_t an_alloc_prefix;
typedef an_alloc_prefix *an_alloc_prefix_ptr;
#endif /* End of prefix definition */
#else /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
/*
No prefix is used in the alternate mode.
*/
size_t	__array_new_prefix_size = 0;
#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */


static inline void* alloc_array(size_t		size,
                                size_t          prefix_size,
			        a_new_ptr	new_routine)
/*
Call the allocation routine to allocate the memory for the array.  Adjust
the size as needed to provide storage for the prefix information used to
save the array size.  The size of the prefix, if any, is given by
prefix_size.
*/
{
  void		*array_ptr;
  /* Increment the size to provide space for the prefix block. */
  size += prefix_size;
  /* Allocate the memory using the appropriate new routine.  If a pointer
     was provided by the caller, use that one.  Otherwise, use the
     one specified by the ABI being used. */
  if (new_routine == NULL) {
#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE
    array_ptr = operator new[](size);
#else /* !ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */
    array_ptr = operator new(size);
#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */
  } else {
    array_ptr = (*new_routine)(size);
  }  /* if */
  if (array_ptr != NULL) {
    /* Return a pointer to the part of the array after the prefix. */
    array_ptr = (void*)(((char *)array_ptr) + prefix_size);
  }  /* if */
  return array_ptr;
}  /* alloc_array */


static void free_array(void*		array_ptr,
		       size_t		size,
                       size_t           prefix_size,
		       a_delete_ptr	delete_routine,
		       int		is_two_arg)
/*
Call the deallocation routine to free the memory for the array.  Adjust
the size as needed to provide storage for the prefix information used to
save the array size.  The size of the prefix (if any) is given by
prefix_size.
*/
{
  /* Increment the size to provide space for the prefix block. */
  size += prefix_size;
  /* Adjust the pointer to point to the start of the prefix. */
  array_ptr = (void*)(((char *)array_ptr) - prefix_size);
  /* Free the memory using the appropriate new routine.  If a pointer
     was provided by the caller, use that one.  Otherwise, use the
     one specified by the ABI being used. */
  if (delete_routine == NULL) {
#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE
    operator delete[](array_ptr);
#else /* !ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */
    operator delete(array_ptr);
#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */
  } else {
    if (is_two_arg) {
      a_two_operand_delete_ptr two_op_delete_routine;
      two_op_delete_routine = (a_two_operand_delete_ptr)delete_routine;
      (*two_op_delete_routine)(array_ptr, size);
    } else {
      (*delete_routine)(array_ptr);
    }  /* if */
  }  /* if */
}  /* free_array */


#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO
/*ARGSUSED*/ /* <-- "number_of_elements" is only used when
                    USE_PREFIX_FOR_ARRAY_ALLOC_INFO is TRUE. */
#else /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
#ifdef __EDG_IA64_ABI
/*ARGSUSED*/ /* <-- "size" is not used in that case. */
#endif /* ifdef __EDG_IA64_ABI */
#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */

static inline a_boolean record_array_alloc_info(void*	array_ptr,
	   				        size_t	size,
					        size_t	number_of_elements)
/*
Record the size of the array so that it can be retrieved later using
the array pointer.  Returns TRUE if an error occurred and the size
could not be recorded.
*/
{
#if USE_PREFIX_FOR_ARRAY_ALLOC_INFO
  an_alloc_prefix_ptr	app;
#if !defined(__EDG_IA64_ABI) && defined(TI_ARRAY_PREFIX)
  /* Get a pointer to the prefix information and fill in the fields.
     The number of elements is saved as the complement of the actual
     value.  This is done so that zeroing out the prefix (as might happen
     if the memory were overwritten) would not result in valid values. */
  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);
  app->number_of_elements = number_of_elements; 
#elif !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)
  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);
  app->size = size;
  app->encoded_number_of_elements = ~number_of_elements;
#elif defined(__EDG_IA64_ABI) && defined(__eabi__) /* ARM ABI Mode */
  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);
  app->element_size = size;
  app->element_count = number_of_elements;
#elif defined(__EDG_IA64_ABI) && !defined(__eabi__) /* True IA64_ABI */
  app = ((an_alloc_prefix_ptr)array_ptr) - 1;
  *app = (an_alloc_prefix)number_of_elements;
#endif /* defined(__EDG_IA64_ABI) */
  return FALSE;
#else /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
  a_vec_info_ptr	info_ptr;
  /* Allocate the needed memory and construct the "hidden" array
     information. */
  if (_free_vec_info != NULL) {
    /* Reuse a previously allocated structure. */
    info_ptr = _free_vec_info;
    _free_vec_info = info_ptr->next;
  } else {
    /* Allocate an array information structure from free memory. */
    info_ptr = (a_vec_info_ptr)malloc(sizeof(vec_info));
    if (info_ptr == NULL) {
      array_ptr = NULL;
    }  /* if */
  }  /* if */
  if (info_ptr != NULL) {
    info_ptr->next       = _head_vec_info;
    info_ptr->array_ptr  = array_ptr;
    info_ptr->array_size = size;
    _head_vec_info  = info_ptr;
  }  /* if */
  return array_ptr == NULL;
#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
}  /* record_array_alloc_info */


#if !USE_PREFIX_FOR_ARRAY_ALLOC_INFO
/*ARGSUSED*/ /* <-- "element_size" is only used when
                    USE_PREFIX_FOR_ARRAY_ALLOC_INFO is TRUE. */
#endif /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
static inline size_t get_array_size(void*	array_ptr,
			 	    size_t	element_size)
/*
Return the array size saved when the array was allocated.  The size is
stored either in a prefix allocated immediately before the array or in
a separate data structure.  array_ptr points to the start of the array
whose size is to be determined.  element_size is the size of each element.
*/
{
#if USE_PREFIX_FOR_ARRAY_ALLOC_INFO
  an_alloc_prefix_ptr	app;
  size_t		size;
#if !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)
  size_t                size_to_check;
#endif

#if !defined(__EDG_IA64_ABI) && defined(TI_ARRAY_PREFIX)
  /* Get the size from the prefix.  Compute the size from the
     element count saved in the prefix and the element size passed
     by the caller.  Note that the number of elements is saved as the
     complement of the actual value.  If the two sizes do not agree,
     either the memory was not allocated by array_new, or the prefix was
     corrupted. */
  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);
  size = app->number_of_elements * element_size;
#elif !defined(__EDG_IA64_ABI) && !defined(TI_ARRAY_PREFIX)
  size = app->size;
  size_to_check = element_size * (~(app->encoded_number_of_elements));
  if (size != size_to_check) _array_pointer_not_from_vec_new();
#elif defined(__EDG_IA64_ABI) && defined(__eabi__) /* ARM ABI Mode */
  app = (an_alloc_prefix_ptr)(((char *)array_ptr) - __array_new_prefix_size);
  size = app->element_size;
#elif defined(__EDG_IA64_ABI) && !defined(__eabi__) /* TRUE IA64 Mode */
  app = ((an_alloc_prefix_ptr)array_ptr) - 1;
  size = *app * element_size;
#endif /* defined(__EDG_IA64_ABI) */
  return size;
#else /* !USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
  a_vec_info_ptr        prev_ptr;
  a_vec_info_ptr 	info_ptr = NULL;
  size_t		size;
  /* Find the "hidden" information  for this array. */
  for (prev_ptr = NULL, info_ptr = _head_vec_info;
       (info_ptr != NULL) && (info_ptr->array_ptr != array_ptr);
       info_ptr = info_ptr->next) {
    prev_ptr = info_ptr;
  }  /* for */
  if (info_ptr == NULL) {
    /* This array was not allocated by vec_new, so we do not know the
       size.  Call a function that will abort.  The name should
       be sufficient to identify the nature of the problem to the user. */
     _array_pointer_not_from_vec_new();
  }  /* if */
  size = info_ptr->array_size;
  /* Unhook this array information from the linked list and add to the
     front of the free list. */
  if (prev_ptr == NULL) {
    /* This structure is on the beginning of the linked list. */
    _head_vec_info = info_ptr->next;
  } else {
    prev_ptr->next = info_ptr->next;
  }  /* if */
  info_ptr->next = _free_vec_info;
   _free_vec_info = info_ptr;
  return size;
#endif /* USE_PREFIX_FOR_ARRAY_ALLOC_INFO */
}  /* get_array_size */


/*ARGSUSED*/ /* <-- "dtor" is only used when EXCEPTION_HANDLING is TRUE. 
                    "prefix_size" is only used when
                    USE_PREFIX_FOR_ARRAY_ALLOC_INFO is true. */
static void *array_new_general(void                  *array_ptr,
                               size_t                number_of_elements,
                               size_t                element_size,
                               size_t                prefix_size,
                               void                  *src_array_ptr,
                               a_constructor_ptr     ctor,
                               a_destructor_ptr	     dtor,
		               a_new_ptr	     new_routine,
                               a_delete_ptr          delete_routine,
			       int		     is_two_arg,
                               a_boolean             zero_init)
/*
Allocate storage for an array, then call a constructor for each
element of the array.  If array_ptr is NULL, allocate the space for an
array of class objects (with number_of_elements elements each of size
element_size).  Also remember the size of the array in a
behind-the-scenes data structure so that it can be recalled at the
time of the corresponding vec_delete call.  If array_ptr is non-NULL,
it points to an already-allocated array.  If ctor is non-NULL, it
points to a constructor function to be called for each element of the
array (whether the array is allocated here or pre-allocated).  Return
the address of the array.

src_array_ptr points to the array to be copied when ctor points to a
copy constructor.

dtor is a pointer to the destructor for objects of the element type.
This is used by the exception handling mechanism for object cleanup
if an exception is thrown while the array is being constructed.
If there is no destructor then dtor is NULL and no cleanup is done.

delete_routine is a pointer to the delete routine to be used to deallocate the
space in the event that an exception is thrown during construction.
is_two_arg is TRUE if delete_routine refers to a two argument version of the
delete operator.  zero_init is TRUE if the memory should be cleared before
invoking constructors.

This routine needs to record the size of the array that was allocated so
that the size is known when the array is deallocated.  One of two means
of recording this information is used depending on the setting of the
configuration flag USE_PREFIX_FOR_ARRAY_ALLOC_INFO.  If this flag is TRUE,
a prefix structure is allocated as part of the array allocation, and this
prefix is used to store the size.  The pointer returned to the caller points
to the memory after the prefix block.

When USE_PREFIX_FOR_ARRAY_ALLOC_INFO is FALSE, a linked list is used
to record the number of elements in the array.  Consequently, the
performance degrades if a large number of arrays are allocated.  For
this reason, the alternate mechanism is recommended for production
use.
*/
{
  size_t   array_size;
  int      i;
  void     *arr_ptr;

#if EXCEPTION_HANDLING
  an_eh_stack_entry		ehse;
  an_array_alloc_eh_info	aaehi;
  a_boolean			create_eh_stack_entry;
  a_boolean			free_memory_on_cleanup = array_ptr == NULL;

  /* An entry is created on the EH stack if the class for which the
     array is being created has a destructor, or if the object is
     dynamically allocated. */
  create_eh_stack_entry = dtor != NULL || array_ptr == NULL;
#endif /* EXCEPTION_HANDLING */
  if (array_ptr == NULL || prefix_size) {
    a_boolean	err;
    array_size = number_of_elements * element_size;
    if (array_ptr == NULL) {
      /* Allocate the array if a pointer has not been supplied by the
         caller. */
      array_ptr = alloc_array(array_size, prefix_size, new_routine);
      if (array_ptr == NULL) {
        goto error_exit;
      }  /* if */
    }  /* if */
    /* Record the array size information so that the array can be properly
       freed later. */
    if (prefix_size != 0) {
      err = record_array_alloc_info(array_ptr, array_size, number_of_elements);
      if (err) goto error_exit;
    }  /* if */
#if ABI_COMPATIBILITY_VERSION >= 300
  } else if (zero_init) {
    array_size = number_of_elements * element_size;
#endif /* ABI_COMPATIBILITY_VERSION >= 300 */
  }  /* if */
#if ABI_COMPATIBILITY_VERSION >= 300
  if (zero_init) {
    __memzero(array_ptr, array_size);
  }  /* if */
#endif /* ABI_COMPATIBILITY_VERSION >= 300 */
#if EXCEPTION_HANDLING
  if (create_eh_stack_entry) {
    add_vec_new_or_delete_eh_stack_entry(&ehse, &aaehi, /*is_vec_new=*/TRUE);
    aaehi.free_memory_on_cleanup = free_memory_on_cleanup;
    aaehi.number_of_elements     = number_of_elements;
    aaehi.element_size           = element_size;
    aaehi.prefix_size            = prefix_size;
    aaehi.destructor		 = dtor;
    aaehi.delete_routine	 = delete_routine;
    aaehi.is_two_arg		 = is_two_arg;
    aaehi.array_ptr              = array_ptr;
#ifdef __EDG_IA64_ABI
    aaehi.terminate_immediately  = FALSE;
#endif /* defined(__EDG_IA64_ABI) */
  }  /* if */
#endif /* EXCEPTION_HANDLING */
  /* Call the constructor, if any, for each member of the array.  Note that
     there may be zero elements.  Cfront tacks on what appears to be eight
     additional NULL values to be used as the addresses of the first
     eight virtual base classes.  The EDG compiler generates a special wrapper
     for use by vec_new and doesn't need the additional arguments.  The
     additional arguments here allow cfront-generated vec_new calls to
     be used with this vec_new. */
  if (ctor != NULL) {
    for (i = 0, arr_ptr = array_ptr;
         i < number_of_elements;
         i++, increment_ptr(arr_ptr, element_size)) {
     if (src_array_ptr == NULL) {
       /* Call the default constructor. */
#if CFRONT_COMPATIBILITY_MODE
        a_cfront_constructor_ptr	cfront_ctor;
        cfront_ctor = (a_cfront_constructor_ptr)ctor;
        (*cfront_ctor)(arr_ptr, (void *)0, (void *)0, (void *)0, (void *)0,
                       (void *)0, (void *)0, (void *)0, (void *)0);
#else /* CFRONT_COMPATIBILITY_MODE */
        (*ctor)(arr_ptr); 
#endif /* CFRONT_COMPATIBILITY_MODE */
      } else {
        /* Call the copy constructor. */
        a_copy_constructor_ptr	cctor;
        cctor = (a_copy_constructor_ptr)ctor;
        (*cctor)(arr_ptr, src_array_ptr);
      }  /* if */
#if EXCEPTION_HANDLING
      if (dtor != NULL) {
        /* Update the counter of the number of elements processed in the
           EH stack entry. */
        aaehi.elements_processed++;
      }  /* if */
#endif /* EXCEPTION_HANDLING */
      /* Go to the next element in the source array when the constructor
         being called is a copy constructor. */
      if (src_array_ptr != NULL) increment_ptr(src_array_ptr, element_size);
    }  /* for */
  }  /* if */
#if EXCEPTION_HANDLING
  if (create_eh_stack_entry) {
    /* Unlink the vec_new EH stack entry. */
    __curr_eh_stack_entry = __curr_eh_stack_entry->next;
  }  /* if */
#endif /* EXCEPTION_HANDLING */
error_exit:
  /* Return the pointer to the array. */
  return array_ptr;
}  /* array_new_general */

#ifndef __EDG_IA64_ABI
#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE
EXTERN_C void *__array_new(size_t                       number_of_elements,
                           size_t                       element_size,
                           a_constructor_ptr	 	ctor,
                           a_destructor_ptr	        dtor,
			   a_new_ptr		 	new_routine,
                           a_delete_ptr          	delete_routine,
			   int			 	is_two_arg)
/*
This entry point is used for operations that use class specific array
new and delete operators.  The new and delete routines are pointed to
by new_routine and delete_routine.  is_two_arg is TRUE if the delete
routine is one that requires two arguments.
*/
{
  return (array_new_general((void*)NULL, number_of_elements, element_size,
                            __array_new_prefix_size, (void*)NULL, ctor, dtor,
                            new_routine, delete_routine, is_two_arg,
                            /*zero_init=*/FALSE));
}  /* __array_new */
#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */


#if ABI_COMPATIBILITY_VERSION >= 234
EXTERN_C void *__placement_array_new(
			   void				*array_ptr,
			   size_t                       number_of_elements,
                           size_t                       element_size,
                           a_constructor_ptr	 	ctor,
                           a_destructor_ptr	        dtor)
/*
This entry point is used for placement array new operations.  The actual
memory is allocated by a call to the appropriate new routine before
this routine is called.  This routine is used to record the array size
information and to call the constructor for each array element.
*/
{
  return (array_new_general(array_ptr, number_of_elements, element_size,
                            __array_new_prefix_size, (void*)NULL, ctor, dtor,
                            (a_new_ptr)NULL, (a_delete_ptr)NULL,
                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));
}  /* __placement_array_new */
#endif /* ABI_COMPATIBILITY_VERSION >= 234 */



EXTERN_C void *__vec_new_eh(void                         *array_ptr,
                            size_t                       number_of_elements,
                            size_t                       element_size,
                            a_constructor_ptr	 	 ctor,
                            a_destructor_ptr	         dtor)
/*
This entry point is used by code that uses exception handling for
new operations that do not involve the use of a class specific
operator new.
*/
{
  return (array_new_general(array_ptr, number_of_elements, element_size,
                            (array_ptr == NULL) ? __array_new_prefix_size : 0,
                            (void*)NULL, ctor, dtor,
                            (a_new_ptr)NULL, (a_delete_ptr)NULL,
                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));
}  /* __vec_new_eh */


EXTERN_C void *__vec_new(void                         *array_ptr,
                         size_t                       number_of_elements,
                         size_t                       element_size,
                         a_constructor_ptr            ctor)
/*
This is an entry point used for compatibility with code generated
before EH was supported.  This is similar to vec_new_eh, except that
no destructor pointer is provided.
*/
{
  return (array_new_general(array_ptr, number_of_elements, element_size,
                            (array_ptr == NULL) ? __array_new_prefix_size : 0,
                            (void*)NULL, ctor, (a_destructor_ptr)NULL, 
                            (a_new_ptr)NULL, (a_delete_ptr)NULL,
                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));
}  /* __vec_new */


EXTERN_C void __vec_cctor_eh(void                       *array_ptr,
                             size_t                     number_of_elements,
                             size_t                     element_size,
                             a_copy_constructor_ptr	ctor,
                	     void                       *src_array_ptr,
                             a_destructor_ptr		dtor)
/*
This is an entry point to array_new_general used to call the copy
constructor for each element of an array.  The corresponding element of
the array pointed to by src_array_ptr is the source operand for the
copy constructor.  Because this runtime routine will only be called for
constructor initialization of member arrays, the number_of_elements
can never be zero.
*/
{
  (void)array_new_general(array_ptr, number_of_elements, element_size,
                          (array_ptr == NULL) ? __array_new_prefix_size : 0,
                          src_array_ptr, (a_constructor_ptr)ctor, dtor, 
                          (a_new_ptr)NULL, (a_delete_ptr)NULL,
                          /*is_two_arg=*/FALSE, /*zero_init=*/FALSE);
}  /* __vec_cctor_eh */


#if ABI_COMPATIBILITY_VERSION >= 300
EXTERN_C void *__array_new_zero(size_t                number_of_elements,
                                size_t                element_size,
                                a_constructor_ptr     ctor,
                                a_destructor_ptr      dtor,
                                a_new_ptr             new_routine,
                                a_delete_ptr          delete_routine,
                                int                   is_two_arg)
/*
This entry point is used for operations requiring value-initialization.
In such cases, memory is zeroed before calling a (default) constructor
on it.  See array_new_general for the meaning of the parameters.
*/
{
  return (array_new_general((void*)NULL, number_of_elements, element_size,
                            __array_new_prefix_size, (void*)NULL, ctor, dtor,
                            new_routine, delete_routine, is_two_arg,
                            /*zero_init=*/TRUE));
}  /* __array_new_zero */


EXTERN_C void *__placement_array_new_zero(
                                        void               *array_ptr,
                                        size_t             number_of_elements,
                                        size_t             element_size,
                                        a_constructor_ptr  ctor,
                                        a_destructor_ptr   dtor)
/*
This entry point is used for placement array new operations requiring value-
initialization.  The actual memory is allocated by a call to the appropriate
new routine before this routine is called.  This routine is used to record
the array size information and to call the constructor for each array element.
*/
{
  return (array_new_general(array_ptr, number_of_elements, element_size,
                            __array_new_prefix_size, (void*)NULL, ctor, dtor,
                            (a_new_ptr)NULL, (a_delete_ptr)NULL,
                            /*is_two_arg=*/FALSE, /*zero_init=*/TRUE));
}  /* __placement_array_new_zero */


EXTERN_C void *__vec_new_eh_zero(void               *array_ptr,
                                 size_t             number_of_elements,
                                 size_t             element_size,
                                 a_constructor_ptr  ctor,
                                 a_destructor_ptr   dtor)
/*
This entry point is used by code that uses exception handling for
new operations that do not involve the use of a class specific
operator new but that require memory to be zeroed before the default
constructor is called.
*/
{
  return (array_new_general(array_ptr, number_of_elements, element_size,
                            (array_ptr == NULL) ? __array_new_prefix_size : 0,
                            (void*)NULL, ctor, dtor, (a_new_ptr)NULL, 
                            (a_delete_ptr)NULL, /*is_two_arg=*/FALSE, 
                            /*zero_init=*/TRUE));
}  /* __vec_new_eh_zero */
#endif /* ABI_COMPATIBILITY_VERSION >= 300 */
#else /* defined(__EDG_IA64_ABI) */
EXTERN_C void *ABI_NAMESPACE::__cxa_vec_new(
                                         size_t            number_of_elements,
                                         size_t            element_size,
                                         size_t            prefix_size,
                                         a_constructor_ptr ctor,
                                         a_destructor_ptr  dtor)
/*
The entry point used for ordinary array new.
*/
{
  return (array_new_general((void *)NULL, (int)number_of_elements,
                            element_size, prefix_size, (void *)NULL,
                            ctor, dtor, (a_new_ptr)NULL, (a_delete_ptr)NULL,
                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));
}  /* __cxa_vec_new */


EXTERN_C void *ABI_NAMESPACE::__cxa_vec_new2(
                                         size_t            number_of_elements,
                                         size_t            element_size,
                                         size_t            prefix_size,
                                         a_constructor_ptr ctor,
                                         a_destructor_ptr  dtor,
                                         a_new_ptr         new_routine,
                                         a_delete_ptr      delete_routine)
/*
The entry point used for array new with class-specific new and delete
operators.
*/
{
  return (array_new_general((void *)NULL, (int)number_of_elements,
                            element_size, prefix_size, (void *)NULL,
                            ctor, dtor, new_routine, delete_routine,
                            /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));
}  /* __cxa_vec_new2 */


EXTERN_C void *ABI_NAMESPACE::__cxa_vec_new3(
                                  size_t                   number_of_elements,
                                  size_t                   element_size,
                                  size_t                   prefix_size,
                                  a_constructor_ptr        ctor,
                                  a_destructor_ptr         dtor,
                                  a_new_ptr                new_routine,
                                  a_two_operand_delete_ptr delete_routine)
/*
The entry point used for array new with class-specific new and delete
operators where the delete operator, if any, takes two arguments.
*/
{
  return (array_new_general((void *)NULL, (int)number_of_elements,
                            element_size, prefix_size, (void *)NULL,
                            ctor, dtor, new_routine, 
                            (a_delete_ptr)delete_routine,
                            /*is_two_arg=*/TRUE, /*zero_init=*/FALSE));
}  /* __cxa_vec_new3 */


EXTERN_C void ABI_NAMESPACE::__cxa_vec_ctor(
                                         void              *array_ptr,
                                         size_t            number_of_elements,
                                         size_t            element_size,
                                         a_constructor_ptr ctor,
                                         a_destructor_ptr  dtor)
/*
The entry point used for constructing an array of objects where the memory has
already been allocated.
*/
{
  (void)(array_new_general(array_ptr, (int)number_of_elements,
                           element_size, /*prefix_size=*/0, (void *)NULL,
                           ctor, dtor, (a_new_ptr)NULL, (a_delete_ptr)NULL,
                           /*is_two_arg=*/FALSE, /*zero_init=*/FALSE));
}  /* __cxa_vec_ctor */


EXTERN_C void ABI_NAMESPACE::__cxa_vec_cctor(
                                    void                   *array_ptr,
                                    void                   *src_array_ptr,
                                    size_t                 number_of_elements,
                                    size_t                 element_size,
                                    a_copy_constructor_ptr ctor,
                                    a_destructor_ptr       dtor)
/*
The entry point used for copying an array of objects.
*/
{
  (void)(array_new_general(array_ptr, (int)number_of_elements,
                           element_size, /*prefix_size=*/0, src_array_ptr,
                           (a_constructor_ptr)ctor, dtor, (a_new_ptr)NULL,
                            (a_delete_ptr)NULL, /*is_two_arg=*/FALSE, 
                            /*zero_init=*/FALSE));
}  /* __cxa_vec_cctor */

#endif /* defined(__EDG_IA64_ABI) */

#if EXCEPTION_HANDLING
EXTERN_C void __cleanup_vec_new_or_delete(an_eh_stack_entry_ptr ehsep)
/*
Called by the exception handling cleanup routine to do the cleanup
processing for a vec_new or vec_delete operation that was interrupted by
an exception.
*/
{
  /* Call the destructor, if specified, on each element in the array, in
     reverse order. */
  an_array_alloc_eh_info_ptr	aaehip = ehsep->variant.array_alloc_eh_info;
  a_destructor_ptr		dtor = aaehip->destructor;
  a_sizeof_t			number_of_elements;
  a_sizeof_t			element_size;
  void*               		arr_ptr;
  void*				array_ptr;
  a_sizeof_t			i;
  a_sizeof_t		        first_element;

#ifdef __EDG_IA64_ABI
  if (aaehip->terminate_immediately) {
    __call_terminate();
  }  /* if */
#endif /* defined(__EDG_IA64_ABI) */
  array_ptr = (void *)aaehip->array_ptr;
  element_size = aaehip->element_size;
  if (aaehip->is_vec_new) {
    /* Cleaning up a vec_new.  Destroy the fully constructed elements of
       the array in reverse order. */
    number_of_elements = aaehip->elements_processed;
    first_element = number_of_elements - 1;
  } else {
    first_element = aaehip->number_of_elements -
                    aaehip->elements_processed - 1;
    number_of_elements = first_element + 1;
  }  /* if */
  if (dtor != NULL) {
    /* If there is a destructor, destroy the objects. */
    for (i = 0,
         arr_ptr = (void *)(((char *)array_ptr) +
                                                first_element * element_size);
         i < number_of_elements;
         i++, increment_ptr(arr_ptr, -(int)(element_size))) {
#ifndef __EDG_IA64_ABI
      /* Call the destructor with 0x2 - whole object = TRUE
                                  0x1 - delete object = FALSE. */
      (*dtor)(arr_ptr, 0x2 /*whole object = TRUE, delete = FALSE*/);
#else /* ifdef __EDG_IA64_ABI */
      (*dtor)(arr_ptr);
#endif /* ifdef __EDG_IA64_ABI */
    }  /* for */
  }  /* if */
  if (aaehip->free_memory_on_cleanup) {
    /* Call the routine to free the memory. */
    size_t	size = element_size * aaehip->number_of_elements;
    free_array(array_ptr, size, aaehip->prefix_size,
               aaehip->delete_routine, aaehip->is_two_arg);
  }  /* if */
}  /* __cleanup_vec_new_or_delete */
#endif /* EXCEPTION_HANDLING */


#ifndef __EDG_IA64_ABI
/*ARGSUSED*/ /* terminate_immediately is used only in the IA-64 ABI. */
#endif /* ifndef __EDG_IA64_ABI */
static void array_delete_general(void                *array_ptr,
                                 size_t              number_of_elements,
                                 size_t              element_size,
                                 size_t              prefix_size,
                                 a_destructor_ptr    dtor,
				 int		     delete_flag,
                                 a_delete_ptr	     delete_routine,
				 int		     is_two_arg,
                                 int                 terminate_immediately)
                                     
/*
Call a destructor for each element of an array, then delete the storage
for the array.  array_ptr points to the array, which has number_of_elements
elements each of size element_size.  If number_of_elements is -1, use the
size stored by vec_new at the time of allocation of this array.  In that case,
the size of the prefix is given by prefix_size.  If array_ptr is NULL, this
routine does nothing and returns.  If dtor is non-NULL, it points to a
destructor function to be called for each element of the array.  If
delete_flag is TRUE, the storage for the array is deallocated after the
destruction; number_of_elements must be -1 for that case.  If
terminate_immediately is TRUE, std::terminate will be called if any of the
destructor elements throws an exception; otherwise, the remainder of the
elements will be destroyed and the exception will be rethrown.
*/
{
  int                   i;
  void                  *arr_ptr;
  size_t		array_size = 0;

  /* If the address of the array is NULL, do nothing. */
  if (array_ptr != NULL ) {
#if EXCEPTION_HANDLING
    an_eh_stack_entry		ehse;
    an_array_alloc_eh_info	aaehi;
    add_vec_new_or_delete_eh_stack_entry(&ehse, &aaehi, 
                                         /*is_vec_new=*/FALSE);
    aaehi.free_memory_on_cleanup = delete_flag;
    aaehi.array_ptr              = array_ptr;
    aaehi.number_of_elements     = number_of_elements;
    aaehi.element_size           = element_size;
    aaehi.prefix_size            = prefix_size;
    aaehi.destructor		 = dtor;
    aaehi.delete_routine	 = delete_routine;
    aaehi.is_two_arg		 = is_two_arg;
#ifdef __EDG_IA64_ABI
    aaehi.terminate_immediately  = terminate_immediately;
#endif /* defined(__EDG_IA64_ABI) */
#endif /* EXCEPTION_HANDLING */
    /* Determine the number of elements in the array, if unknown. */
    if (number_of_elements == (size_t)-1 && prefix_size != 0) {
      /* Determine the number of elements from the memory allocation size. */
      array_size = get_array_size(array_ptr, element_size);
      number_of_elements = array_size / element_size;
    }  /* if */
#if EXCEPTION_HANDLING
    aaehi.number_of_elements     = number_of_elements;
#endif /* EXCEPTION_HANDLING */

    /* Call the destructor, if specified, on each element in the array, in
       reverse order. */
    if (dtor != NULL) {
      for (i = 0,
           arr_ptr = (void*)((char*)array_ptr +
                             (number_of_elements - 1) * element_size);
           i < number_of_elements;
           i++, increment_ptr(arr_ptr, -(int)(element_size))) {
#if EXCEPTION_HANDLING
        /* Update the counter of the number of elements processed in the
           EH stack entry.  This is incremented before the destructor is
           called so that, should an exception occur, we won't try
           destroying this element again. */
        aaehi.elements_processed++;
#endif /* EXCEPTION_HANDLING */
#ifndef __EDG_IA64_ABI
        /* Call the destructor with 0x2 - whole object = TRUE
                                    0x1 - delete object = FALSE. */
        (*dtor)(arr_ptr, 0x2 /*whole object = TRUE, delete = FALSE*/);
#else /* defined(__EDG_IA64_ABI) */
        (*dtor)(arr_ptr);
#endif /* defined(__EDG_IA64_ABI) */
      }  /* for */
    }  /* if */
#if EXCEPTION_HANDLING
    /* Unlink the vec_new EH stack entry.  This is unlinked before the memory
       for the array is freed.  If an exception occurs during the free
       it should just be handled by the normal mechanism. */
    __curr_eh_stack_entry = __curr_eh_stack_entry->next;
#endif /* EXCEPTION_HANDLING */
    /* Delete the array, if requested. */
    if (delete_flag) {
      free_array(array_ptr, array_size, prefix_size, delete_routine,
                 is_two_arg);
    }  /* if */
  }  /* if */
}  /* array_delete_general */

#ifndef __EDG_IA64_ABI
/*ARGSUSED*/ /* <-- "unused" is unused. */
EXTERN_C void __vec_delete(void                *array_ptr,
                           size_t              number_of_elements,
                           size_t              element_size,
                           a_destructor_ptr    dtor,
                           int                 delete_flag,
                           int                 unused)
/*
Entry point used for the normal vector delete operation.  The unused
parameter is there for cfront compatibility.
*/
{
  array_delete_general(array_ptr, number_of_elements, element_size, 
                       (number_of_elements == (size_t)-1) ? 
                                                 __array_new_prefix_size : 0,
                       dtor, delete_flag, (a_delete_ptr)NULL,
                       /*is_two_arg=*/FALSE, /*terminate_immediately=*/FALSE);
}  /* __vec_delete */


#if ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE
EXTERN_C void __array_delete(void                *array_ptr,
                             size_t              number_of_elements,
                             size_t              element_size,
                             a_destructor_ptr    dtor,
                             a_delete_ptr	 delete_routine,
			     int		 is_two_arg)
/*
This entry point is used for operations that use class specific array
new and delete operators.  The delete routine is pointed to
by delete_routine.  is_two_arg is TRUE if the delete routine is one that
requires two arguments.
*/
{
  array_delete_general(array_ptr, number_of_elements, element_size, 
                       (number_of_elements == (size_t)-1) ? 
                                                __array_new_prefix_size : 0,
                       dtor, /*delete_flag=*/TRUE, delete_routine, 
                       is_two_arg, /*terminate_immediately=*/FALSE);
}  /* __array_delete */
#endif /* ABI_CHANGES_FOR_ARRAY_NEW_AND_DELETE */
#else /* defined(__EDG_IA64_ABI) */
EXTERN_C void ABI_NAMESPACE::__cxa_vec_dtor(
                                          void             *array_ptr,
                                          size_t           number_of_elements,
                                          size_t           element_size,
                                          a_destructor_ptr dtor)
/*
Run the destructors for an array of objects.
*/
{
  array_delete_general(array_ptr, number_of_elements, element_size,
                       /*prefix_size=*/0, dtor, /*delete_flag=*/FALSE,
                       (a_delete_ptr)NULL, /*is_two_arg=*/FALSE,
                       /*terminate_immediately=*/FALSE);
}  /* __cxa_vec_dtor */


EXTERN_C void ABI_NAMESPACE::__cxa_vec_delete(void             *array_ptr,
                                              size_t           element_size,
                                              size_t           prefix_size,
                                              a_destructor_ptr dtor)
/*
The entry point for ordinary array delete.
*/
{
  array_delete_general(array_ptr, (size_t)/*number_of_elements=*/-1, element_size,
                       prefix_size, dtor, /*delete_flag=*/TRUE,
                       (a_delete_ptr)NULL, /*is_two_arg=*/FALSE,
                       /*terminate_immediately=*/FALSE);
}  /* __cxa_vec_delete */


EXTERN_C void ABI_NAMESPACE::__cxa_vec_delete2(void             *array_ptr,
                                               size_t           element_size,
                                               size_t           prefix_size,
                                               a_destructor_ptr dtor,
                                               a_delete_ptr     delete_routine)
/*
The entry point for array delete with a class-specific operator delete.
*/
{
  array_delete_general(array_ptr, (size_t)/*number_of_elements=*/-1, element_size,
                       prefix_size, dtor, /*delete_flag=*/TRUE,
                       delete_routine, /*is_two_arg=*/FALSE,
                       /*terminate_immediately=*/FALSE);
}  /* __cxa_vec_delete2 */


EXTERN_C void ABI_NAMESPACE::__cxa_vec_delete3(
                                     void                     *array_ptr,
                                     size_t                   element_size,
                                     size_t                   prefix_size,
                                     a_destructor_ptr         dtor,
                                     a_two_operand_delete_ptr delete_routine)
/*
The entry point for array delete with a two-argument class-specific operator
delete.
*/
{
  array_delete_general(array_ptr, (size_t)/*number_of_elements=*/-1, element_size,
                       prefix_size, dtor, /*delete_flag=*/TRUE,
                       (a_delete_ptr)delete_routine, /*is_two_arg=*/TRUE,
                       /*terminate_immediately=*/FALSE);
}  /* __cxa_vec_delete3 */


EXTERN_C void ABI_NAMESPACE::__cxa_vec_cleanup(
					void             *array_ptr,
					size_t           number_of_elements,
					size_t           element_size,
					a_destructor_ptr dtor)
/*
The entry point used to invoke the destructor on an array of objects,
and to invoke terminate if a destructor exits with a throw.
*/
{
  if (dtor != NULL) {
    array_delete_general(array_ptr, number_of_elements, element_size,
                         /*prefix_size=*/0, dtor, /*delete_flag=*/FALSE,
                         (a_delete_ptr)NULL, /*is_two_arg=*/FALSE,
                         /*terminate_immediately=*/TRUE);
  }  /* if */
}  /* __cxa_vec_cleanup */

#endif /* defined(__EDG_IA64_ABI) */

#ifndef __EDG_IA64_ABI                                     
EXTERN_C void _array_pointer_not_from_vec_new()
/*
This routine is used when a pointer that was not created by vec_new is
passed to one other vector handling routines that needs to get the size
from the information created by vec_new.  This routine simply aborts.
The name is intended to describe the nature of the problem to the user
*/
{
  __abort_execution(ec_array_not_from_vec_new);
}
#endif /* ifndef __EDG_IA64_ABI */
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

vec_newdel.h/   1146129411  0     0     0       3012      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Declarations for runtime routines for vector new() and delete() functionality.

*/

#ifndef VEC_NEWDEL_H
#define VEC_NEWDEL_H

#include "runtime.h"

#ifndef __EDG_IA64_ABI

EXTERN_C void *__vec_new_eh(void                         *array_ptr,
                            size_t                          number_of_elements,
                            size_t                       element_size,
                            a_constructor_ptr	 	 ctor,
                            a_destructor_ptr	         dtor);

EXTERN_C void *__vec_new(void                         *array_ptr,
                         size_t                          number_of_elements,
                         size_t                       element_size,
                         a_constructor_ptr            ctor);

EXTERN_C void __vec_delete(void                *array_ptr,
                           size_t              number_of_elements,
                           size_t              element_size,
                           a_destructor_ptr    dtor,
                           int                 delete_flag,
                           int                 /*unused_arg*/);

EXTERN_C void _array_pointer_not_from_vec_new();

#endif /* ifdef __EDG_IA64_ABI */

/*
Type name used by the exception handling mechanism to point to the
structure used to maintain information about array new and delete
operations that are in process.
*/
typedef struct an_array_alloc_eh_info *an_array_alloc_eh_info_ptr;

#endif /* ifndef VEC_NEWDEL_H */

/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
vfprintf.c/     1146129411  0     0     0       2788      `
/*****************************************************************************/
/*  VFRINTF.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VFPRINTF -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include "format.h"
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
/*****************************************************************************/
/* VFPRINTF -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int vfprintf(FILE *_fp, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   return (_printfi(&fptr, _ap, (void *)_fp, _outc, _outs));
 
}
 
/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }
vprintf.c/      1146129411  0     0     0       2793      `
/*****************************************************************************/
/*  VPRINTF.C v4.1.3                                                         */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VPRINTF  -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 

/*****************************************************************************/
/* VPRINTF  -  Print formatted output to a stdio                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int vprintf(const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (EOF);

   return (_printfi(&fptr, _ap, (void *)stdout, _outc, _outs));
 
}
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


vsprintf.c/     1146129411  0     0     0       2711      `
/*****************************************************************************/
/*  VSPRINTF.C v4.1.3                                                        */
/*  Copyright (c) 1995-2006 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VSPRINTF -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);


/*****************************************************************************/
/* VSPRINTF -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a format string and an argument list to           */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int vsprintf(char *_string, const char *_format, va_list _ap)
{
    int   rval;
    char *fptr = (char *)_format;
    char *out_end = _string;

    rval = _printfi(&fptr, _ap, (void *)&out_end, _outc, _outs);

    *out_end = '\0';

    return rval;
}


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
    return *(*((char **)_op))++ = c;
}
 

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
    size_t len = strlen(s);
    
    memcpy(*((char **)_op), s, len);
    *((char **)_op) += len;
    return len;
}
 

vtbl.h/         1146129411  0     0     0       2841      `
/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/
/*

Virtual function table entry layout.

*/

#ifndef _VTBL_H
#define _VTBL_H

#ifndef __EDG_IA64_ABI
#if 1
   struct a_vtbl_entry
   {
      short   delta;      /* OFFSET TO GET TO THE COMPLETE OBJECT   */
      void  (*func)();    /* VIRTUAL FUNCTION TO BE CALLED          */
   };
#else
struct a_vtbl_entry {
  __EDG_DELTA_TYPE
		delta;
			/* Value to be added to the "this" pointer to adjust
			   it to point to the class for which the virtual
			   function is actually defined. */
  __EDG_VIRTUAL_FUNCTION_INDEX_TYPE
		index;
			/* Index into the virtual function table.  Only
			   used in member function pointers, not present in
			   vtbl entries.  Cfront uses the same structure for
		  	   both member pointers and vtbl entries, so this is
			   present for cfront compatibility. */
  union {
    a_void_function_ptr
		ptr;
			/* Pointer to the function to be called. */
    a_type_info_impl_ptr
		type_info_impl;
			/* Pointer to the type information implementation
			   entry.  This is present in slot zero of the
			   virtual function table. */
  } function;
};
#endif
#else /* defined(__EDG_IA64_ABI) */

typedef __EDG_DELTA_TYPE a_vtbl_entry;

#endif /* defined(__EDG_IA64_ABI) */

typedef 
/*** START TI ADD ***/
const  
/*** END TI ADD ***/
a_vtbl_entry *a_vtbl_entry_ptr;

#endif /* ifndef _VTBL_H */


/******************************************************************************
*                                                             \  ___  /       *
*                                                               /   \         *
* Edison Design Group C++  Runtime                           - | \^/ | -      *
* Copyright 1993-2004 Edison Design Group, Inc.                 \   /         *
* All rights reserved.  Consult your license regarding        /  | |  \       *
* permissions and restrictions.                                  [_]          *
*                                                                             *
******************************************************************************/

